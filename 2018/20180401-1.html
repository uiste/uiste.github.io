<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.4.2" rel="stylesheet" type="text/css">













<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.4.2',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="时间复杂度 时间复杂度的算法具体步骤是：⑴ 找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。⑵ 计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。⑶ 用大Ο记号表示算法的时间性能。">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP细节-03">
<meta property="og:url" content="http://blog.uiste.com/2018/20180401-1.html">
<meta property="og:site_name" content="uiste">
<meta property="og:description" content="时间复杂度 时间复杂度的算法具体步骤是：⑴ 找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。⑵ 计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。⑶ 用大Ο记号表示算法的时间性能。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-02T09:12:55.703Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP细节-03">
<meta name="twitter:description" content="时间复杂度 时间复杂度的算法具体步骤是：⑴ 找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。⑵ 计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。⑶ 用大Ο记号表示算法的时间性能。">



  <link rel="alternate" href="/atom.xml" title="uiste" type="application/atom+xml">




  <link rel="canonical" href="http://blog.uiste.com/2018/20180401-1.html">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>PHP细节-03 | uiste</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">uiste</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <h1 class="site-subtitle" itemprop="description">uiste</h1>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>
  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    <!--  -->
    
    
    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.uiste.com/2018/20180401-1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="uiste">
      <meta itemprop="description" content="Stay Hungry，Stay Foolish">
      <meta itemprop="image" content="/images/default_avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="uiste">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">PHP细节-03
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-04-01 08:55:26" itemprop="dateCreated datePublished" datetime="2018-04-01T08:55:26+08:00">2018-04-01</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><blockquote>
<p>时间复杂度的算法具体步骤是：<br>⑴ 找出算法中的基本语句；<br>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。<br>⑵ 计算基本语句的执行次数的数量级；<br>只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。<br>⑶ 用大Ο记号表示算法的时间性能。<br>将基本语句执行次数的数量级放入大Ο记号中。<br>如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i=1; i&lt;=n; i++)  </span><br><span class="line">       x++;  </span><br><span class="line">for (i=1; i&lt;=n; i++)  </span><br><span class="line">    　for (j=1; j&lt;=n; j++)  </span><br><span class="line">          x++;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。<br>Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。</p>
</blockquote>
<h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h1><p>try内部正常执行try的内部逻辑，异常则执行catch的内部逻辑结构，但是不管执行的哪个都会执行完try catch的内部逻辑（非return）后执行finally的内部逻辑。</p>
<p>如果try catch都有return，按照正常执行，然后执行finally的逻辑，再返回对应的try 或者catch里执行return。</p>
<p>如果try catch finally都有return，执行完finally的逻辑后，会调用finally的return。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">    public function testTry()</span><br><span class="line">    &#123;</span><br><span class="line">        $i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            $i = $i + 1;</span><br><span class="line">            return $i;</span><br><span class="line">        &#125; catch (Exception $e) &#123;</span><br><span class="line">            echo &quot;wc&quot;;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            $i = $i + 2;</span><br><span class="line">            // print_r($i);</span><br><span class="line">            return &quot;1111&quot;;//当finally有return的时候 返回这个，当注销后，返回try 或者是 catch的内容。</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$b = new test();</span><br><span class="line">echo $b-&gt;testTry();</span><br><span class="line"></span><br><span class="line"># 1111[Finished in 0.4s]</span><br></pre></td></tr></table></figure>
<h1 id="set-error-handle"><a href="#set-error-handle" class="headerlink" title="set_error_handle"></a>set_error_handle</h1><p>捕获 notice waring 等错误，放置回调函数处理</p>
<blockquote>
<p>E_ERROR,E_PARSE 等拦截不了的。使用 register_shutdown_function()回调函数处理任意类型错误。</p>
</blockquote>
<h1 id="trait-是一个新的特性"><a href="#trait-是一个新的特性" class="headerlink" title="trait 是一个新的特性"></a>trait 是一个新的特性</h1><p>Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace AlibabaCloud\Client\Regions;</span><br><span class="line"></span><br><span class="line">use AlibabaCloud\Client\Traits\EndpointTrait;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Class EndpointProvider</span><br><span class="line"> *</span><br><span class="line"> * @package    AlibabaCloud\Client\Regions</span><br><span class="line"> *</span><br><span class="line"> * @deprecated deprecated since version 2.0, Use AlibabaCloud instead.</span><br><span class="line"> */</span><br><span class="line">class EndpointProvider</span><br><span class="line">&#123;</span><br><span class="line">    use EndpointTrait;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="预定义接口"><a href="#预定义接口" class="headerlink" title="预定义接口"></a>预定义接口</h1><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><h2 id="Aggregate-集合体"><a href="#Aggregate-集合体" class="headerlink" title="Aggregate 集合体"></a>Aggregate 集合体</h2><h2 id="Yield-生成器"><a href="#Yield-生成器" class="headerlink" title="Yield    生成器"></a>Yield    生成器</h2><h2 id="IteratorAggregate"><a href="#IteratorAggregate" class="headerlink" title="IteratorAggregate"></a>IteratorAggregate</h2><h1 id="魔术常量"><a href="#魔术常量" class="headerlink" title="魔术常量"></a>魔术常量</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1). __FILE__                当前文件路径</span><br><span class="line">(2). __DIR__                  当前文件目录</span><br><span class="line">(3). __LINE__                 在文件文件的那一行 </span><br><span class="line">(4). __FUNCTION__       在当前文件的那个函数中       返回 函数名</span><br><span class="line">(5). __CLASS__             在当前文件中的那个类中       返回 类名</span><br><span class="line">(6). __METHOD__          在当前文件的类中的那个方法中 返回 类名::方法名</span><br></pre></td></tr></table></figure>
<h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__construct()，类的构造函数</span><br><span class="line">__destruct()，类的析构函数</span><br><span class="line">__call()，在对象中调用一个不可访问方法时调用</span><br><span class="line">__callStatic()，用静态方式中调用一个不可访问方法时调用</span><br><span class="line">__get()，获得一个类的成员变量时调用</span><br><span class="line">__set()，设置一个类的成员变量时调用</span><br><span class="line">__isset()，当对不可访问属性调用isset()或empty()时调用</span><br><span class="line">__unset()，当对不可访问属性调用unset()时被调用。</span><br><span class="line">__sleep()，执行serialize()时，先会调用这个函数</span><br><span class="line">__wakeup()，执行unserialize()时，先会调用这个函数</span><br><span class="line">__toString()，类被当成字符串时的回应方法</span><br><span class="line">__invoke()，调用函数的方式调用一个对象时的回应方法</span><br><span class="line">__set_state()，调用var_export()导出类时，此静态方法会被调用。</span><br><span class="line">__clone()，当对象复制完成时调用</span><br><span class="line">__autoload()，尝试加载未定义的类</span><br><span class="line">__debugInfo()，打印所需调试信息</span><br></pre></td></tr></table></figure>
<p>范例<br>下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。</p>
<p>一、 <code>__construct()</code>，类的构造函数</p>
<p>php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。</p>
<p>1、 构造方法的作用</p>
<p>通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。</p>
<p>2、 构造方法的在类中的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __constrct([参数列表])&#123;</span><br><span class="line"> </span><br><span class="line">  方法体 //通常用来对成员属性进行初始化赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、 在类中声明构造方法需要注意的事项</p>
<p>1、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。</p>
<p>2、构造方法名称是以两个下画线开始的<code>__construct()</code><br>下面是它的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  class Person</span><br><span class="line">  &#123;                                   </span><br><span class="line">      public $name;    </span><br><span class="line">      public $age;    </span><br><span class="line">      public $sex;    </span><br><span class="line">                                  </span><br><span class="line">    /**</span><br><span class="line">     * 显示声明一个构造方法且带参数</span><br><span class="line">     */                                           </span><br><span class="line">    public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">    &#123;   </span><br><span class="line">      $this-&gt;name = $name;</span><br><span class="line">      $this-&gt;sex = $sex;</span><br><span class="line">      $this-&gt;age = $age;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    /**</span><br><span class="line">     * say 方法</span><br><span class="line">     */</span><br><span class="line">    public function say()</span><br><span class="line">    &#123; </span><br><span class="line">      echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age;</span><br><span class="line">    &#125;  </span><br><span class="line">                                               </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person1且不带任参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person1 = new Person();</span><br><span class="line">echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27</span><br></pre></td></tr></table></figure></p>
<p>创建对象$Person2且带参数“小明”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person2 = new Person(&quot;小明&quot;);</span><br><span class="line">echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27</span><br></pre></td></tr></table></figure>
<p>创建对象$Person3且带三个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);</span><br><span class="line">echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25</span><br></pre></td></tr></table></figure>
<p>二、<code>__destruct()</code>，类的析构函数<br>通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。</p>
<p>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
<p>析构方法是PHP5才引进的新内容。</p>
<p>析造方法的声明格式与构造方法 <code>__construct()</code> 比较类似，也是以两个下划线开始的方法 <code>__destruct()</code> ，这种析构方法名称也是固定的。</p>
<p>1、 析构方法的声明格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __destruct()</span><br><span class="line">&#123;</span><br><span class="line"> //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：析构函数不能带有任何参数。</p>
<p>2、 析构方法的作用</p>
<p>一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。<br>举例演示，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person&#123;   </span><br><span class="line">                             </span><br><span class="line">  public $name;     </span><br><span class="line">  public $age;     </span><br><span class="line">  public $sex;     </span><br><span class="line">                                   </span><br><span class="line">  public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22)</span><br><span class="line">  &#123;  </span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  /**</span><br><span class="line">   * say 说话方法</span><br><span class="line">   */</span><br><span class="line">  public function say()</span><br><span class="line">  &#123; </span><br><span class="line">    echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age;</span><br><span class="line">  &#125;  </span><br><span class="line">   </span><br><span class="line">  /**</span><br><span class="line">   * 声明一个析构方法</span><br><span class="line">   */</span><br><span class="line">  public function __destruct()</span><br><span class="line">  &#123;</span><br><span class="line">      echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">$Person = new Person(&quot;小明&quot;);</span><br><span class="line">unset($Person); //销毁上面创建的对象$Person</span><br></pre></td></tr></table></figure></p>
<p>上面的程序运行时输出：</p>
<p>我觉得我还可以再抢救一下，我的名字叫小明<br>三、 <code>__call()</code>，在对象中调用一个不可访问方法时调用。<br>该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。</p>
<p>1、 <code>__call()</code> 方法的格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function __call(string $function_name, array $arguments)</span><br><span class="line">&#123;</span><br><span class="line">  // 方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、 <code>__call()</code> 方法的作用：</p>
<p>为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 <code>__call()</code> 方法来避免。</p>
<p>该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。<br>请参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;               </span><br><span class="line">  function say()</span><br><span class="line">  &#123; </span><br><span class="line">                </span><br><span class="line">      echo &quot;Hello, world!&lt;br&gt;&quot;; </span><br><span class="line">  &#125;   </span><br><span class="line">     </span><br><span class="line">  /**</span><br><span class="line">   * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">   */</span><br><span class="line">  function __call($funName, $arguments)</span><br><span class="line">  &#123; </span><br><span class="line">     echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名</span><br><span class="line">     print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">     echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行           </span><br><span class="line">  &#125;                     </span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();      </span><br><span class="line">$Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;);       </span><br><span class="line">$Person-&gt;say();</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line"></span><br><span class="line">你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<p>四、 <code>__callStatic()</code>，用静态方式中调用一个不可访问方法时调用<br>此方法与上面所说的 <code>__call()</code> 功能除了 <code>__callStatic()</code> 是未静态方法准备的之外，其它都是一样的。</p>
<p>请看下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  function say()</span><br><span class="line">  &#123;</span><br><span class="line"> </span><br><span class="line">    echo &quot;Hello, world!&lt;br&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * 声明此方法用来处理调用对象中不存在的方法</span><br><span class="line">   */</span><br><span class="line">  public static function __callStatic($funName, $arguments)</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名</span><br><span class="line">    print_r($arguments); // 输出调用不存在的方法时的参数列表</span><br><span class="line">    echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person();</span><br><span class="line">$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法</span><br><span class="line">$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);</span><br><span class="line">$Person-&gt;say();</span><br><span class="line">运行结果如下：</span><br><span class="line"></span><br><span class="line">你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！</span><br><span class="line">你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></p>
<p>五、 <code>__get()</code>，获得一个类的成员变量时调用<br>在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 <code>__get()</code>。</p>
<p>魔术方法<code>__get()</code>的作用<br>在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。<br>我们通过下面的 <code>__get()</code> 的实例来更进一步的连接它吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  private $name;</span><br><span class="line">  private $age;</span><br><span class="line"> </span><br><span class="line">  function __construct($name=&quot;&quot;, $age=1)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理</span><br><span class="line">   * @param $propertyName</span><br><span class="line">   *</span><br><span class="line">   * @return int</span><br><span class="line">   */</span><br><span class="line">  public function __get($propertyName)</span><br><span class="line">  &#123;  </span><br><span class="line">    if ($propertyName == &quot;age&quot;) &#123;</span><br><span class="line">      if ($this-&gt;age &gt; 30) &#123;</span><br><span class="line">        return $this-&gt;age - 10;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return $this-&gt;$propertyName;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return $this-&gt;$propertyName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$Person = new Person(&quot;小明&quot;, 60);  // 通过Person类实例化的对象，并通过构造方法为属性赋初值</span><br><span class="line">echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;;  // 直接访问私有属性name，自动调用了__get()方法可以间接获取</span><br><span class="line">echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;;  // 自动调用了__get()方法，根据对象本身的情况会返回不同的值</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">姓名：小明</span><br><span class="line">年龄：50</span><br></pre></td></tr></table></figure></p>
<p>六、 <code>__set()</code>，设置一个类的成员变量时调用<br><code>__set()</code> 的作用：<br><code>__set( $property, $value )</code> 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。</p>
<p>请看下面的演示代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  private $name;</span><br><span class="line">  private $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值</span><br><span class="line">   * @param $property</span><br><span class="line">   * @param $value</span><br><span class="line">   */</span><br><span class="line">  public function __set($property, $value) &#123;</span><br><span class="line">    if ($property==&quot;age&quot;)</span><br><span class="line">    &#123;</span><br><span class="line">      if ($value &gt; 150 || $value &lt; 0) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $this-&gt;$property = $value;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * 在类中声明说话的方法，将所有的私有属性说出</span><br><span class="line">   */</span><br><span class="line">  public function say()&#123;</span><br><span class="line">    echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变</span><br><span class="line">//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数</span><br><span class="line">$Person-&gt;name = &quot;小红&quot;;   //赋值成功。如果没有__set()，则出错。</span><br><span class="line">//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数</span><br><span class="line">$Person-&gt;age = 16; //赋值成功</span><br><span class="line">$Person-&gt;age = 160; //160是一个非法值，赋值失效</span><br><span class="line">$Person-&gt;say(); //输出：我叫小红，今年16岁了</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">我叫小红，今年16岁了</span><br></pre></td></tr></table></figure></p>
<p>七、 <code>__isset()</code>，当对不可访问属性调用isset()或empty()时调用<br>在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。</p>
<p>那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？</p>
<p>分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个<strong>isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的</strong>isset()方法了帮我们完成这样的操作。</p>
<p><code>__isset()</code>的作用：当对不可访问属性调用 isset() 或 empty() 时，<code>__isset()</code> 会被调用。<br>请看下面代码演示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  private $name;</span><br><span class="line">  private $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * @param $content</span><br><span class="line">   *</span><br><span class="line">   * @return bool</span><br><span class="line">   */</span><br><span class="line">  public function __isset($content) &#123;</span><br><span class="line">    echo &quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;;</span><br><span class="line">    echo isset($this-&gt;$content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;</span><br><span class="line">echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;;</span><br><span class="line">运行结果如下：</span><br><span class="line"></span><br><span class="line">1 // public 可以 isset()</span><br><span class="line">当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br><span class="line">当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo</span><br><span class="line">1 // __isset() 内第二个echo</span><br></pre></td></tr></table></figure></p>
<p>八、 <code>__unset()</code>，当对不可访问属性调用unset()时被调用。<br>看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。</p>
<p>那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？</p>
<p>这里自然也是分两种情况：</p>
<p>1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。</p>
<p>2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。</p>
<p>虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上<code>__unset()</code>这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了<strong>unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用`</strong>unset()`函数来帮我们删除对象内部的私有成员属性。</p>
<p>请看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  private $name;</span><br><span class="line">  private $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * @param $content</span><br><span class="line">   *</span><br><span class="line">   * @return bool</span><br><span class="line">   */</span><br><span class="line">  public function __unset($content) &#123;</span><br><span class="line">    echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;;</span><br><span class="line">    echo isset($this-&gt;$content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&quot;小明&quot;, 25); // 初始赋值</span><br><span class="line">unset($person-&gt;sex);</span><br><span class="line">unset($person-&gt;name);</span><br><span class="line">unset($person-&gt;age);</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">当在类外部使用unset()函数来删除私有成员时自动调用的</span><br><span class="line">1当在类外部使用unset()函数来删除私有成员时自动调用的</span><br></pre></td></tr></table></figure></p>
<p>九、 <code>__sleep()</code>，执行serialize()时，先会调用这个函数<br>serialize() 函数会检查类中是否存在一个魔术方法 <code>__sleep()</code>。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p>
<p>注意：</p>
<p><code>__sleep()</code> 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。<br>作用：</p>
<p><code>__sleep()</code> 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。<br>具体请参考如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * @return array</span><br><span class="line">   */</span><br><span class="line">  public function __sleep() &#123;</span><br><span class="line">    echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">    $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">    return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo serialize($person);</span><br><span class="line">echo &apos;&lt;br/&gt;&apos;;</span><br><span class="line">代码运行结果：</span><br><span class="line"></span><br><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;</span><br></pre></td></tr></table></figure></p>
<p>十、 <code>__wakeup()</code>，执行unserialize()时，先会调用这个函数<br>如果说 <code>__sleep()</code> 是白的，那么 <code>__wakeup()</code> 就是黑的了。</p>
<p>那么为什么呢？</p>
<p>因为：</p>
<p>与之相反，<code>unserialize()</code> 会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 <code>__wakeup</code> 方法，预先准备对象需要的资源。<br>作用：<br><code>__wakeup()</code> 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。<br>还是看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * @return array</span><br><span class="line">   */</span><br><span class="line">  public function __sleep() &#123;</span><br><span class="line">    echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;;</span><br><span class="line">    $this-&gt;name = base64_encode($this-&gt;name);</span><br><span class="line">    return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * __wakeup</span><br><span class="line">   */</span><br><span class="line">  public function __wakeup() &#123;</span><br><span class="line">    echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;;</span><br><span class="line">    $this-&gt;name = 2;</span><br><span class="line">    $this-&gt;sex = &apos;男&apos;;</span><br><span class="line">    // 这里不需要返回数组</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_dump(serialize($person));</span><br><span class="line">var_dump(unserialize(serialize($person)));</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法</span><br><span class="line">当在类外部使用unserialize()时会调用这里的__wakeup()方法</span><br><span class="line">object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125;</span><br></pre></td></tr></table></figure></p>
<p>十一、 <code>__toString()</code>，类被当成字符串时的回应方法<br>作用：</p>
<p><code>__toString()</code> 方法用于一个类被当成字符串时应怎样回应。例如 <code>echo $obj;</code> 应该显示些什么。<br>注意：</p>
<p>此方法必须返回一个字符串，否则将发出一条 <code>E_RECOVERABLE_ERROR</code> 级别的致命错误。<br>警告：</p>
<p>不能在 <code>__toString()</code> 方法中抛出异常。这么做会导致致命错误。<br>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public function __toString()</span><br><span class="line">  &#123;</span><br><span class="line">    return &apos;go go go&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">go go go</span><br></pre></td></tr></table></figure></p>
<p>那么如果类中没有 <code>__toString()</code> 这个魔术方法运行会发生什么呢？让我们来测试下：</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">echo $person;</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18</span><br><span class="line">很明显，页面报了一个致命错误，这是语法所不允许的。</span><br></pre></td></tr></table></figure></p>
<p>十二、 <code>__invoke()</code>，调用函数的方式调用一个对象时的回应方法</p>
<p>作用：</p>
<p>当尝试以调用函数的方式调用一个对象时，<code>__invoke()</code> 方法会被自动调用。<br>注意：</p>
<p>本特性只在 PHP 5.3.0 及以上版本有效。<br>直接上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public function __invoke() &#123;</span><br><span class="line">    echo &apos;这可是一个对象哦&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person();</span><br><span class="line">查看运行结果：</span><br><span class="line"></span><br><span class="line">这可是一个对象哦</span><br><span class="line">当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：</span><br><span class="line"></span><br><span class="line">Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18</span><br></pre></td></tr></table></figure></p>
<p>十三、 <code>__set_state()</code>，调用var_export()导出类时，此静态方法会被调用。</p>
<p>作用：</p>
<p>自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。<br>参数：</p>
<p>本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。<br>下面我们先来看看在没有加 <code>__set_state()</code> 情况按下，代码及运行结果如何：</p>
<p>上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">var_export($person);</span><br><span class="line">看结果：</span><br><span class="line"></span><br><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小明&apos;, &apos;age&apos; =&gt; 25, ))</span><br><span class="line">很明显，将对象中的属性都打印出来了</span><br><span class="line"></span><br><span class="line">加了 __set_state() 之后：</span><br><span class="line"></span><br><span class="line">继续上代码：</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public static function __set_state($an_array)</span><br><span class="line">  &#123;</span><br><span class="line">    $a = new Person();</span><br><span class="line">    $a-&gt;name = $an_array[&apos;name&apos;];</span><br><span class="line">    return $a;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person-&gt;name = &apos;小红&apos;;</span><br><span class="line">var_export($person);</span><br><span class="line">继续看结果：</span><br><span class="line"></span><br><span class="line">Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小红&apos;, &apos;age&apos; =&gt; 25, ))</span><br></pre></td></tr></table></figure></p>
<p>十四、 <code>__clone()</code>，当对象复制完成时调用<br>在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。</p>
<p>作用：</p>
<p>对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 <code>__clone()</code> 方法）。对象中的 <code>__clone()</code> 方法不能被直接调用。</p>
<p>语法：</p>
<p>$copy_of_object = clone $object;<br>注意：</p>
<p>当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。</p>
<p>当复制完成时，如果定义了 <code>__clone()</code> 方法，则新创建的对象（复制生成的对象）中的 <code>__clone()</code>方法会被调用，可用于修改属性的值（如果有必要的话）。<br>看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">  public $sex;</span><br><span class="line">  public $name;</span><br><span class="line">  public $age;</span><br><span class="line"> </span><br><span class="line">  public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    $this-&gt;name = $name;</span><br><span class="line">    $this-&gt;age = $age;</span><br><span class="line">    $this-&gt;sex = $sex;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  public function __clone()</span><br><span class="line">  &#123;</span><br><span class="line">    echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$person = new Person(&apos;小明&apos;); // 初始赋值</span><br><span class="line">$person2 = clone $person;</span><br><span class="line"> </span><br><span class="line">var_dump(&apos;persion1:&apos;);</span><br><span class="line">var_dump($person);</span><br><span class="line">echo &apos;&lt;br&gt;&apos;;</span><br><span class="line">var_dump(&apos;persion2:&apos;);</span><br><span class="line">var_dump($person2);</span><br><span class="line">看结果：</span><br><span class="line"></span><br><span class="line">Person::__clone你正在克隆对象</span><br><span class="line">string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125; </span><br><span class="line">string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125;</span><br><span class="line">克隆成功。</span><br></pre></td></tr></table></figure></p>
<p>十五、<code>__autoload()</code>，尝试加载未定义的类<br>作用：</p>
<p>你可以通过定义这个函数来启用类的自动加载。<br>在魔术函数 <code>__autoload()</code> 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。</p>
<p>但是有了 <code>__autoload()</code> 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。</p>
<p>还是通过例子来看看吧：</p>
<p>先看看以往的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 文件non_autoload.php </span><br><span class="line"> */</span><br><span class="line">   </span><br><span class="line">require_once(&apos;project/class/A.php&apos;); </span><br><span class="line">require_once(&apos;project/class/B.php&apos;); </span><br><span class="line">require_once(&apos;project/class/C.php&apos;); </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123; </span><br><span class="line">  $a = new A(); </span><br><span class="line">  $b = new B(); </span><br><span class="line">  $c = new C(); </span><br><span class="line">  // … 业务逻辑 </span><br><span class="line">&#125; else if (条件B) &#123; </span><br><span class="line">  $a = newA(); </span><br><span class="line">  $b = new B(); </span><br><span class="line">  // … 业务逻辑 </span><br><span class="line">&#125;</span><br><span class="line">看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。</span><br><span class="line"></span><br><span class="line">那么如果使用 __autoload() 方式呢？</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 文件autoload_demo.php </span><br><span class="line"> */</span><br><span class="line">function __autoload($className) &#123; </span><br><span class="line">  $filePath = “project/class/&#123;$className&#125;.php”; </span><br><span class="line">  if (is_readable($filePath)) &#123; </span><br><span class="line">    require($filePath); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">   </span><br><span class="line">if (条件A) &#123; </span><br><span class="line">  $a = new A(); </span><br><span class="line">  $b = new B(); </span><br><span class="line">  $c = new C(); </span><br><span class="line">  // … 业务逻辑 </span><br><span class="line">&#125; else if (条件B) &#123; </span><br><span class="line">  $a = newA(); </span><br><span class="line">  $b = new B(); </span><br><span class="line">  // … 业务逻辑 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。</p>
<p>再来看看这里的效率如何，我们分析下：</p>
<p>当php引擎第一次使用类A，但是找不到时，会自动调用 <code>__autoload</code>方法，并将类名“A”作为参数传入。所以，我们在 <code>__autoload()</code>中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。</p>
<p>注意：</p>
<p>这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用 <code>__autoload</code>，而是直接使用内存中的类A，不会导致多次包含。<br>扩展：</p>
<p>其实php发展到今天，已经有将 <code>spl_autoload_register</code> — 注册给定的函数作为 <code>__autoload</code>的实现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function classLoader($class)</span><br><span class="line">&#123;</span><br><span class="line">    $path = str_replace(&apos;\\&apos;, DIRECTORY_SEPARATOR, $class);</span><br><span class="line">    $file = __DIR__ . &apos;/src/&apos; . $path . &apos;.php&apos;;</span><br><span class="line"></span><br><span class="line">    if (file_exists($file)) &#123;</span><br><span class="line">        require_once $file;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">spl_autoload_register(&apos;classLoader&apos;);</span><br><span class="line"></span><br><span class="line">require_once  __DIR__ . &apos;/src/Qiniu/functions.php&apos;;</span><br></pre></td></tr></table></figure></p>
<p>十六、<code>__debugInfo()</code>，打印所需调试信息</p>
<p>注意：</p>
<p>该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。<br>看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class C &#123;</span><br><span class="line">  private $prop;</span><br><span class="line"> </span><br><span class="line">  public function __construct($val) &#123;</span><br><span class="line">    $this-&gt;prop = $val;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  /**</span><br><span class="line">   * @return array</span><br><span class="line">   */</span><br><span class="line">  public function __debugInfo() &#123;</span><br><span class="line">    return [</span><br><span class="line">      &apos;propSquared&apos; =&gt; $this-&gt;prop ** 2,</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var_dump(new C(42));</span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;</span><br><span class="line">再次注意：</span><br><span class="line"></span><br><span class="line">这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册</span><br></pre></td></tr></table></figure></p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/20180331-2.html" rel="next" title="PHP细节-02">
                <i class="fa fa-chevron-left"></i> PHP细节-02
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/20180401-2.html" rel="prev" title="Linux 基础">
                Linux 基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/default_avatar.png" alt="uiste">
            
              <p class="site-author-name" itemprop="name">uiste</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry，Stay Foolish</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">150</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">66</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/uiste" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/uiste" target="_blank" title="微博" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>微博</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://www.zhihu.com/people/uiste" target="_blank" title="知乎" rel="external nofollow"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.xiaomanyu.cn" title="Mandy画站" target="_blank">Mandy画站</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#时间复杂度"><span class="nav-number">1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">2.</span> <span class="nav-text">try catch finally</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set-error-handle"><span class="nav-number">3.</span> <span class="nav-text">set_error_handle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#trait-是一个新的特性"><span class="nav-number">4.</span> <span class="nav-text">trait 是一个新的特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#预定义接口"><span class="nav-number">5.</span> <span class="nav-text">预定义接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator-迭代器"><span class="nav-number">5.1.</span> <span class="nav-text">Iterator 迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Aggregate-集合体"><span class="nav-number">5.2.</span> <span class="nav-text">Aggregate 集合体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Yield-生成器"><span class="nav-number">5.3.</span> <span class="nav-text">Yield    生成器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IteratorAggregate"><span class="nav-number">5.4.</span> <span class="nav-text">IteratorAggregate</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#魔术常量"><span class="nav-number">6.</span> <span class="nav-text">魔术常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#魔术方法"><span class="nav-number">7.</span> <span class="nav-text">魔术方法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2015 -  <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">uiste</span>

  

  
</div>


  










        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
      <div>
        <!-- Go to www.addthis.com/dashboard to customize your tools -->
<div class="addthis_inline_share_toolbox">
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-57838eee5e2620d0" async="async"></script>
</div>

      </div>
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.2"></script>



  



  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
