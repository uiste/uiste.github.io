<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac 配置ssh 免密登录]]></title>
    <url>%2F2018%2F20181102-3.html</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122# 配置ssh~ vim ~/.ssh/configHost * ServerAliveInterval 10Host Mweb1 HostName 服务器IP地址 Port 端口 User 用户名 IdentityFile 私钥地址Host Mweb2 HostName 服务器IP地址 Port 22 User uiste IdentityFile ~/.ssh/id_rsa# 登录方式➜ ~ ssh Mweb1Last login: Fri Nov 2 08:15:51 2018 from 180.173.83.33[root@VM_0_6_centos ~]#]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac配置远程服务器隧道代理]]></title>
    <url>%2F2018%2F20181102-2.html</url>
    <content type="text"><![CDATA[因为安全原因远程服务器的数据库不允许本地直接访问，又没有开启访问IP白名单时，可以通过隧道代理访问。Windows系统通过xsheel可以设置隧道代理。Mac只需要运行如下命令 123ssh -p 22 -i ~/.ssh/id_rsa -fNL 代理端口:代理IP:转发原端口 用户名@远程服务器IPssh -p 22 -i ~/.ssh/id_rsa -fNL 3308:127.0.0.1:3306 root@118.xx.xxx.xx 123ssh -p &#123;ssh_port&#125; -i &#123;rsa_file&#125; -fNL &#123;local_port&#125;:&#123;mysql_ip&#125;:&#123;mysql_port&#125; &#123;ssh_user&#125;@&#123;ssh_ip&#125;ssh -p 22 -i ./id_rsa_jump -fNL 33060:mysql_ip:3306 jump@jump_ip # 实例 -p {ssh_port}: 指定跳板机器的ssh服务的端口-i {rsa_file}:指定连接跳板机的ssh公钥，由跳板机的ssh服务端生成，如果不指定公钥或者公钥验证失败则会弹出密码进行登录。-f:需进行ssh认证-N:只进行端口转发，不执行命令-L:指定连接服务的格式 [bind_address:]port:host:hostport{local_port}：本地监听的端口{mysql_ip}：转发到的mysql的ip或域名{mysql_port}：转发到的mysql的端口{ssh_port}：跳板机的{ssh_user}：跳板机的ssh用户名(如果为rsa登录，则ras对应的用户名和ssh_user一致){ssh_ip}：跳板机的ip或域名检查是否启动成功netstat -aon|findstr “33060” #存在对应的监听则启动成功 如果要关闭则kill连接mysqlip:127.0.0.1port:33060]]></content>
  </entry>
  <entry>
    <title><![CDATA[truffle geth 启动Ethereum测试节点]]></title>
    <url>%2F2018%2F20181102-1.html</url>
    <content type="text"><![CDATA[truffle 框架使用 uiste@uiste:~$ testrpc 1234567uiste@uiste:~/www/blockchain/test_truffle_2$ truffle unbox webpackuiste@uiste:~/www/blockchain/test_truffle_2$ truffle developLast login: Mon Apr 2 20:07:27 on ttys008uiste@uiste:~$ cd www/blockchain/test_truffle_2/uiste@uiste:~/www/blockchain/test_truffle_2$ npm run dev geth 方式123456`geth --datadir &quot;./Mychains/dev&quot; --identity &quot;mydev&quot; --rpccorsdomain &quot;*&quot; --networkid 99 console`uiste@uiste:~$ cd www/blockchain/test-gethuiste@uiste:~/www/blockchain/test-geth$ geth --datadir &quot;./Mychains/dev&quot; --identity &quot;mydev&quot; --rpc --rpcapi &quot;db,eth,net,web3,personal,web3&quot; --nodiscover --rpccorsdomain &quot;*&quot; --networkid 100 consoleuiste@uiste:/Applications$ /Applications/Mist.app/Contents/MacOS/Mist --rpc &quot;/Users/uiste/www/blockchain/test-geth/Mychains/dev/geth.ipc&quot; 12345geth --datadir &quot;./chain&quot; --identity &quot;mydev&quot; --rpc --rpcapi &quot;db,eth,net,web3,personal,web3&quot; --nodiscover --rpccorsdomain &quot;*&quot; --networkid 100 console 2&gt;&gt;eth_output.loggeth --dev --rpc --rpccorsdomain &quot;*&quot; --rpcaddr &quot;0.0.0.0&quot; --rpcport &quot;8545&quot; --mine --rpcapi &quot;eth,txpool,web3&quot;geth --testnet --rpc --rpccorsdomain &quot;*&quot; --rpcaddr &quot;0.0.0.0&quot; --rpcport &quot;8545&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【5】区块链-以太坊truffle 框架]]></title>
    <url>%2F2018%2F20180511-5.html</url>
    <content type="text"><![CDATA[TestRPC安装安装Ethereum客户端来支持JSON RPC API调用开发环境，推荐使用EthereumJS。安装命令： sudo npm install -g ethereumjs-testrpc 这里的安装如果无法下载，请参考上一篇博客中安装truffle中使用淘宝镜像的方法。此步安装遇到很多问题，也尝试了各种方法，比如gcc依赖的安装升级，Python的安装，npm的升级，git的配置，还有node版本是否影响。虽然最终把问题给解决了，但修改的地方太多具体什么原因导致安装过程中出现那么多问题，还有待大家去尝试分析。 在执行以上命令之后，只是把ethereumjs-testrpc安装在nodejs的以下路径： /home/zhuzs/app/nodejs/node-v6.9.1/lib/node_modules/ethereumjs-testrpc 还行进行软连接的配置： ln -s /home/zhuzs/app/nodejs/node-v6.9.1/lib/node_modules/ethereumjs-testrpc/bin/testrpc /usr/local/bin/testrpc truffle 安装npm install -g truffle truffle 使用常用命令1234truffle init 初始化truffle compile 编译truffle migrate 部署truffle serve 启动服务 操作 启动TestRPC 初始化项目 修改配置文件,编写简单的智能合约 mac 默认读取的truffle.js1234567891011module.exports = &#123; // See &lt;http://truffleframework.com/docs/advanced/configuration&gt; // to customize your Truffle configuration! networks: &#123; development: &#123; host: &quot;127.0.0.1&quot;, port: 8545, network_id: &quot;*&quot; // Match any network id &#125; &#125;&#125;; SimpleStorage.sol12345678910111213pragma solidity ^0.4.0; contract SimpleStorage &#123; uint storedData; function set(uint x) public &#123; storedData = x; &#125; function get() constant public returns (uint) &#123; return storedData; &#125; &#125; 2_deploy_contracts.js12345const SimpleStorage = artifacts.require(&quot;./SimpleStorage.sol&quot;)module.exports = function(deployer) &#123; deployer.deploy(SimpleStorage);&#125;; 编译(保证编译不报错)truffle migrate –reset 使用这个命令便可解决以上问题 部署 报错问题无法解决 换一种方案实现123456mkdir test //重新建一个项目目录testtruffle unbox webpacktruffle develop // 启动一个控制台&gt; compile //编译&gt;migrate //迁移合约 当然这两部也可以不在控制台下完成 可以用 truffle compile 和 truffle migrate 完成。npm run dev //运行webpack服务器进行前端热重新加载（在开发控制台之外）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【4】区块链-以太坊web3.js]]></title>
    <url>%2F2018%2F20180511-4.html</url>
    <content type="text"><![CDATA[下载uiste@uiste:~/www/blockchain/test_web3js$ git clone https://github.com/ethereum/web3.js.git 运行node-app.js获取主账号地址，与账户余额 下载轻钱包123git clone https://github.com/ConsenSys/eth-lightwallet.gitcd eth-lightwalletnpm install]]></content>
  </entry>
  <entry>
    <title><![CDATA[【3】区块链-以太坊代币合约]]></title>
    <url>%2F2018%2F20180511-3.html</url>
    <content type="text"><![CDATA[编写智能合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149pragma solidity ^0.4.0;//创建一个基础合约，有些操作只能是当前合约的创建者才能操作contract owned&#123; //声明一个用来接收合约创建者的状态变量 address public owner; //构造函数，把当前交易的发送者（也就是合约的创建者）赋予owner变量 function owned() public &#123; owner = msg.sender; &#125; //声明一个修改器，用于有些方法只有合约的创建者才能操作 modifier onlyOwner&#123; if(msg.sender != owner)&#123; revert(); &#125;else&#123; _; &#125; &#125; //把该合约的拥有者转给其他人 function transferOwner(address newOwner) public onlyOwner&#123; owner = newOwner; &#125;&#125;contract tokenCpc1 is owned &#123; string public name ;//代币名字 string public symbol; //代币符号 uint8 public decimals = 0; //代币小数位 uint public totalSupply; //代币总量 uint public sellPrice = 1 ether ; //设置代币的卖的价格等于一个以太币 uint public buyPrice = 1 ether ;//设置代币的买的价格等于一个以太币 //用一个映射类型的变量，来记录所有账户的代币的余额 mapping(address =&gt; uint) public balanceOf; //用一个映射类型的变量，来记录被冻结的账户 mapping(address=&gt;bool) public frozenAccount; event e(string _str); //构造函数，初始化代币的变量和初始代币总量 function tokenCpc1(uint initialSupply,string _name , string _symbol, uint8 _decimals,address centralMinter) public payable&#123; //手动指定代币的拥有者，如果不填，则默认为合约的部署者 if(centralMinter !=0)&#123; owner = centralMinter; &#125; balanceOf[owner] = initialSupply; name = _name; symbol = _symbol; decimals = _decimals; totalSupply = initialSupply; &#125; //发行代币，向指定的目标账户添加代币 function mintToken(address target,uint mintedAmount) public onlyOwner&#123; //判断目标账户是否存在 if(target != 0)&#123; //设置目标账户相应的代币余额 balanceOf[target] = mintedAmount; //增加总量 totalSupply +=mintedAmount; &#125;else&#123; revert(); &#125; &#125; //实现账户的冻结和解冻 function freezeAccount(address target,bool _bool) public onlyOwner&#123; if(target != 0)&#123; frozenAccount[target] = _bool; &#125; &#125; //实现账户间，代币的转移 function transfer(address _to, uint _value) public &#123; //检测交易的发起者的账户是不是被冻结了 if(frozenAccount[msg.sender])&#123; revert(); &#125; //检测交易发起者的账户的代币余额是否足够 if(balanceOf[msg.sender] &lt; _value)&#123; revert(); &#125; //检测溢出 if((balanceOf[_to] + _value) &lt;balanceOf[_to] )&#123; revert(); &#125; //实现代币转移 balanceOf[msg.sender] -=_value; balanceOf[_to] +=_value; &#125; //设置代币的买卖价格 function setPrice(uint newSellPrice,uint newBuyPrice) public onlyOwner&#123; sellPrice = newSellPrice; buyPrice = newBuyPrice; &#125; //实现代币的卖操作 function sell(uint amount) public returns(uint revenue)&#123; //检测交易的发起者的账户是不是被冻结了 if(frozenAccount[msg.sender])&#123; revert(); &#125; //检测交易发起者的账户的代币余额是否足够 if(balanceOf[msg.sender] &lt; amount)&#123; revert(); &#125; //把相应数量的代币给合约的拥有者 balanceOf[owner] +=amount ; //卖家的账户减去相应的余额 balanceOf[msg.sender] -=amount; //计算对应的以太币的价值 revenue = amount * sellPrice; //向卖家的账户发送对应数量的以太币 if(msg.sender.send(revenue))&#123; return revenue; &#125;else&#123; //如果以太币发送失败，则终止程序，并且恢复状态变量 revert(); &#125; &#125; //实现买操作 function buy() public payable returns(uint amount) &#123; //检测买家是不是大于0 if(buyPrice &lt;= 0)&#123; //如果不是，则终止 revert(); &#125; //根据用户发送的以太币的数量和代币的买价，计算出代币的数量 amount = msg.value / buyPrice; //检测合约的拥有者是否有足够多的代币 if(balanceOf[owner] &lt; amount)&#123; revert(); &#125; //向合约的拥有者转移以太币 if(!owner.send(msg.value))&#123; //如果失败，则终止 revert(); &#125; //从拥有者的账户上减去相应的代币 balanceOf[owner] -=amount ; //买家的账户增加相应的余额 balanceOf[msg.sender] +=amount; return amount; &#125;&#125; 部署合约 开启挖矿 添加代币 操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[【2】区块链-以太坊智能合约]]></title>
    <url>%2F2018%2F20180511-2.html</url>
    <content type="text"><![CDATA[以太坊智能合约实战启动Remix IDE工具 设置IDE本地文件共享 参考连接 https://remix.readthedocs.io/en/latest/tutorial_remixd_filesystem.html https://github.com/ethereum/remixd 以太坊智能合约demo新建账户的两种方案 新建合约 编写合约代码 合约部署 开启挖矿 合约打包成功 查看部署好的合约 执行合约 给主账户设置100000块钱 查看合约执行状态 这里本来是100000多执行了一次1000000导致有1100000 合约执行 文档solidity 文档http://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html http://www.tryblockchain.org/ Web3 js 文档http://web3.tryblockchain.org/ Truffle 文档http://truffle.tryblockchain.org/]]></content>
  </entry>
  <entry>
    <title><![CDATA[【1】区块链-以太坊搭建私有网络]]></title>
    <url>%2F2018%2F20180511-1.html</url>
    <content type="text"><![CDATA[以太坊搭建私有网络实战基本环境安装123451. 安装nodejs2. brew tap ethereum/ethereum3. brew install ethereum4. Ethereum Wallet and Mist Beta 0.10.0https://github.com/ethereum/mist/releases/ 配置创世区块文件 文件名：CustomGenesis.json123456789101112131415161718&#123; &quot;nonce&quot;: &quot;0x0000000000000042&quot;, &quot;timestamp&quot;: &quot;0x00&quot;, &quot;parentHash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;extraData&quot;: &quot;0x00&quot;, &quot;gasLimit&quot;: &quot;0x8000000&quot;, &quot;difficulty&quot;: &quot;0x400&quot;, &quot;mixhash&quot;: &quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;coinbase&quot;: &quot;0x3333333333333333333333333333333333333333&quot;, &quot;alloc&quot;: &#123; &#125;, &quot;config&quot;: &#123; &quot;chainId&quot;: 15, &quot;homesteadBlock&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;&#125; 初始化创世区块geth --identity &quot;mydev&quot; --rpc --rpccorsdomain &quot;*&quot; --datadir &quot;./Mychains/dev&quot; --rpcapi &quot;db,eth,net,web3&quot; init &quot;./CustomGenesis.json&quot; 开启私有网络 只开启rpcgeth --datadir &quot;./Mychains/dev&quot; --identity &quot;mydev&quot; --rpccorsdomain &quot;*&quot; --networkid 99 console 开启rpc和httpgeth --datadir &quot;./Mychains/dev&quot; --identity &quot;mydev&quot; --rpc --rpcapi &quot;db,eth,net,web3,personal,web3&quot; --nodiscover --rpccorsdomain &quot;*&quot; --networkid 100 console 创建账户 IPC连接连接，并开启挖矿（新开一个客户端）geth attach /Users/uiste/www/blockchain/test-geth/Mychains/dev/geth.ipc 如果是Web应用的时候，就使用http://127.0.0.8545 地址就是连接 开启mist浏览器Mac遇到启动mist失败 解决方案： 通过命令行方式启动让Ethereum Wallet，添加参数让他和刚起的私有链同用一个ipc。 12uiste@uiste:~/www/blockchain/test-geth/Mychains/dev$ cd /Applications/uiste@uiste:/Applications$ ./Ethereum\ Wallet.app/Contents/MacOS/Ethereum\ Wallet --rpc &quot;/Users/uiste/www/blockchain/test-geth/Mychains/dev/geth.ipc&quot; 通过命令行方式启动Mist，添加参数让他和刚起的私有链同用一个ipc。 1uiste@uiste:/Applications$ Mist.app/Contents/MacOS/Mist --rpc &quot;/Users/uiste/www/blockchain/test-geth/Mychains/dev/geth.ipc&quot; 启动Mist后的界面如下： 停止挖矿，命令行查看账户余额]]></content>
  </entry>
  <entry>
    <title><![CDATA[大规模网站开发技术]]></title>
    <url>%2F2018%2F20180404-1.html</url>
    <content type="text"><![CDATA[大型网站的特点 海量数据： 淘宝有几十亿商品 高并发： 日均PV几十亿 高可用： 系统7*24不间断 功能多、需求多、更新快 存储过程自动分表12345678910111213141516171819202122232425262728293031323334353637# 参照表CREATE TABLE `pc_pay_result_20170420` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `order_id` varchar(32) NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;支付结果&apos;;# 存储过程DROP PROCEDURE IF EXISTS `proc_month_daily_create_tables`;DELIMITER $$CREATE PROCEDURE `proc_month_daily_create_tables`() begin set @current_20_tablesql=(select concat(&apos;es.pc_pay_result_&apos;,date_format(curdate(),&apos;%Y%m&apos;),&apos;20&apos;));set @create_tablesql_00=(select concat(&apos;CREATE TABLE IF NOT EXISTS es.pc_pay_result_&apos;,date_format(date_add(curdate(),interval 1 month),&apos;%Y%m&apos;),&apos;00 like &apos;,&apos;es.pc_pay_result_&apos;,date_format(curdate(),&apos;%Y%m&apos;),&apos;20;&apos;));set @create_tablesql_10=(select concat(&apos;CREATE TABLE IF NOT EXISTS es.pc_pay_result_&apos;,date_format(date_add(curdate(),interval 1 month),&apos;%Y%m&apos;),&apos;10 like &apos;,&apos;es.pc_pay_result_&apos;,date_format(curdate(),&apos;%Y%m&apos;),&apos;20;&apos;));set @create_tablesql_20=(select concat(&apos;CREATE TABLE IF NOT EXISTS es.pc_pay_result_&apos;,date_format(date_add(curdate(),interval 1 month),&apos;%Y%m&apos;),&apos;20 like &apos;,&apos;es.pc_pay_result_&apos;,date_format(curdate(),&apos;%Y%m&apos;),&apos;20;&apos;));PREPARE create_tablesql_00 FROM @create_tablesql_00; EXECUTE create_tablesql_00; PREPARE create_tablesql_10 FROM @create_tablesql_10; EXECUTE create_tablesql_10; PREPARE create_tablesql_20 FROM @create_tablesql_20; EXECUTE create_tablesql_20; END $$DELIMITER ;# 自动创建事件CREATE DEFINER=`root`@`localhost` EVENT `存储过程建表事件` ON SCHEDULE EVERY &apos;0:1&apos; MINUTE_SECOND STARTS &apos;2019-04-07 15:38:29&apos; ON COMPLETION NOT PRESERVE ENABLE COMMENT &apos;存储过程建表&apos; DO begin/**event body**/CALL proc_month_daily_create_tables();endCREATE DEFINER=`root`@`localhost` EVENT `存储过程建表事件` ON SCHEDULE EVERY &apos;0 1&apos; DAY_HOUR STARTS &apos;2019-04-08 15:38:29&apos; ON COMPLETION NOT PRESERVE ENABLE COMMENT &apos;存储过程建表&apos; DO begin/**event body**/CALL proc_month_daily_create_tables();end 创建自定义函数!(funciton)[http://resoure.uiste.com/phcntech_dev190407162402_funcion.png]]]></content>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F20180403-1.html</url>
    <content type="text"><![CDATA[精神指南：找到容易变化的地方，独立出来 策略模式用不同的类 + 相同的方法 实现不同的策略行为 观察者模式被观察者绑定多个观察者的类 指定事件完成时，循环触发不同观察者的相同方法PHP SPL 中 SplObserveer SplSubject SplObjectStorage 装饰模式单例模式适配器模式工厂模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql高级-存储引擎、驱动、索引、优化]]></title>
    <url>%2F2018%2F20180402-3.html</url>
    <content type="text"><![CDATA[MySQL5.1版本前默认存储引擎是myisamMySQL5.5版本开始默认存储引擎是innodb 字段类型锁 myisam 和 memory 存储引擎采用的是表级锁 BDB存储引擎采用的是页面锁，但也支持表级锁 innodb 存储引擎既支持行锁也支持表锁，默认采用行锁 表级锁：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低 行级锁：开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度也最高 页面锁：介于上述二者之间 123456myisam 表锁争用情况&gt; show status like &apos;table_lock%&apos;;table_lock_waited 值高有着叫严重的表锁争用情况table_lock_immediatetable_lock_immediate/table_lock_waited &gt; 5000 争用情况正常 myisam 锁机制表共享读锁（不会阻塞其它进程对同一表的读请求，但会阻塞同一表的写请求）表独占写锁（会阻塞其它进程对同一表的读写操作） 并发插入concurrent_instert0:不允许并发插入1:有空洞不允许并发插入，无空洞允许2:都允许 innodb123456&gt; show status like &apos;innodb_row_lock%&apos;;innodb_row_lock_current_waits:innodb_row_lock_timeinnodb_row_lock_time_avginnodb_row_lock_time_maxinnodb_row_lock_waits 行锁不影响读操作，只影响写操作。同时如果更新语句条件没有加索引，会锁定整个表，但还是不影响读操作 事务innodb 事务隔离级别123456789101112* read uncommitted 非提交读（会带来涨读）* read committed 提交读 * repeatable read 可重复读 （会出现幻读）* serializable 序列化 （会加锁，让数据不可变）查看隔离级别select @@tx_isolation 查看当前会话隔离级别select @@global.tx_isolation 查看系统隔离级别设置隔离级别set session transaction isolation level xxx 设置档期会话隔离级别set global transaction isolation level xxx 设置系统全局隔离级别 驱动php5.3之前定的渠道是libmysql.dll或so 之后是mysqlnd驱动API msyql （mysql_real_escape_string($name)）转移特深字符，用于msyql_queue() 安全查询 mysqli 新增：面向对象接口、绑定语句支持（prepare、bind_param）、多语句支持、事务支持等 pdo_mysql 特点：多数据库统一支持 索引和全文检索技术 普通索引 如果没有唯一性要求，可以选择普通索引 唯一索引 如果列上有唯一性要求，可以选择唯一索引 全文索引 如果需要模糊搜索，可以选择全文索引 组合索引 如果有多个条件一起查询，可以选择组合索引注意最左原则 索引的实现方式 B+ 树 、聚簇索引 、 非聚簇索引 对中文支持不友好 sql优化执行顺序12345678910111. from 子句对其后面的多个表进行笛卡尔积，产生的虚拟表VT12. on 对VT1 数据过滤 得到 VT23. 将未符合调价的保留表中数据添加到 VT2 中 得到 VT34. where 子句对 VT3 过滤 得到 VT45. group 对 VT4 得到 VT56. cube|roolup 子句进行操作得到 VT67. having 对VT6数据进行Having 得到VT78. select 从 VT7 中选择要获取的字段 得到 VT89. distinct 去重 得到 VT910. order by 对VT9 结果进行排序后，形成 VT1011. limit 从 VT10 中取出指定的数据，形成 VT11 返回给用户 explain1234567891011121314151617181920212223242526272829303132333435363738394041EXPLAIN 输出格式EXPLAIN 命令的输出内容大致如下:mysql&gt; explain select * from user_info where id = 2\G*************************** 1. row *************************** id: 1 select_type: SIMPLE table: user_info partitions: NULL type: constpossible_keys: PRIMARY key: PRIMARY key_len: 8 ref: const rows: 1 filtered: 100.00 Extra: NULL1 row in set, 1 warning (0.00 sec)各列的含义如下:id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.select_type: SELECT 查询的类型.table: 查询的是哪个表partitions: 匹配的分区type: join 类型possible_keys: 此次查询中可能选用的索引key: 此次查询中确切使用到的索引.ref: 哪个字段或常数与 key 一起被使用rows: 显示此查询一共扫描了多少行. 这个是一个估计值.filtered: 表示此查询条件所过滤的数据的百分比extra: 额外的信息 分表读写分离]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql高级-体系结构]]></title>
    <url>%2F2018%2F20180402-2.html</url>
    <content type="text"><![CDATA[Mysql是由SQL接口，解析器，优化器，缓存，存储引擎组成的。 Connectors 指的是不同语言中与SQL的交互 Management Serveices &amp; Utilities 系统管理和控制工具 Connection Pool 连接池 管理缓冲用户连接，线程处理等需要缓存的需求。 SQL Interface: SQL接口 接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface。 Parser: 解析器。 SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。 主要功能： a . 将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的 。 b. 如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的。 Optimizer: 查询优化器 SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。 用一个例子就可以理解： select uid,name from user where gender = 1;这个select 查询先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤。这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤。将这两个查询条件联接起来生成最终查询结果。 Cache和Buffer： 查询缓存 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。 Engine ：存储引擎 存储引擎是MySql中具体的与文件打交道的子系统。也是Mysql最具有特色的一个地方。 Mysql的存储引擎是插件式的。它根据MySql AB公司提供的文件访问层的一个抽象接口来定制一种文件访问机制（这种访问机制就叫存储引擎）。 现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的MyISAM,InnoDB,BDB。 默认下MySql5.6是使用MyISAM引擎，它查询速度快，有较好的索引优化和数据压缩技术。但是它不支持事务。 InnoDB支持事务，并且提供行级的锁定，应用也相当广泛。 Mysql也支持自己定制存储引擎，甚至一个库中不同的表使用不同的存储引擎，这些都是允许的。 物理文件物理文件包括：redolog、undolog、binlog（复制时还有relaylog）、errorlog、querylog、slowlog、data、index]]></content>
  </entry>
  <entry>
    <title><![CDATA[NoSql]]></title>
    <url>%2F2018%2F20180402-1.html</url>
    <content type="text"><![CDATA[memcache Page为内存分配的最小单位。 Memcached 的内存分配以page为单位，默认情况下一个page是1M，可以通过-I参数在启动时指定。如果需要申请内存 时，memcached会划分出一个新的page并分配给需要的slab区域。page一旦被分配在重启前不会被回收或者重新分配 Slabs划分数据空间。 Memcached 并不是将所有大小的数据都放在一起的，而是预先将数据空间划分为一系列slabs，每个slab只负责一定范围内的数据存储。每个slab只存储大于其上一个slab的size并小于或者等于自己最大size的数据。例如：slab 3只存储大小介于137 到 224 bytes的数据。如果一个数据大小为230byte将被分配到slab 4中。每个slab负责的空间其实是不等的，memcached默认情况下下一个slab的最大值为前一个的1.25倍，这个可以通过修 改-f参数来修改增长比例。 Chunk才是存放缓存数据的单位。 Chunk 是一系列固定的内存空间，这个大小就是管理它的slab的最大存放大小。例如：slab 1的所有chunk都是104byte，而slab 4的所有chunk都是280byte。chunk是memcached实际存放缓存数据的地方，因为chunk的大小固定为slab能够存放的最大值， 所以所有分配给当前slab的数据都可以被chunk存下。如果时间的数据大小小于chunk的大小，空余的空间将会被闲置，这个是为了防止内存碎片而设 计的。例如，chunk size是224byte，而存储的数据只有200byte，剩下的24byte将被闲置。 Slab的内存分配。 Memcached在启动时通过-m指定最大使用内存，但是这个不会一启动就占用，是随着需要逐步分配给各slab的。如果一个新的缓存数据要被存放，memcached首先选择一个合适的slab，然后查看该slab是否还有空闲的chunk，如果有则直接存放进去；如 果没有则要进行申请。slab申请内存时以page为单位，所以在放入第一个数据，无论大小为多少，都会有1M大小的page被分配给该slab。申请到 page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk的数组，在从这个chunk数组中选择一个用于存储 数据。如下图，slab 1和slab 2都分配了一个page，并按各自的大小切分成chunk数组。 Memcached内存分配策略 按slab需求分配page，各slab按需使用chunk存储。Memcached分配出去的page不会被回收或者重新分配Memcached申请的内存不会被释放slab空闲的chunk不会借给任何其他slab使用，如果所有page都已经存满了。并且memcache已不能再分配新的内存空间。将根据LRU算法（最近最少使用）,清除某个item并将新项存储在该位置 分布式解决方案 取模算法方式 将key转换为32位的数字，并与memcached服务器的总数进行相除取得余数。而这个余数就是memcached服务器的节点node。有了这个node我们就可以确定memcached服务器，就可以发送命令给memcached执行了。 缺点是不方便扩展和机器宕机后不能自动调整集群$node sprintf(&#39;%u&#39;, crc32($key)) % $total 一致哈希算法方式 通过虚拟节点的方式实现，可以使不可控的存储节点能够尽可能的均匀分布在圆环上，从而达到数据均匀缓存在各个主机里。其次增加与删除虚拟节点对于之前缓存的整体数据影响非常小。 Redis高性能key-value 存储系统，它通常被称为数据结构服务器。因为值可以是：字符串、哈希、列表、集合、有序集合 特点：单线程、快（每秒10万次SET操作）、拥有很多原子操作方法，保证数据一致性、将具有临时性和数据持久化 二进制安全、一个字符串类型的值最多能保存512M内容。 集合（set） 集合是一个无需字符串集合。元素不能重复。一个集合最多可以包含2^32-1个元素。方便计算不同集合的交集、并集、差集。常用应用：关注列表、粉丝列表、共同关注或者粉丝等 有序集合（zSet） 每个有序集合成员都关联着一个评分，这个评分的用语把有序集合中的成员按最低分到最高分排列。（应用于各种有排序条件的列表：访问足迹最近访问的时间戳作为排序分） watch 123456789101112131415161718192021222324&lt;?phpheader("content-type:text/html;charset=utf-8"); $redis = new redis(); $result = $redis-&gt;connect('127.0.0.1', 6379);$watchkey = $redis-&gt;get("watchkey"); $rob_total = 10;if($watchkey&lt;$rob_total)&#123; $redis-&gt;watch("watchkey"); // 监视某个key $redis-&gt;multi(); // 开启事物 $redis-&gt;hSet("watchlist","user_id_".mt_rand(1, 9999),time()); // 业务操作 $redis-&gt;incr("watchkey"); $rob_result = $redis-&gt;exec(); // 如果执行操作期间，被监视的KEY被其它客户端修改了，则exec失败 if($rob_result)&#123; $watchlist = $redis-&gt;hGetAll("watchlist"); echo "抢购成功！&lt;br/&gt;"; echo "剩余数量：".($rob_total-$watchkey-1)."&lt;br/&gt;"; echo "用户列表：&lt;pre&gt;"; var_dump($watchlist); &#125;else&#123; echo "手气不好，再抢购！"; &#125; &#125;else&#123;echo "已被抢购完!";&#125; 数据持久化：RDB 和 AOF RDB：就是快照存储，是默认的持久化方式，按照一定的策略周期性的将数据保存到磁盘。对应产生的数据文件为dump.rdb,通过配置文件中的save参数来定义快照的周期.通过修改配置文件的dbfilename 来修改 123save 900 1save 300 10save 60 10000 AOF:修改配置appendonly yes 来开启，开启后写命令会依次记录到此文件。AOF 大！即使通过bgrewriteaof 命令移除冗余记录也大。恢复慢123# appendfsync always 每次命令都写，最安全，性能最差appendfsync everysec 每秒同步一次（默认）# appendfsync no 不主动同步，由操作系统负责鞋服，约30秒一次 mongoDB介于关系数据库和非关系型数据之间的文档数据库，支持的数据结构非常松散，类似json的bson格式，因此可以存储比较复杂的数据类型。支持对数据字段奖励索引 模式自由，通过数据分片实现高伸缩性 处理地理信息 高可用，内置故障迁移 高性能低延时实时数据（查询QPS接近MySQL的两倍左右， 插入QPS接近MySQL的五倍左右） 局部索引，TTL索引，固定集合 不适合高度事务性系统，不适合需要复杂SQL处理的查询 与关系型数据库结构对比：文档≈行，集合≈表，数据库≈数据库]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 基础]]></title>
    <url>%2F2018%2F20180401-2.html</url>
    <content type="text"><![CDATA[权限 普通用户只能追加无法删除chattr +a /var/log/access.log r w x 4 2 1 磁盘文件统计 df 查看磁盘占用 du 统计文件占用 fdisk 分区管理 mount 磁盘挂载 umount 磁盘卸载 mkfs.ext4 磁盘格式化 查找find12345678910111213find . -mmin -60 修改时间为最近60分钟内的find . -mmin +5 修改时间为5分钟之前的find /tmp -atime -1 查找/tmp目录最近1天(24小时)内被访问过的文件find . -type f 查找本目录下的所有文件find . -type d 查找本目录下的所有目录find . -user root 查找本目录下所有root用户的文件find . -perm 600 查找本目录下所有权限为600的文件find . \( -name &quot;_*&quot; -or -user root \) -type f 查找本目录下（以_开头或root用户的） 文件逻辑运算符-not-or-and 分析文章访问日志文件，找出访问量最大的前10个IP地址，降序排序 找出IP，每行一个 -f 表示需要取得哪个字段cut -d &quot; &quot; -f1 /var/log/access.log 去重并计数uniq -c 排序sort -n -r 取前10行head -10 $ cut -d &quot; &quot; -f1 /var/log/access.log | sort | uniq -c | sort -n -r | head -10 linux 中有三个系统文件描述符：0.标准输入，1.标准输出，2.标准错误输出 系统管理 ps 命令，显示当前进程 1234ps -ef 显示带启动命令行的进程信息ps -u root 显示某用户的进程ps -A 显示全部进程ps -ejH 显示进程树 kill 命令：终止进程 12345kill -s PID-s 指定信号-l 所有信号标识列表kill -9 PID 强制结束killall 进程名称 fg 命令 将后台任务调到前台 命令后加 &amp; 或者 ctrl + z 可将任务转到后台执行后台执行中的任务，可以通过 fg &amp;任务序号 调到前台执行jobs -l 查看后台任务fg %1 恢复后台进程中的1工作号到前台执行，不写1表示恢复最后一个工作号（+）到前台执行，也可以不写%，fg 1 开放端口：12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPTservice iptables save #保存iptables规则 shell 变量 123区分大小写等号两边无空格所有变量都是字符串 流程控制 命令列表 函数]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP细节-03]]></title>
    <url>%2F2018%2F20180401-1.html</url>
    <content type="text"><![CDATA[时间复杂度 时间复杂度的算法具体步骤是：⑴ 找出算法中的基本语句；算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。⑵ 计算基本语句的执行次数的数量级；只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。⑶ 用大Ο记号表示算法的时间性能。将基本语句执行次数的数量级放入大Ο记号中。如果算法中包含嵌套的循环，则基本语句通常是最内层的循环体，如果算法中包含并列的循环，则将并列循环的时间复杂度相加。例如：12345for (i=1; i&lt;=n; i++) x++; for (i=1; i&lt;=n; i++) for (j=1; j&lt;=n; j++) x++; 第一个for循环的时间复杂度为Ο(n)，第二个for循环的时间复杂度为Ο(n2)，则整个算法的时间复杂度为Ο(n+n2)=Ο(n2)。Ο(1)表示基本语句的执行次数是一个常数，一般来说，只要算法中不存在循环语句，其时间复杂度就是Ο(1)。其中Ο(log2n)、Ο(n)、 Ο(nlog2n)、Ο(n2)和Ο(n3)称为多项式时间，而Ο(2n)和Ο(n!)称为指数时间。计算机科学家普遍认为前者（即多项式时间复杂度的算法）是有效算法，把这类问题称为P（Polynomial,多项式）类问题，而把后者（即指数时间复杂度的算法）称为NP（Non-Deterministic Polynomial, 非确定多项式）问题。 try catch finallytry内部正常执行try的内部逻辑，异常则执行catch的内部逻辑结构，但是不管执行的哪个都会执行完try catch的内部逻辑（非return）后执行finally的内部逻辑。 如果try catch都有return，按照正常执行，然后执行finally的逻辑，再返回对应的try 或者catch里执行return。 如果try catch finally都有return，执行完finally的逻辑后，会调用finally的return。 12345678910111213141516171819202122232425&lt;?phpclass test&#123; public function testTry() &#123; $i = 0; try &#123; $i = $i + 1; return $i; &#125; catch (Exception $e) &#123; echo &quot;wc&quot;; &#125; finally &#123; $i = $i + 2; // print_r($i); return &quot;1111&quot;;//当finally有return的时候 返回这个，当注销后，返回try 或者是 catch的内容。 &#125; &#125;&#125; $b = new test();echo $b-&gt;testTry();# 1111[Finished in 0.4s] set_error_handle捕获 notice waring 等错误，放置回调函数处理 E_ERROR,E_PARSE 等拦截不了的。使用 register_shutdown_function()回调函数处理任意类型错误。 trait 是一个新的特性Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题1234567891011121314151617&lt;?phpnamespace AlibabaCloud\Client\Regions;use AlibabaCloud\Client\Traits\EndpointTrait;/** * Class EndpointProvider * * @package AlibabaCloud\Client\Regions * * @deprecated deprecated since version 2.0, Use AlibabaCloud instead. */class EndpointProvider&#123; use EndpointTrait;&#125; 预定义接口Iterator 迭代器Aggregate 集合体Yield 生成器IteratorAggregate魔术常量123456(1). __FILE__ 当前文件路径(2). __DIR__ 当前文件目录(3). __LINE__ 在文件文件的那一行 (4). __FUNCTION__ 在当前文件的那个函数中 返回 函数名(5). __CLASS__ 在当前文件中的那个类中 返回 类名(6). __METHOD__ 在当前文件的类中的那个方法中 返回 类名::方法名 魔术方法12345678910111213141516__construct()，类的构造函数__destruct()，类的析构函数__call()，在对象中调用一个不可访问方法时调用__callStatic()，用静态方式中调用一个不可访问方法时调用__get()，获得一个类的成员变量时调用__set()，设置一个类的成员变量时调用__isset()，当对不可访问属性调用isset()或empty()时调用__unset()，当对不可访问属性调用unset()时被调用。__sleep()，执行serialize()时，先会调用这个函数__wakeup()，执行unserialize()时，先会调用这个函数__toString()，类被当成字符串时的回应方法__invoke()，调用函数的方式调用一个对象时的回应方法__set_state()，调用var_export()导出类时，此静态方法会被调用。__clone()，当对象复制完成时调用__autoload()，尝试加载未定义的类__debugInfo()，打印所需调试信息 范例下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。 一、 __construct()，类的构造函数 php中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 1、 构造方法的作用 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 2、 构造方法的在类中的声明格式1234function __constrct([参数列表])&#123; 方法体 //通常用来对成员属性进行初始化赋值&#125; 3、 在类中声明构造方法需要注意的事项 1、在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。 2、构造方法名称是以两个下画线开始的__construct()下面是它的例子：1234567891011121314151617181920212223242526&lt;?php class Person &#123; public $name; public $age; public $sex; /** * 显示声明一个构造方法且带参数 */ public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /** * say 方法 */ public function say() &#123; echo &quot;我叫：&quot; . $this-&gt;name . &quot;，性别：&quot; . $this-&gt;sex . &quot;，年龄：&quot; . $this-&gt;age; &#125; &#125; 创建对象$Person1且不带任参数12$Person1 = new Person();echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27 创建对象$Person2且带参数“小明” 12$Person2 = new Person(&quot;小明&quot;);echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27 创建对象$Person3且带三个参数 12$Person3 = new Person(&quot;李四&quot;,&quot;男&quot;,25);echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25 二、__destruct()，类的析构函数通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。 析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 析构方法是PHP5才引进的新内容。 析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。 1、 析构方法的声明格式1234function __destruct()&#123; //方法体&#125; 注意：析构函数不能带有任何参数。 2、 析构方法的作用 一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。举例演示，如下：12345678910111213141516171819202122232425262728293031323334&lt;?phpclass Person&#123; public $name; public $age; public $sex; public function __construct($name=&quot;&quot;, $sex=&quot;男&quot;, $age=22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /** * say 说话方法 */ public function say() &#123; echo &quot;我叫：&quot;.$this-&gt;name.&quot;，性别：&quot;.$this-&gt;sex.&quot;，年龄：&quot;.$this-&gt;age; &#125; /** * 声明一个析构方法 */ public function __destruct() &#123; echo &quot;我觉得我还可以再抢救一下，我的名字叫&quot;.$this-&gt;name; &#125;&#125; $Person = new Person(&quot;小明&quot;);unset($Person); //销毁上面创建的对象$Person 上面的程序运行时输出： 我觉得我还可以再抢救一下，我的名字叫小明三、 __call()，在对象中调用一个不可访问方法时调用。该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 1、 __call() 方法的格式： 1234function __call(string $function_name, array $arguments)&#123; // 方法体&#125; 2、 __call() 方法的作用： 为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。 该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。请参考如下代码：123456789101112131415161718192021222324252627282930&lt;?phpclass Person&#123; function say() &#123; echo &quot;Hello, world!&lt;br&gt;&quot;; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funName, $arguments) &#123; echo &quot;你所调用的函数：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行 &#125; &#125;$Person = new Person(); $Person-&gt;run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat(&quot;小明&quot;, &quot;苹果&quot;); $Person-&gt;say();运行结果：你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 四、 __callStatic()，用静态方式中调用一个不可访问方法时调用此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。 请看下面代码：12345678910111213141516171819202122232425262728&lt;?phpclass Person&#123; function say() &#123; echo &quot;Hello, world!&lt;br&gt;&quot;; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funName, $arguments) &#123; echo &quot;你所调用的静态方法：&quot; . $funName . &quot;(参数：&quot; ; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo &quot;)不存在！&lt;br&gt;\n&quot;; // 结束换行 &#125;&#125;$Person = new Person();$Person::run(&quot;teacher&quot;); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat(&quot;小明&quot;, &quot;苹果&quot;);$Person-&gt;say();运行结果如下：你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! 五、 __get()，获得一个类的成员变量时调用在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现“不能访问某个私有属性”的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 魔术方法__get()的作用在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。我们通过下面的 __get() 的实例来更进一步的连接它吧：1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass Person&#123; private $name; private $age; function __construct($name=&quot;&quot;, $age=1) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) &#123; if ($propertyName == &quot;age&quot;) &#123; if ($this-&gt;age &gt; 30) &#123; return $this-&gt;age - 10; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125;&#125;$Person = new Person(&quot;小明&quot;, 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo &quot;姓名：&quot; . $Person-&gt;name . &quot;&lt;br&gt;&quot;; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo &quot;年龄：&quot; . $Person-&gt;age . &quot;&lt;br&gt;&quot;; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值运行结果：姓名：小明年龄：50 六、 __set()，设置一个类的成员变量时调用__set() 的作用：__set( $property, $value ) 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 请看下面的演示代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpclass Person&#123; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) &#123; if ($property==&quot;age&quot;) &#123; if ($value &gt; 150 || $value &lt; 0) &#123; return; &#125; &#125; $this-&gt;$property = $value; &#125; /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say()&#123; echo &quot;我叫&quot;.$this-&gt;name.&quot;，今年&quot;.$this-&gt;age.&quot;岁了&quot;; &#125;&#125; $Person=new Person(&quot;小明&quot;, 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = &quot;小红&quot;; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; //赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); //输出：我叫小红，今年16岁了运行结果：我叫小红，今年16岁了 七、 __isset()，当对不可访问属性调用isset()或empty()时调用在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。 那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？ 分两种情况，如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性，如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？当然是可以的，但不是一成不变。你只要在类里面加上一个isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的isset()方法了帮我们完成这样的操作。 __isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。请看下面代码演示：123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __isset($content) &#123; echo &quot;当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;&quot;; echo isset($this-&gt;$content); &#125;&#125; $person = new Person(&quot;小明&quot;, 25); // 初始赋值echo isset($person-&gt;sex),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;name),&quot;&lt;br&gt;&quot;;echo isset($person-&gt;age),&quot;&lt;br&gt;&quot;;运行结果如下：1 // public 可以 isset()当在类外部使用isset()函数测定私有成员name时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo当在类外部使用isset()函数测定私有成员age时，自动调用 // __isset() 内 第一个echo1 // __isset() 内第二个echo 八、 __unset()，当对不可访问属性调用unset()时被调用。看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。 那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？ 这里自然也是分两种情况： 1、 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 2、 如果对象的成员属性是私有的，我使用这个函数就没有权限去删除。 虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上__unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用`unset()`函数来帮我们删除对象内部的私有成员属性。 请看如下代码：123456789101112131415161718192021222324252627282930313233&lt;?phpclass Person&#123; public $sex; private $name; private $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __unset($content) &#123; echo &quot;当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;&quot;; echo isset($this-&gt;$content); &#125;&#125; $person = new Person(&quot;小明&quot;, 25); // 初始赋值unset($person-&gt;sex);unset($person-&gt;name);unset($person-&gt;age);运行结果：当在类外部使用unset()函数来删除私有成员时自动调用的1当在类外部使用unset()函数来删除私有成员时自动调用的 九、 __sleep()，执行serialize()时，先会调用这个函数serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意： __sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。作用： __sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。具体请参考如下代码：12345678910111213141516171819202122232425262728293031&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @return array */ public function __sleep() &#123; echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125;&#125; $person = new Person(&apos;小明&apos;); // 初始赋值echo serialize($person);echo &apos;&lt;br/&gt;&apos;;代码运行结果：当在类外部使用serialize()时会调用这里的__sleep()方法O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125; 十、 __wakeup()，执行unserialize()时，先会调用这个函数如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。 那么为什么呢？ 因为： 与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。作用：__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。还是看代码：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @return array */ public function __sleep() &#123; echo &quot;当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;&quot;; $this-&gt;name = base64_encode($this-&gt;name); return array(&apos;name&apos;, &apos;age&apos;); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125; /** * __wakeup */ public function __wakeup() &#123; echo &quot;当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;&quot;; $this-&gt;name = 2; $this-&gt;sex = &apos;男&apos;; // 这里不需要返回数组 &#125;&#125; $person = new Person(&apos;小明&apos;); // 初始赋值var_dump(serialize($person));var_dump(unserialize(serialize($person)));运行结果：当在类外部使用serialize()时会调用这里的__sleep()方法string(58) &quot;O:6:&quot;Person&quot;:2:&#123;s:4:&quot;name&quot;;s:8:&quot;5bCP5piO&quot;;s:3:&quot;age&quot;;i:25;&#125;&quot; 当在类外部使用serialize()时会调用这里的__sleep()方法当在类外部使用unserialize()时会调用这里的__wakeup()方法object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; int(2) [&quot;age&quot;]=&gt; int(25) &#125; 十一、 __toString()，类被当成字符串时的回应方法作用： __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。注意： 此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。警告： 不能在 __toString() 方法中抛出异常。这么做会导致致命错误。代码：12345678910111213141516171819202122232425&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __toString() &#123; return &apos;go go go&apos;; &#125;&#125; $person = new Person(&apos;小明&apos;); // 初始赋值echo $person;结果：go go go 那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下： 代码：12345678910111213141516171819202122&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; &#125; $person = new Person(&apos;小明&apos;); // 初始赋值echo $person;结果：Catchable fatal error: Object of class Person could not be converted to string in D:\phpStudy\WWW\test\index.php on line 18很明显，页面报了一个致命错误，这是语法所不允许的。 十二、 __invoke()，调用函数的方式调用一个对象时的回应方法 作用： 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。注意： 本特性只在 PHP 5.3.0 及以上版本有效。直接上代码：12345678910111213141516171819202122232425262728&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __invoke() &#123; echo &apos;这可是一个对象哦&apos;; &#125; &#125; $person = new Person(&apos;小明&apos;); // 初始赋值$person();查看运行结果：这可是一个对象哦当然，如果你执意要将对象当函数方法使用，那么会得到下面结果：Fatal error: Function name must be a string in D:\phpStudy\WWW\test\index.php on line 18 十三、 __set_state()，调用var_export()导出类时，此静态方法会被调用。 作用： 自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。参数： 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何： 上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; &#125; $person = new Person(&apos;小明&apos;); // 初始赋值var_export($person);看结果：Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小明&apos;, &apos;age&apos; =&gt; 25, ))很明显，将对象中的属性都打印出来了加了 __set_state() 之后：继续上代码：&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public static function __set_state($an_array) &#123; $a = new Person(); $a-&gt;name = $an_array[&apos;name&apos;]; return $a; &#125; &#125; $person = new Person(&apos;小明&apos;); // 初始赋值$person-&gt;name = &apos;小红&apos;;var_export($person);继续看结果：Person::__set_state(array( &apos;sex&apos; =&gt; &apos;男&apos;, &apos;name&apos; =&gt; &apos;小红&apos;, &apos;age&apos; =&gt; 25, )) 十四、 __clone()，当对象复制完成时调用在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 作用： 对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 语法： $copy_of_object = clone $object;注意： 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone()方法会被调用，可用于修改属性的值（如果有必要的话）。看代码：1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass Person&#123; public $sex; public $name; public $age; public function __construct($name=&quot;&quot;, $age=25, $sex=&apos;男&apos;) &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __clone() &#123; echo __METHOD__.&quot;你正在克隆对象&lt;br&gt;&quot;; &#125; &#125; $person = new Person(&apos;小明&apos;); // 初始赋值$person2 = clone $person; var_dump(&apos;persion1:&apos;);var_dump($person);echo &apos;&lt;br&gt;&apos;;var_dump(&apos;persion2:&apos;);var_dump($person2);看结果：Person::__clone你正在克隆对象string(9) &quot;persion1:&quot; object(Person)#1 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125; string(9) &quot;persion2:&quot; object(Person)#2 (3) &#123; [&quot;sex&quot;]=&gt; string(3) &quot;男&quot; [&quot;name&quot;]=&gt; string(6) &quot;小明&quot; [&quot;age&quot;]=&gt; int(25) &#125;克隆成功。 十五、__autoload()，尝试加载未定义的类作用： 你可以通过定义这个函数来启用类的自动加载。在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。 但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 还是通过例子来看看吧： 先看看以往的方式： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 文件non_autoload.php */ require_once(&apos;project/class/A.php&apos;); require_once(&apos;project/class/B.php&apos;); require_once(&apos;project/class/C.php&apos;); if (条件A) &#123; $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 &#125; else if (条件B) &#123; $a = newA(); $b = new B(); // … 业务逻辑 &#125;看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。那么如果使用 __autoload() 方式呢？/** * 文件autoload_demo.php */function __autoload($className) &#123; $filePath = “project/class/&#123;$className&#125;.php”; if (is_readable($filePath)) &#123; require($filePath); &#125; &#125; if (条件A) &#123; $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 &#125; else if (条件B) &#123; $a = newA(); $b = new B(); // … 业务逻辑 &#125; ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。 再来看看这里的效率如何，我们分析下： 当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload方法，并将类名“A”作为参数传入。所以，我们在 __autoload()中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。 注意： 这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用 __autoload，而是直接使用内存中的类A，不会导致多次包含。扩展： 其实php发展到今天，已经有将 spl_autoload_register — 注册给定的函数作为 __autoload的实现了1234567891011121314&lt;?phpfunction classLoader($class)&#123; $path = str_replace(&apos;\\&apos;, DIRECTORY_SEPARATOR, $class); $file = __DIR__ . &apos;/src/&apos; . $path . &apos;.php&apos;; if (file_exists($file)) &#123; require_once $file; &#125;&#125;spl_autoload_register(&apos;classLoader&apos;);require_once __DIR__ . &apos;/src/Qiniu/functions.php&apos;; 十六、__debugInfo()，打印所需调试信息 注意： 该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。看代码：12345678910111213141516171819202122232425&lt;?phpclass C &#123; private $prop; public function __construct($val) &#123; $this-&gt;prop = $val; &#125; /** * @return array */ public function __debugInfo() &#123; return [ &apos;propSquared&apos; =&gt; $this-&gt;prop ** 2, ]; &#125;&#125; var_dump(new C(42));结果：object(C)#1 (1) &#123; [&quot;propSquared&quot;]=&gt; int(1764) &#125;再次注意：这里的 `**` 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP细节-02]]></title>
    <url>%2F2018%2F20180331-2.html</url>
    <content type="text"><![CDATA[文件 二进制文件读写 pack() unpack() 系统函数判断图像类型：exif_imagetype() 文件指针 1234fseek() 在文件指针中定位ftell() 返回文件指针读写的位置rewind() 倒回文件指针的位置feof() 测试文件指针是否到了文件结束的位置 超大文件上传 12swfUpload、uploadify 等flash组件XMLHTTPRequest 大文件断点续传+分段上传 ajax2.0 PHP运行原理 UA -&gt; apache -&gt; SAPI -&gt; zend engine -&gt; php script PHP运行模式 CLI模式 命令行接口 1234定时任务shell脚本中使用桌面应用程序PHP server 服务 CGI 通用网关接口 1234就像桥梁一样，把网页和web服务器中的执行程序连接起来，它把http服务器接收的指令传递给执行程序，再把执行程序的结果返回http服务器。CGI跨平台性及佳，几乎可以在任何操作系统实现提供http服务性能比较差，一个请求fork一个进程 FastCGI 快速通用网关接口 12345678也是交互程序与web服务器通信协议。致力于介绍服务器与程序之前互动的开销web服务器启动时，载入FastCGI进程管理器 对于PHP来讲就是php-fpmFastCGI 会启动多个CGI进程等待web服务器的连接收到请求时由FastCGI子进程处理。子进程关闭连接时，请求处理完成。子进程接着等待并处理FastCGI进程管理器的下一个连接提供http服务支持大并发多进程消耗较多内存 模块模式 apache 和 ISS 进程、线程、协程 单进程：单个CPU一次只能运行一个任务 一个进程可以包括多个线程（防止多个线程同时读写某一块区域加锁机制） 协程避免了无意义的调度，由此提高了性能。但因此要程序员自己承担调度的责任，同时也失去了标准线程使用多CPU的能力 多进程形式，允许多个任务同时运行多线程形式，允许单个任务分成不同部分运行 ts Thread safe 线程安全，执行时会进程线程安全检查，防止有新要求就启动新线程的执行方式而耗尽系统资源 nts Non Thread Safe 非线程安全，在执行时不进行线程安全检查 由于ISAPI是线程执行的，所以选择PHP版本时要选择TS版本的。其它选择NTS版本就行了。 Apache 的 prefork 模块 prefork 采用预派生子进程模式，用单独的子进程来处理不同的请求，进程之间彼此独立。httpd-mpm.conf 配置包括： 12345StartServers 5 # 初始化进程数量MinSpareServers 5 # 空闲进程总数最小值MaxApareServers 10 # 空闲进程总数最大值MaxClients 150 # 最大客户端连接数量限制MaxRequestsPerChild 0 # 子进程减能处理的请求数量 Apache 的 worker 模块 worker 全新的支持多线程和多进程混合模型的MPM，由于使用线程来处理，所以可以处理相对海量的数据请求。而系统资源的开销要小于基于进程的服务器 Apache 的 event 模式 为什么大访问量下NGINX性能更高？ Apache 所采用的select 网络 I/O 模型非常低效Nginx 使用了最新的epoll 和 kqueue(freebsd) 网络 I/O 模型PHP是 Apache 的一个扩展模块，所以Apache 进程 干的事情也比较多，执行PHP、输出HTML 都得干，占用的资源也多（CPU，内存） PHP运行机制与原理 PHP 底层原理 PHP通过 SAPI 和 Apache相连PHP总共有三个模块：内核、Zend引擎、以及扩展层PHP内核用来处理请求、文件流、错误处理等相关操作Zend引擎（ZE）用以将源文件转换成机器语言，然后在虚拟机上运行它；扩展层是一株函数、类库和流，PHP使用它们来执行一些特定的操作，如：MySQL扩展来连接MySQL数据库ZE引擎执行程序是可能需要连接若干扩展，这是ZE将控制权交给扩展，等待处理完任务和再返还最后ZE将程序运行结果反回给PHP内核，它再将结果传送给SAPI传给Apache PHP运行机制 扫描 解析 编译 执行 输出 PHP垃圾回收机制没有引用的内存变量就垃圾，PHP开启了很多内存空间，如果不销毁内存会一点点的被吃掉，最终导致内存溢出。 找到所有已定义的变量：get_defined_vars refcount_gc 是否为0 就知道是不是垃圾 无引用的变量 (清除为0的5.2版本以前 5.3以后 采用了引用计数系统中的同步周期回收算法来清除) 当我们存储的疑似垃圾区域满了的时候，就会被执行清除垃圾的操作。前提是开启了 php.ini 中的 zend.enable_gc 配置 也可以调用 gc_enable() 和 gc_disable() 打开和关闭垃圾回收机制 也可以通过 gc_collect_cycles() 强制执行周期回收 PHP常用选项 display_errors 是否显示错误信息 辅助开发使用，不要在生产环境使用 error_reporting 设置错误报告的级别 variables_order 设置EGPCS超全局变量的解析顺序 request_order 确定 $_GET 和 $_POST 等超全局变量的顺序，后面的会把前面的数据重写覆盖 “GP” disable_classes 、 disable_functions 禁用某些类和某些函数 HTTP 协议1234GET /index.html HTTP/1.1HOST: www.example.comRange: bytcs-500-999Connection:keep-alive HTTP 工作流程访问一个网址时，发生了什么？ 通过DNS解析域名对应的服务器IP地址 建立TCP连接 向服务器发送请求 返回内容 javascript 闭包 闭包使用不当可能会导致内存泄露。闭包是指有权访问另一个函数作用域中的变量的函数一个外部函数执行完毕后，由于其内部函数被外部引用，导致其作用域中的变量存活，而不能在函数执行完毕后被销毁，包含这些变量的那个对象就被称为闭包]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP细节-01]]></title>
    <url>%2F2018%2F20180331-1.html</url>
    <content type="text"><![CDATA[字符串 双引号或者heredoc其中的变量 以及 \ 开始的符合8进制16进制和特殊符号 字符串底层是C语言的结构体，所以可以用[] 或 {} 来访问某个字符 字符串最大长度可以达到2G内存 C语言字符串\0代表字符串结束，但PHP结构体是有个长度字段，可以让二进制字符串安全 用超出字符串长度的下标写入将会拉长字符串并以空格填充 UTF-8 编码 16进制 Unicode 编码范围 0800 - FFFF2进制 1110xxxx 10xxxxxx 10xxxxxx为了通用优先选择UTF-8 3个字节,为了节省空间用GBK 2个字节 数组 key 可以是integer 或者 string (包含合法整形的字符串，浮点数和布尔值都会被转化为整形) unset() 后，不会重建索引 遍历中的引用分析 1234567891011121314&lt;?php$arr = [1,2,3];foreach ($arr as $key =&gt; &amp;$value) &#123;&#125;echo $value; // 3 是 &amp;$arr[2] = 3;foreach ($arr as $key =&gt; $value) &#123;&#125;var_dump($arr); // [1,2,2]// 循环1 $value = &amp;$arr[2] = $arr[0] = 1;// 循环2 $value = &amp;$arr[2] = $arr[1] = 2;// 循环3 $value = &amp;$arr[2] = $arr[2] = 2; 位运算：$a&amp;1 == 0 偶数 反之奇数 正则表达式定义组成 = 元字符 + 普通字符常见元字符123456789101112131415^ 匹配字符串的开始$ 匹配字符串的结束. 匹配除换行以外的任意字符\w 匹配字母或者数字或者下划线\W 不匹配字母数字下划线\s 匹配任意的空字符 相当于[\f\r\n\t\v]\d 匹配任意的数字\b 匹配单词的开始或者结束\xxx 查找以八进制xxx规定的字符\xdd 查找以十六进制dd对顶的字符\uxxx 查找以十六进制 xxxx 规定的 Unicode 字符[abcd] 匹配任意一个字符[a-d] 匹配任意一个字符[^abcd] 不匹配任意一个字符[\u4e00-\u9fa5] 匹配任意单个汉字 常见限定符 （限定的是前面一个单元）1234567| 或关系* 匹配0到多个，相当于&#123;0,&#125;? 匹配0到1个，相当于&#123;0,1&#125;+ 匹配至少1个字符，相当于&#123;1,&#125;&#123;n&#125; 匹配n个字符&#123;n,&#125; 匹配至少n个字符&#123;n,m&#125; 匹配n到m个字符 环视1234(?=exp) 位置后面能匹配exp(?!=exp) 位置后面不能匹配exp(?&lt;=exp) 位置前面能匹配exp(?&lt;!exp) 位置前面不能匹配exp 贪婪与懒惰 通常的行为是尽可能匹配多的字符（回溯）只要在它后面加一个问号，匹配成功的前提是使用最少的重复 1234567891011121314151617181920212223242526&lt;?php$string = &apos;aaabaab&apos;;$pattern1 = &apos;/a.&#123;1,10&#125;b/&apos;;$pattern2 = &apos;/a.&#123;1,10&#125;?b/&apos;;preg_match_all($pattern1,$string,$matchs1);preg_match_all($pattern2,$string,$matchs2);var_dump($matchs1);var_dump($matchs2);array(1) &#123; [0]=&gt; array(1) &#123; [0]=&gt; string(7) &quot;aaabaab&quot; &#125;&#125;array(1) &#123; [0]=&gt; array(2) &#123; [0]=&gt; string(4) &quot;aaab&quot; [1]=&gt; string(3) &quot;aab&quot; &#125;&#125; 回溯 贪婪模式的回溯是影响性能 习惯 优先使用单引号 内置函数： 121. 邮件过滤：$email = filter_var(&apos;hi@uiste.com&apos;, FILTER_VALIDATE_EMAIL);2. 获取文件扩展名：pathinfo($filename, PATHINFO_EXTENSION); strtr 与 str_replace 函数前者优先级更高 yield 实现协程 生成器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function createRange($number)&#123; for($i=0;$i&lt;$number;$i++)&#123; yield time(); &#125;&#125;$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); echo $value , PHP_EOL;&#125;1554027375155402737615540273771554027378155402737915540273801554027381155402738215540273831554027384[Finished in 10.2s]我们来还原一下代码执行过程。首先调用 createRange 函数，传入参数10，但是 for 值执行了一次然后停止了，并且告诉 foreach 第一次循环可以用的值。 foreach 开始对 $result 循环，进来首先 sleep(1) ，然后开始使用 for 给的一个值执行输出。 foreach 准备第二次循环，开始第二次循环之前，它向 for 循环又请求了一次。 for 循环于是又执行了一次，将生成的时间戳告诉 foreach . foreach 拿到第二个值，并且输出。由于 foreach 中 sleep(1) ，所以， for 循环延迟了1秒生成当前时间所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。无论开始传入的 $number 有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。读取超大文件PHP开发很多时候都要读取大文件，比如csv文件、text文件，或者一些日志文件。这些文件如果很大，比如5个G。这时，直接一次性把所有的内容读取到内存中计算不太现实。&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);function readTxt()&#123; # code... $handle = fopen(&quot;./test.txt&quot;, &apos;rb&apos;); while (feof($handle)===false) &#123; # code... yield fgets($handle); &#125; fclose($handle);&#125;foreach (readTxt() as $key =&gt; $value) &#123; # code... echo $value , PHP_EOL;&#125; 语法支持带来更高效率 用 ** 更快 12echo 2**3 , PHP_EOL;echo pow(2,3) , PHP_EOL; 用 … 定义变成参数 &lt;=&gt; 大于为1，等于为0，小于为-1 if 使用技巧给定初始值，比增加else效率更高 if 使用技巧 三元运算符替换 去掉多此一举的写法 直接return 出去，尽量精简代码 根据二维数组中的某个键值排序：12// 根据uv_price排序array_multisort(array_column($productData, &apos;uv_price&apos;), SORT_DESC, $productData); php坑人题123456789&lt;?php$a = 3;$b = 6;if($a = 5 || $b = 7)&#123; $a++; ++$b;&#125;echo $a . '-' . $b; //1-7 1234567891011&lt;?php$count = 5;function getCount()&#123; static $count = 0; return $count++;&#125;echo ++$count . PHP_EOL; //6echo getCount() . PHP_EOL; //0echo getCount() . PHP_EOL; //1 12&lt;?phpecho count('1234') + count(null) + count(false) . PHP_EOL; // 1+0+1 = 2 12345678910111213141516171819&lt;?php$a = 0.2+0.7;$b = 0.9;echo $a . PHP_EOL; // 0.9echo $b . PHP_EOL; // 0.9var_dump($a == $b); // bool(false)// php在比较浮点数大小时，需要把浮点数转为字符串进行比较。要使用 BC 这个函数库，要在编译 PHP 程序时加入 --enable-bcmath 的选项。bcadd: 将二个高精确度数字相加。bccomp: 比较二个高精确度数字。bcdiv: 将二个高精确度数字相除。bcmod: 取得高精确度数字的余数。bcmul: 将二个高精确度数字相乘。bcpow: 求一高精确度数字次方值。bcscale: 配置程序中所有 BC 函数库的默认小数点位数。bcsqrt: 求一高精确度数字的平方根。bcsub: 将二个高精确度数字相减。]]></content>
  </entry>
  <entry>
    <title><![CDATA[brew更换国内镜像源]]></title>
    <url>%2F2018%2F20180329-5.html</url>
    <content type="text"><![CDATA[homebrew主要分两部分：git repo（位于GitHub）和二进制bottle（位于binary），这两者在国内访问不太顺畅。其实可以替换成国内的镜像，git repo国内镜像就比较多了，可以自行查找，如：中科大镜像… 替换homebrew默认源1234567替换brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git替换homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 如果替换源之后brew update 没反应12cd &quot;$(brew --repo)&quot;git pull origin master 切回官方源1234567重置brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git重置homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git 注释掉bash配置文件里的有关Homebrew Bottles即可恢复官方源。 重启bash或让bash重读配置文件。Homebrew Bottles是Homebrew提供的二进制代码包，目前镜像站收录了以下仓库： 对于bash用户12echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.bash_profilesource ~/.bash_profile 对于zsh用户12echo &apos;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&apos; &gt;&gt; ~/.zshrcsource ~/.zshrc]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F2018%2F20180329-4.html</url>
    <content type="text"><![CDATA[网络协议为计算机网络中进行数据交换而建立的规则,标准或约定的集合,所有的计算机/手机等网络设备通信都得遵循网络协议.网络协议根据通信的步骤,层级划分为7个层级,从上往下为: 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 内容来源： easyswoole]]></content>
  </entry>
  <entry>
    <title><![CDATA[立个flag]]></title>
    <url>%2F2018%2F20180329-3.html</url>
    <content type="text"><![CDATA[好久都没有在这里写笔记了。记录的地方比较零散，有道云、OneNote、web博客(域名迁移备案失效，服务器也关闭了)。有时候突然想要查找一些内容都忘记放在哪里了。也就只能是一个记录过程却少了一些查找的过程。立个flag以后继续记录在这里了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx 配置]]></title>
    <url>%2F2018%2F20180329-2.html</url>
    <content type="text"><![CDATA[负载均衡1234567891011121314151617http &#123; upstream http_server &#123; server x.x.x.x weight=10; # 权重 server x.x.x.x weight=20; # 权重 &#125; upstream backend &#123; server 127.0.0.1:8080; server 127.0.0.1:9090; ip_hash; # ip_hash &#125; server &#123; ... &#125;&#125; nginx 转发比较消耗CPU nginx 转发12345678910111213141516server &#123; listen 8888; server name localhost; #access_log logs/host.access.log main; location / &#123; root /home/...; index index.html index.htm if (!-e $request_filename) &#123; # 找不到请求地址 proxy_pass http://127.0.0.1:8811; # 单机转发 外网IP #proxy_pass http://http_server; # 负载均衡名称 &#125; &#125;&#125; nginx 的 upstream权重配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586权重配置：weight和请求数量成正比，主要用于上游服务器配置不均衡的情况。下面的配置中，192.168.10.2机器的请求量是192.168.10.1机器请求量的2倍。upstream nodes &#123;server 192.168.10.1:8668 weight=5;server 192.168.10.2:8668 weight=10;&#125;ip_hash配置：每一个请求按照请求的ip的hash结果分配。这样每一个请求固定落在一个上游服务器，能够解决ip会话在同一台服务器的问题。upstream nodes &#123;ip_hash;server 192.168.10.1:8668;server 192.168.10.2:8668;&#125;fair配置：按上游服务器的响应时间来分配请求。响应时间短的优先分配。upstream nodes &#123;server 192.168.10.1:8668;server 192.168.10.2:8668;fair;&#125;url_hash配置：按照访问的url的hash结果来分配请求，使每一个url定向到同一个上游服务器。注意：在upstream中加入hash语句。server语句中不能写入weight等其他的參数，hash_method是使用的hash算法。upstream nodes &#123;server 192.168.10.1:8668;server 192.168.10.2:8668;hash $request_uri;hash_method crc32;&#125;下面再说下在upstream中常用的配置项：down：表示当前的server不參与负载均衡。weight：默觉得1，weight越大，负载的权重就越大。max_fails ：请求失败的次数默觉得1。fail_timeout : max_fails次失败后，暂停请求此台服务器的时间。backup： 其他全部的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。upstream nodes &#123;ip_hash;server 192.168.10.1:8668 down;server 192.168.10.2:8668 weight=2;server 192.168.10.3:8668;server 192.168.10.4:8668 backup;&#125; Linux命令机器名hostname -i 端口netstat -anp | grep 8888]]></content>
  </entry>
  <entry>
    <title><![CDATA[sheel 脚本]]></title>
    <url>%2F2018%2F20180329-1.html</url>
    <content type="text"><![CDATA[reload.sh 平滑重启12345echo &quot;loading...&quot;pid = `pidof live_master`echo $pidkill -USR1 $pidecho &apos;&quot;loading success&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql 常见问题]]></title>
    <url>%2F2018%2F20180328-1.html</url>
    <content type="text"><![CDATA[mysql8.0 设置简单密码报错ERROR 1819 (HY000): Your password does not satisfy the current policy requirements1234567891011121314151617181920212223242526272829mysql&gt; SHOW VARIABLES LIKE &apos;validate_password%&apos;;+--------------------------------------+--------+| Variable_name | Value |+--------------------------------------+--------+| validate_password.check_user_name | ON || validate_password.dictionary_file | || validate_password.length | 8 || validate_password.mixed_case_count | 1 || validate_password.number_count | 1 || validate_password.policy | MEDIUM || validate_password.special_char_count | 1 |+--------------------------------------+--------+7 rows in set (0.01 sec)mysql&gt; set global validate_password.policy=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password.length=4;Query OK, 0 rows affected (0.00 sec)mysql&gt; exit;Bye➜ ~ mysql_secure_installationSecuring the MySQL server deployment.Enter password for user root:Error: Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) Syntax error or access violation: 1055 Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column ‘XXX.Y.ZZZZ’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by 原因：MySQL 5.7.5和up实现了对功能依赖的检测。如果启用了only_full_group_by SQL模式(在默认情况下是这样)，那么MySQL就会拒绝选择列表、条件或顺序列表引用的查询，这些查询将引用组中未命名的非聚合列，而不是在功能上依赖于它们。(在5.7.5之前，MySQL没有检测到功能依赖项，only_full_group_by在默认情况下是不启用的。关于前5.7.5行为的描述，请参阅MySQL 5.6参考手册。) 执行以下个命令，可以查看 sql_mode 的内容。123456 mysql&gt; SHOW SESSION VARIABLES; mysql&gt; SHOW GLOBAL VARIABLES; mysql&gt; select @@sql_mode; 可见session和global 的sql_mode的值都为： ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION only_full_group_by说明：only_full_group_by ：使用这个就是使用和oracle一样的group 规则, select的列都要在group中,或者本身是聚合列(SUM,AVG,MAX,MIN) 才行，其实这个配置目前个人感觉和distinct差不多的，所以去掉就好官网摘抄：官网：ONLY_FULL_GROUP_BYReject queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are neither named in the GROUP BY clause nor are functionally dependent on (uniquely determined by) GROUP BY columns. As of MySQL 5.7.5, the default SQL mode includes ONLY_FULL_GROUP_BY. (Before 5.7.5, MySQL does not detect functional dependency and ONLY_FULL_GROUP_BY is not enabled by default. For a description of pre-5.7.5 behavior, see the MySQL 5.6 Reference Manual.) A MySQL extension to standard SQL permits references in the HAVING clause to aliased expressions in the select list. Before MySQL 5.7.5, enabling ONLY_FULL_GROUP_BY disables this extension, thus requiring the HAVING clause to be written using unaliased expressions. As of MySQL 5.7.5, this restriction is lifted so that the HAVING clause can refer to aliases regardless of whether ONLY_FULL_GROUP_BY is enabled. 解决：执行以下两个命令：123mysql&gt; set global sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;mysql&gt; set session sql_mode=&apos;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;; 这两个命令，去掉 sql_mode 的 ONLY_FULL_GROUP_BY Mac OS X 完全卸载MySQL12345678910111213141516171819执行下列命令servie.mysql stopbrew uninstall mysqlsudo rm /usr/local/mysqlsudo rm -rf /usr/local/mysql*sudo rm -rf /Library/StartupItems/MySQLCOMsudo rm -rf /Library/PreferencePanes/My*rm -rf ~/Library/PreferencePanes/My*sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /var/db/receipts/com.mysql.*其实不同的安装方式有些东西的存储位置不一样，删除完检查一下下面这些文件是否删除了，没有的话则删除掉：/usr/local/Cellar 里的mysql文件/usr/local/var 里的mysql文件/tmp 里的mysql.sock, mysql.sock.lock, my.cnf文件pid文件和err文件都在/usr/local/var/mysql里确保删除了brew安装的安装包存储在/usr/local/Library/Cache/Homebrew也可以一并删除执行brew cleanup]]></content>
  </entry>
  <entry>
    <title><![CDATA[swoole]]></title>
    <url>%2F2018%2F20180325-3.html</url>
    <content type="text"><![CDATA[安装PHP安装sowoole 扩展123456789101112131415➜ package cd swoole➜ swoole git:(master) phpizeConfiguring for:PHP Api Version: 20170718Zend Module Api No: 20170718Zend Extension Api No: 320170718➜ swoole git:(master) ./configure➜ swoole git:(master) make &amp;&amp; make installs···Build complete.Don&apos;t forget to run &apos;make test&apos;.Installing shared extensions: /usr/local/Cellar/php@7.2/7.2.16/pecl/20170718/Installing header files: /usr/local/Cellar/php@7.2/7.2.16/include/php/ ws_server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;?phpclass Ws &#123; CONST HOST = "0.0.0.0"; CONST PORT = 8811; CONST CHART_PORT = 8812; public $ws = null; public function __construct() &#123; // 获取 key 有值 del $this-&gt;ws = new swoole_websocket_server(self::HOST, self::PORT); $this-&gt;ws-&gt;listen(self::HOST, self::CHART_PORT, SWOOLE_SOCK_TCP); $this-&gt;ws-&gt;set( [ 'enable_static_handler' =&gt; true, 'document_root' =&gt; "/home/work/hdtocs/swoole_mooc/thinkphp/public/static", 'worker_num' =&gt; 4, 'task_worker_num' =&gt; 4, ] ); $this-&gt;ws-&gt;on("start", [$this, 'onStart']); $this-&gt;ws-&gt;on("open", [$this, 'onOpen']); $this-&gt;ws-&gt;on("message", [$this, 'onMessage']); $this-&gt;ws-&gt;on("workerstart", [$this, 'onWorkerStart']); $this-&gt;ws-&gt;on("request", [$this, 'onRequest']); $this-&gt;ws-&gt;on("task", [$this, 'onTask']); $this-&gt;ws-&gt;on("finish", [$this, 'onFinish']); $this-&gt;ws-&gt;on("close", [$this, 'onClose']); $this-&gt;ws-&gt;start(); &#125; /** * @param $server */ public function onStart($server) &#123; swoole_set_process_name("live_master"); &#125; /** * @param $server * @param $worker_id */ public function onWorkerStart($server, $worker_id) &#123; // 定义应用目录 define('APP_PATH', __DIR__ . '/../../../application/'); // 加载框架里面的文件 //require __DIR__ . '/../thinkphp/base.php'; require __DIR__ . '/../../../thinkphp/start.php'; &#125; /** * request回调 * @param $request * @param $response */ public function onRequest($request, $response) &#123; if($request-&gt;server['request_uri'] == '/favicon.ico') &#123; $response-&gt;status(404); $response-&gt;end(); return ; &#125; $_SERVER = []; if(isset($request-&gt;server)) &#123; foreach($request-&gt;server as $k =&gt; $v) &#123; $_SERVER[strtoupper($k)] = $v; &#125; &#125; if(isset($request-&gt;header)) &#123; foreach($request-&gt;header as $k =&gt; $v) &#123; $_SERVER[strtoupper($k)] = $v; &#125; &#125; $_GET = []; if(isset($request-&gt;get)) &#123; foreach($request-&gt;get as $k =&gt; $v) &#123; $_GET[$k] = $v; &#125; &#125; $_FILES = []; if(isset($request-&gt;files)) &#123; foreach($request-&gt;files as $k =&gt; $v) &#123; $_FILES[$k] = $v; &#125; &#125; $_POST = []; if(isset($request-&gt;post)) &#123; foreach($request-&gt;post as $k =&gt; $v) &#123; $_POST[$k] = $v; &#125; &#125; $this-&gt;writeLog(); $_POST['http_server'] = $this-&gt;ws; ob_start(); // 执行应用并响应 try &#123; think\Container::get('app', [APP_PATH]) -&gt;run() -&gt;send(); &#125;catch (\Exception $e) &#123; // todo &#125; $res = ob_get_contents(); ob_end_clean(); $response-&gt;end($res); &#125; /** * @param $serv * @param $taskId * @param $workerId * @param $data */ public function onTask($serv, $taskId, $workerId, $data) &#123; // 分发 task 任务机制，让不同的任务 走不同的逻辑 $obj = new app\common\lib\task\Task; $method = $data['method']; $flag = $obj-&gt;$method($data['data'], $serv); /*$obj = new app\common\lib\ali\Sms(); try &#123; $response = $obj::sendSms($data['phone'], $data['code']); &#125;catch (\Exception $e) &#123; // todo echo $e-&gt;getMessage(); &#125;*/ return $flag; // 告诉worker &#125; /** * @param $serv * @param $taskId * @param $data */ public function onFinish($serv, $taskId, $data) &#123; echo "taskId:&#123;$taskId&#125;\n"; echo "finish-data-sucess:&#123;$data&#125;\n"; &#125; /** * 监听ws连接事件 * @param $ws * @param $request */ public function onOpen($ws, $request) &#123; // fd redis [1] \app\common\lib\redis\Predis::getInstance()-&gt;sAdd(config('redis.live_game_key'), $request-&gt;fd); var_dump($request-&gt;fd); &#125; /** * 监听ws消息事件 * @param $ws * @param $frame */ public function onMessage($ws, $frame) &#123; echo "ser-push-message:&#123;$frame-&gt;data&#125;\n"; $ws-&gt;push($frame-&gt;fd, "server-push:".date("Y-m-d H:i:s")); &#125; /** * close * @param $ws * @param $fd */ public function onClose($ws, $fd) &#123; // fd del \app\common\lib\redis\Predis::getInstance()-&gt;sRem(config('redis.live_game_key'), $fd); echo "clientid:&#123;$fd&#125;\n"; &#125; /** * 记录日志 */ public function writeLog() &#123; $datas = array_merge(['date' =&gt; date("Ymd H:i:s")],$_GET, $_POST, $_SERVER); $logs = ""; foreach($datas as $key =&gt; $value) &#123; $logs .= $key . ":" . $value . " "; &#125; swoole_async_writefile(APP_PATH.'../runtime/log/'.date("Ym")."/".date("d")."_access.log", $logs.PHP_EOL, function($filename)&#123; // todo &#125;, FILE_APPEND); &#125;&#125;new Ws(); ws_client12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;singwa-swoole-ws测试&lt;h1&gt; &lt;script&gt; var wsUrl = "ws://swoole.demo.com:8812"; var websocket = new WebSocket(wsUrl); //实例对象的onopen属性 websocket.onopen = function(evt) &#123; websocket.send("hello-sinwa"); console.log("conected-swoole-success"); &#125; // 实例化 onmessage websocket.onmessage = function(evt) &#123; console.log("ws-server-return-data:" + evt.data); &#125; //onclose websocket.onclose = function(evt) &#123; console.log("close"); &#125; //onerror websocket.onerror = function(evt, e) &#123; console.log("error:" + evt.data); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 定时器1234567891011121314151617181920212223&lt;?phpclass Server &#123; const PORT = 8811; public function port() &#123; $shell = &quot;netstat -anp 2&gt;/dev/null | grep &quot;. self::PORT . &quot; | grep LISTEN | wc -l&quot;; $result = shell_exec($shell); if($result != 1) &#123; // 发送报警服务 邮件 短信 /// todo echo date(&quot;Ymd H:i:s&quot;).&quot;error&quot;.PHP_EOL; &#125; else &#123; echo date(&quot;Ymd H:i:s&quot;).&quot;succss&quot;.PHP_EOL; &#125; &#125;&#125;// nohupswoole_timer_tick(2000, function($timer_id) &#123; (new Server())-&gt;port(); echo &quot;time-start&quot;.PHP_EOL;&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[php-ini 文件]]></title>
    <url>%2F2018%2F20180325-2.html</url>
    <content type="text"><![CDATA[多个版本改哪个文件下的php.ini 配置才有效？123➜ package php -i | grep php.iniConfiguration File (php.ini) Path =&gt; /usr/local/etc/php/7.2Loaded Configuration File =&gt; /usr/local/etc/php/7.2/php.ini 别名设置12345➜ package vim ~/.bash_profile alias php72=/Users/uiste/Downloads/package/soft/php/bin/php➜ package source ~/.bash_profile 编译时指定PHP配置信息123# ./configure \--prefix=/usr/local/php \ # 安装路径--with-config-file-path=/etc # 配置路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2 升级后 Yii2 升级]]></title>
    <url>%2F2018%2F20180325-1.html</url>
    <content type="text"><![CDATA[问题 PHP升级7.2后，Yii 2.0.12 版本由于类命名约束问题会产生如下问题： 1Fatal error: Cannot use &apos;Object&apos; as class name as it is reserved in /Users/uiste/www/my_project/mike-app/vendor/yiisoft/yii2/base/Object.php on line 77 升级方法12345678910111213141516171819202122➜ mike-app git:(version-update) composer installLoading composer repositories with package informationInstalling dependencies (including require-dev) from lock fileNothing to install or updateGenerating autoload files➜ mike-app git:(version-update) composer global require &quot;fxp/composer-asset-plugin:^1.4.1&quot;Changed current directory to /Users/uiste/.composer./composer.json has been updatedLoading composer repositories with package informationUpdating dependencies (including require-dev)Package operations: 0 installs, 1 update, 0 removals - Updating fxp/composer-asset-plugin (v1.2.2 =&gt; v1.4.4): Downloading (100%) Writing lock fileGenerating autoload files➜ mike-app git:(version-update) composer update yiisoft/yii2 yiisoft/yii2-composer bower-asset/jquery.inputmaskThe &quot;extra.asset-installer-paths&quot; option is deprecated, use the &quot;config.fxp-asset.installer-paths&quot; optionLoading composer repositories with package informationUpdating dependencies (including require-dev) GitHub API limit (60 calls/hr) is exhausted, could not fetch https://api.github.com/repos/RobinHerbots/Inputmask/contents/bower.json?ref=4.x. Create a GitHub OAuth token to go over the API rate limit. You can also wait until 2018-03-25 07:52:25 for the rate limit to reset.Head to https://github.com/settings/tokens/new?scopes=repo&amp;description=Composer+on+uiste+2018-03-25+0657to retrieve a token. It will be stored in &quot;/Users/uiste/.composer/auth.json&quot; for future use by Composer.Token (hidden): 浏览器打开：https://github.com/settings/tokens/new?scopes=repo&amp;description=Composer+on+localhost.localdomain+2018-03-25+1945登录github账号 生成token ，在命令行输入即可 token 继续1composer updated]]></content>
  </entry>
  <entry>
    <title><![CDATA[安装walle后进行检测错误总出现的问题解决]]></title>
    <url>%2F2018%2F20180223-1.html</url>
    <content type="text"><![CDATA[安装walle后进行检测错误总出现的问题解决安装好 walle后，进行项目配置，但是检测总是出现错误，错误如下： 宿主机代码检出检测出错，请确认把php进程用户www的ssh-key加入git的deploy-keys列表。 目标机器检测出错，请确认php进程www用户ssh-key加入目标机器的www用户ssh-key信任列表。 目标机 ansible ping 出错，请检查 ~/.ssh/config 及 ssh 证书配置目标机器检测出错，请确认www有目标机器发布版本库/data/www/publish写入权限。 解决方法： 1，在宿主机安装了ansible后，就消灭了一个关于ansible未安装的问题 2，其实我们是把宿主机器php进程用户www加入了目标机器www用户的信任authired_keys表的，但是任然报未加入，此处，主要的错误就是因为我们在目标机器中对于 www用户的.ssh文件夹和authorized_keys的权限和所属者； chmod -R 755 /home/www/ chmod -R 700 /home/www/.ssh/ chmod -R 644 /home/www/.ssh/authorized_keys 必须满足以上三个条件才能免密码登录，同时也是解决总报没有加入目标机器信任列表的问题关键 chown www.www -R /home/www 将所属者为www用户 需要记住的宿主机和目标机器的 .ssh authorized_keys /home/www/ 都需要注意权限问题]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mysql 相关命令]]></title>
    <url>%2F2018%2F20180222-1.html</url>
    <content type="text"><![CDATA[Mysql 添加阿里RDS远程登陆用户12345mysql&gt; use mysql;mysql&gt; select user,host from user;mysql&gt; grant all privileges on *.* to &apos;dms&apos;@&apos;121.43.18.67&apos; identified by &apos;mypassword&apos;;mysql&gt; flush privileges; mysql&gt; quit;]]></content>
  </entry>
  <entry>
    <title><![CDATA[此项目将被立刻删除，您不能撤销此操作]]></title>
    <url>%2F2018%2F20180221-1.html</url>
    <content type="text"><![CDATA[mac 删除文件不经过废纸篓，提示“此项目将被立刻删除，您不能撤销此操作。”，解决办法。 终端机运行两个命令：12rm -R ~/.Trashkillall Finder 退出终端机。 如果它说你没有权限删除，那么就这样：12sudo rm -R ~/.Trashkillall Finder 删除废纸篓，finder会自动生成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux 配置，命令]]></title>
    <url>%2F2018%2F20180219-2.html</url>
    <content type="text"><![CDATA[服务器配置添加管理员用户1234567891011121314151617181920212223242526272829303132333435363738# useradd test# passwd test# mkdir -p /home/test/.ssh# chown 600 /home/test/.ssh/# vim /etc/sudoers# cd /home/test/.ssh/# rz# # Received /Users/uiste/.ssh/id_rsa.pub# ls# mv id_rsa.pub authorized_keys# ls -al# chown test:test authorized_keys # chmod 700 authorized_keys # ls -al# chmod 600 authorized_keys # ls# pwd# chown test:test /home/test/.ssh# ls -al /home/test/# 自定义生成ssh keyroot@iZbp1bb2egi7vzn29c1dhvZ ~]# su - www上一次登录：二 1月 1 22:49:16 CST 2019pts/1 上[www@iZbp1bb2egi7vzn29c1dhvZ ~]$ sudo su -Last login: Tue Jan 1 22:49:46 CST 2019 from 223.167.32.98 on pts/2[root@iZbp1bb2egi7vzn29c1dhvZ ~]# su - wwwLast login: Tue Jan 1 22:50:58 CST 2019 on pts/2[www@iZbp1bb2egi7vzn29c1dhvZ ~]$ ssh-keygen -t rsa# useradd test修改管理员配置# vim /etc/sudoers## Allow root to run any commands anywhere root ALL=(ALL) ALLtest ALL=(ALL) NOPASSWD: ALL 切换用户12345# 切换自定用户# su - test# 切换root用户# sudo su - 配置SSH123456789101112131415161718192021222324252627chown test:test /home/test/chmod 755 /home/test/.ssh/[test@izbp14s0hny0qt9wghm6lcz .ssh]$ ls -altotal 12drwxr-xr-x 2 test test 4096 Sep 26 10:54 .drwx------ 3 test test 4096 Sep 26 10:44 ..-rw------- 1 test test 411 Sep 26 10:36 authorized_keys[test@izbp14s0hny0qt9wghm6lcz .ssh]$ cat authorized_keys ssh-rsa AAAAB3Nza...E27svfEF6qsVb9B5dooFFFS5hNjyJJma8dyCLzmpAKXH......8XDB+ofAZYkF/7NyU9ON0OwkKWJL4jL570kfazGgJQQwrjWh5x5.....nLsLvQB2rnjbeyV+RXnNemMutokrjIgrT Administrator@PC-20180613WOHL``` ## 常用命令* 递归创建文件夹`mkdir -p /data/yiilogs/`* 修改文件夹用户`chown test:test /data/yiilogs/`* 修改文件读写权限`chmod 777 /data/yiilogs/`* 查看端口占用情况`netstat -tunlp | grep 3306`* 匹配log中自定内容信息 tail -f /data/yiilog/xxx/access_app_nginx.log |grep ‘interface-loan/xxx’`]]></content>
  </entry>
  <entry>
    <title><![CDATA[lnmp环境 (centos7+nginx+MySQL5.7.9+PHP7)]]></title>
    <url>%2F2018%2F20180219-1.html</url>
    <content type="text"><![CDATA[安装nginx 首先更新系统软件 1# yum update 安装 安装nginx源 1# yum localinstall http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 安装nginx 1yum install nginx 启动nginx 12# service nginx startRedirecting to /bin/systemctl start nginx.service 访问http://你的ip/ 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384vim /etc/nginx/conf.d/service.conf# api-doc.xxx.comserver &#123;listen 80; #默认监听 80 端口server_name api-doc.xxx.com; #配置域名或者公网 iplocation / &#123; proxy_pass http://127.0.0.1:4000; &#125;&#125;# api-doc.xxx.comserver &#123; listen 80; server_name api-doc.xxx.com; location / &#123; root /data/web/blackuser-api-doc/_book; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location ~ /\.ht &#123; deny all; &#125;&#125;# admin.xxx.comserver&#123; listen 80; server_name admin.xxx.com; root /data/web/xxx/backend/web; # 该项要修改为你准备存放相关网页的路径 location / &#123; index index.php index.html index.htm; #如果请求既不是一个文件，也不是一个目录，则执行一下重写规则 if (!-e $request_filename) &#123; #地址作为将参数rewrite到index.php上。 rewrite ^/(.*)$ /index.php/$1; #若是子目录则使用下面这句，将subdir改成目录名称即可。 #rewrite ^/subdir/(.*)$ /subdir/index.php/$1; &#125; #deny all; &#125; #proxy the php scripts to php-fpm location ~ \.php &#123; include fastcgi_params; ##pathinfo支持start #定义变量 $path_info ，用于存放pathinfo信息 set $path_info &quot;&quot;; #定义变量 $real_script_name，用于存放真实地址 set $real_script_name $fastcgi_script_name; #如果地址与引号内的正则表达式匹配 if ($fastcgi_script_name ~ &quot;^(.+?\.php)(/.+)$&quot;) &#123; #将文件地址赋值给变量 $real_script_name set $real_script_name $1; #将文件地址后的参数赋值给变量 $path_info set $path_info $2; &#125; #配置fastcgi的一些参数 fastcgi_param SCRIPT_FILENAME $document_root$real_script_name; fastcgi_param SCRIPT_NAME $real_script_name; fastcgi_param PATH_INFO $path_info; ###pathinfo支持end fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; &#125; location ^~ /data/runtime &#123; return 404; &#125; location ^~ /application &#123; return 404; &#125; location ^~ /simplewind &#123; return 404; &#125;&#125; 安装MySQL5.7.*安裝 安装mysql源 1# yum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm 安装mysql 1yum install mysql-community-server 安装mysql的开发包，以后会有用 1yum install mysql-community-devel 启动mysql 1service mysqld start 查看mysql启动状态 1234# service mysqld status出现pid证明启动成功 获取mysql默认生成的密码 12# grep &apos;temporary password&apos; /var/log/mysqld.log选中的就是密码。 换成自己的密码 1234567# mysql -uroot -pmysql&gt; set global validate_password_policy=0; # 默认是1，即MEDIUM，所以刚开始设置的密码必须符合长度，且必须含有数字，小写或大写字母，特殊字符。有时候，只是为了自己测试，不想密码设置得那么复杂，譬如说，我只想设置root的密码为123456。mysql&gt; set global validate_password_length=1; # validate_password_number_count指定了密码中数据的长度，validate_password_special_char_count指定了密码中特殊字符的长度，validate_password_mixed_case_count指定了密码中大小字母的长度。这些参数，默认值均为1，所以validate_password_length最小值为4，如果你显性指定validate_password_length的值小于4，尽管不会报错，但validate_password_length的值将设为4。mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;MyNewPasdfs4!&apos;;mysql&gt; quit;# mysql -uroot -p 编译安装php7.0.1安装 下载php7源码包 1# cd /root &amp; wget -O php7.tar.gz http://cn2.php.net/get/php-7.1.2.tar.gz/from/this/mirror 解压源码包 1# tar -xvf php7.tar.gz 进入目录 1# cd php-7.0.1 安装php依赖包 1# yum install libxml2 libxml2-devel openssl openssl-devel bzip2 bzip2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel gmp gmp-devel libmcrypt libmcrypt-devel readline readline-devel libxslt libxslt-devel 编译配置，这里如果上一步的某些依赖包没有安装好，就会遇到很多configure error，我们一一解决，安装上相关软件开发包就可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# ./configure \--prefix=/usr/local/php \--with-config-file-path=/etc \--enable-fpm \--with-fpm-user=www \--with-fpm-group=www \--enable-inline-optimization \--disable-debug \--disable-rpath \--enable-shared \--enable-soap \--with-libxml-dir \--with-xmlrpc \--with-openssl \--with-mcrypt \--with-mhash \--with-pcre-regex \--with-sqlite3 \--with-zlib \--enable-bcmath \--with-iconv \--with-bz2 \--enable-calendar \--with-curl \--with-cdb \--enable-dom \--enable-exif \--enable-fileinfo \--enable-filter \--with-pcre-dir \--enable-ftp \--with-gd \--with-openssl-dir \--with-jpeg-dir \--with-png-dir \--with-zlib-dir \--with-freetype-dir \--enable-gd-native-ttf \--enable-gd-jis-conv \--with-gettext \--with-gmp \--with-mhash \--enable-json \--enable-mbstring \--enable-mbregex \--enable-mbregex-backtrack \--with-libmbfl \--with-onig \--enable-pdo \--with-mysqli=mysqlnd \--with-pdo-mysql=mysqlnd \--with-zlib-dir \--with-pdo-sqlite \--with-readline \--enable-session \--enable-shmop \--enable-simplexml \--enable-sockets \--enable-sysvmsg \--enable-sysvsem \--enable-sysvshm \--enable-wddx \--with-libxml-dir \--with-xsl \--enable-zip \--enable-mysqlnd-compression-support \--with-pear \--enable-opcache 编译与安装 1# make &amp;&amp; make install 添加 PHP 命令到环境变量 123456789# vim /etc/profile在末尾加入PATH=$PATH:/usr/local/php/binexport PATH要使改动立即生效执行# source /etc/profile 查看环境变量 12# echo $PATH# php -v 配置 配置php-fpm 123456# cp php.ini-production /etc/php.ini# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf# cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf# cp sapi/fpm/init.d.php-fpm /etc/init.d/php-fpm# chmod +x /etc/init.d/php-fpm 启动php-fpm 1# /etc/init.d/php-fpm start 异常处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283configure error:1.configure: error: xml2-config not found. Please check your libxml2 installation.解决：# yum install libxml2 libxml2-devel&lt;/span&gt; 2.configure: error: Cannot find OpenSSL&apos;s &lt;evp.h&gt;解决：# yum install openssl openssl-devel&lt;/span&gt; 3.configure: error: Please reinstall the BZip2 distribution解决：# yum install bzip2 bzip2-devel&lt;/span&gt; 4.configure: error: Please reinstall the libcurl distribution - easy.h should be in &lt;curl-dir&gt;/include/curl/解决：# yum install libcurl libcurl-devel&lt;/span&gt; 5.If configure fails try --with-webp-dir=&lt;DIR&gt; configure: error: jpeglib.h not found. 解决：# yum install libjpeg libjpeg-devel&lt;/span&gt;6.If configure fails try --with-webp-dir=&lt;DIR&gt;checking for jpeg_read_header in -ljpeg... yesconfigure: error: png.h not found.解决：# yum install libpng libpng-devel&lt;/span&gt; 7.If configure fails try --with-webp-dir=&lt;DIR&gt;checking for jpeg_read_header in -ljpeg... yeschecking for png_write_image in -lpng... yesIf configure fails try --with-xpm-dir=&lt;DIR&gt;configure: error: freetype-config not found.解决：# yum install freetype freetype-devel&lt;/span&gt;8.configure: error: Unable to locate gmp.h解决：# yum install gmp gmp-devel&lt;/span&gt;9.configure: error: mcrypt.h not found. Please reinstall libmcrypt.解决：# yum install libmcrypt libmcrypt-devel10.configure: error: Please reinstall readline - I cannot find readline.h解决：# yum install readline readline-devel&lt;/span&gt;11.configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution解决：# yum install libxslt libxslt-devel&lt;/span&gt; 修改服务运行用户修改nginx的运行角色12345678910111213141516cd /etc/nginxsudo vi nginx.conf# 头部是这样user www-data;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;# 修改为user test;worker_processes auto;pid /run/nginx.pid;include /etc/nginx/modules-enabled/*.conf;#重启nginxsudo service nginx restart 修改php的运行角色1234567891011121314151617181920cd /etc/php/7.0/fpm/pool.d/sudo vi www.conf# 找到user = www-datagroup = www-data# 改为user = testgroup = testcd /run/php/ls -al# 这个目录下面有两个文件# php7.0-fpm.pid和php7.0-fpm.sock# 修改这两个文件的权限sudo chown test:test php7.0-fpm.pidsudo chown test:test php7.0-fpm.sock# 重启php-fpmsudo service php7-fpm restart test用户是杜撰出来的根据自己的当前用户修改 重启服务12service nginx restartservice php-fpm restart 配置服务开启启动开机自启动nginx，php-fpm（其他服务类似）centos 7以上是用Systemd进行系统初始化的，Systemd 是 Linux 系统中最新的初始化系统（init），它主要的设计目标是克服 sysvinit 固有的缺点，提高系统的启动速度。Systemd服务文件以.service结尾，比如现在要建立nginx为开机启动，如果用yum install命令安装的，yum命令会自动创建nginx.service文件，直接用命令systemcel enable nginx.service设置开机启动即可。1systemcel enable nginx.service 源码安装的手动建立nginx.service服务文件在系统服务目录里创建nginx.service文件vi /lib/systemd/system/nginx.service 写入以下内容（路径改成自己的）1234567891011[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/www/lnmp/nginx/sbin/nginx -c /www/lnmp/nginx/conf/nginx.confExecReload=/www/lnmp/nginx/sbin/nginx -s reloadExecStop=/www/lnmp/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target 在系统服务目录里创建php-fpm.service文件vi /lib/systemd/system/php-fpm.service 写入以下内容（路径改成自己的）123456789[Unit]Description=php-fpmAfter=network.target[Service]Type=forkingExecStart=/www/lnmp/php/sbin/php-fpmPrivateTmp=true[Install]WantedBy=multi-user.target Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type=forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp=True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3测试并加入开机自启先关闭nginx，php-fpm使用以下命令开启systemctl start nginx.service #如果服务是开启状态，使用此命令会启动失败。systemctl start php-fpm.service 开启成功，将服务加入开机自启12systemctl enable nginx.service #注意后面不能跟空格systemctl enable php-fpm.service 重启服务器，查看是否启动123shutdown -r now #重启systemctl list-units --type=service #查看运行的服务 其他命令123456systemctl start nginx.service #启动nginx服务systemctl enable nginx.service #设置开机自启动systemctl disable nginx.service #停止开机自启动systemctl status nginx.service #查看服务当前状态systemctl restart nginx.service #重新启动服务systemctl list-units --type=service #查看所有已启动的服务]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X下配置远程Linux 服务器SSH密钥认证自动登录]]></title>
    <url>%2F2017%2F20171223-1.html</url>
    <content type="text"><![CDATA[在本地机器创建公钥打开万能的终端，执行如下命令，无视一切输出，一路欢快地回车即可。 ssh-keygen -t rsa -C ‘your email@domain.com‘-t 指定密钥类型，默认即 rsa ，可以省略-C 设置注释文字，比如你的邮箱 将公钥复制到ssh服务器将前一步骤生成的公钥~/id_rsa.pub文件，复制到ssh服务器对应用户下的~/.ssh/authorized_keys文件,可以有多种方式，这里只介绍常用的三种。 [适用于osx系统]使用ssh-copy-id-for-OSX工具将公钥复制至ssh服务器 1234brew install ssh-copy-idssh-copy-id username@hostname #将username和hostname替换为你的ssh服务器用户名和IP当ssh服务器username用户目录下尚未有.ssh目录时使用此方式cat ~/.ssh/id_rsa.pub | ssh username@hostname &quot;mkdir ~/.ssh; cat &gt;&gt; ~/.ssh/authorized_keys&quot; 通用方式 1234scp ~/.ssh/id_rsa.pub username@hostname:~/ #将公钥文件复制至ssh服务器ssh username@hostname #使用用户名和密码方式登录至ssh服务器mkdir .ssh #若.ssh目录已存在，可省略此步cat id_rsa.pub &gt;&gt; .ssh/authorized_keys #将公钥文件id_rsa.pub文件内容追加到authorized_keys文件 快捷登录完成以上步骤后，即可使用以下命令直接登录ssh服务器，妈妈再也不用担心你记不住密码了 ssh username@hostname #将username替换为你的ssh服务器用户名，hostname替换为服务器的ip但是，每次仍然需要输入ssh username@hostname，仍算不上最优的解决方案，要是能实现一键登录或一条命令登录最好不过了，下面来看看都有那些解决方法 ssh本身也提供了一种快捷的方式来解决这个问题，往~/.ssh/config配置文件添加你的ssh服务器信息即可vim ~/.ssh/config #若没有该文件，直接新建即可添加文件内容格式如下： 12345Host alias #自定义别名 HostName hostname #替换为你的ssh服务器ip或domain Port port #ssh服务器端口，默认为22 User user #ssh服务器用户名 IdentityFile ~/.ssh/id_rsa #第一个步骤生成的公钥文件对应的私钥文件 保存文件退出后，即可使用别名登录ssh服务器 ssh alias #alias是你在~/.ssh/config文件配置的别名若有多个ssh账号需要配置，只要在~/.ssh/config空行再写即可，如下: 12345678910Host foo HostName 192.168.2.222 Port 22 User test IdentityFile ~/.ssh/id_rsaHost alias HostName hostname Port port User user 如果你本地终端使用的是zsh，那就太简单不过了，直接给zsh添加一条别名 123echo &quot;alias ssh-to-username=&apos;ssh username@hostname&apos;&quot; &gt;&gt; ~/.zshrc #将username和hostname替换为你的服务器信息source ~/.zshrc #重新加载更改后的zshrc文件ssh-to-username #使用别名，一条命令即可登录你的ssh服务器 如果你本地终端使用的是iterm2还可以添加Profile实现一键登录，具体步骤此处略过]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符串的gzip压缩与解压的整理]]></title>
    <url>%2F2017%2F20170722-1.html</url>
    <content type="text"><![CDATA[背景介绍因为一直在处理restful API，给移动端提供的数据需要考虑流量问题，优先考虑就是压缩现有的字符串，然后再考虑业务逻辑方面的减少流量。鉴于找这些资料也花了不少时间，所以整理了这篇文章，留作纪念。参考网址PHP与C#的压缩与解压http://www.oschina.net/question/2265205_181108http://my.oschina.net/linland/blog/217769?fromerr=Kf9b6ElQhttp://www.yiibai.com/sql/function.gzencode.html https://forums.xamarin.com/discussion/33607/using-system-io-compression-in-pcl =====================python的压缩与解压 http://outofmemory.cn/code-snippet/2030/Python-usage-gzip-pack-shujubaohttp://www.cnblogs.com/mmix2009/p/3221371.html http://blog.csdn.net/lxdcyh/article/details/4021476javascript的压缩与解压http://stackoverflow.com/questions/14620769/decompress-gzip-and-zlib-string-in-javascripthttp://nodeca.github.io/pako/ 代码具体实现PHP (&gt;=5.4) [php] view plain copy123456$srcString="1"; $srcCompress=base64_encode(gzencode($srcString,9)); echo strlen($srcCompress).'---压缩后字符串长度&lt;br/&gt;'; $newString=base64_decode($srcCompress); $newString=gzdecode($newString); echo $newString.'----解压后原字符串&lt;br/&gt;'; c#(建议还是考虑各个平台的，PCL版本下的见前面的网址，但是没调试通过) [csharp] view plain copy1234567891011121314151617181920212223242526272829303132using System.IO.Compression; using System.Text; public string Compress (string text) &#123; byte[] buffer = Encoding.UTF8.GetBytes (text); using (MemoryStream ms = new MemoryStream ()) &#123; GZipStream Compress = new GZipStream (ms, CompressionMode.Compress); Compress.Write (buffer, 0, buffer.Length); Compress.Close (); return Convert.ToBase64String (ms.ToArray ()); &#125; &#125; public string Decompress (string text) &#123; byte[] buffer = Convert.FromBase64String (text); using (MemoryStream tempMs = new MemoryStream ()) &#123; using (MemoryStream ms = new MemoryStream (buffer)) &#123; GZipStream Decompress = new GZipStream (ms, CompressionMode.Decompress); Decompress.CopyTo (tempMs); Decompress.Close (); return Encoding.UTF8.GetString (tempMs.ToArray ()); &#125; &#125; &#125; python[python] view plain copy12345678910111213141516171819#coding=utf-8 import base64 import StringIO,gzip def zipData( content): zbuf = StringIO.StringIO() zfile = gzip.GzipFile(mode='wb', compresslevel=9, fileobj=zbuf) zfile.write(content) zfile.close() return base64.b64encode(zbuf.getvalue()) def unzipData(content): compresseddata=base64.b64decode(content) compressedstream = StringIO.StringIO(compresseddata) gzipper = gzip.GzipFile(fileobj=compressedstream) data = gzipper.read() return data s=zipData("1") print s s1=unzipData(s) print s1 javascript[html] view plain copy1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="http://code.jquery.com/jquery-2.1.4.min.js"&gt;&lt;/script&gt; &lt;script src="https://raw.githubusercontent.com/nodeca/pako/master/dist/pako.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function gzip(string) &#123; var charData = string.split('').map(function(x)&#123;return x.charCodeAt(0);&#125;); var binData = new Uint8Array(charData); var data= pako.gzip(binData); var strData= String.fromCharCode.apply(null, new Uint16Array(data)); return btoa(strData); &#125; function ungzip(string) &#123; var strData = atob(string); var charData = strData.split('').map(function(x)&#123;return x.charCodeAt(0);&#125;); var binData = new Uint8Array(charData); var data= pako.ungzip(binData); var strData= String.fromCharCode.apply(null, new Uint16Array(data)); return strData; &#125; test="1"; var s=gzip(test); alert(s); alert(ungzip(s)); &lt;/script&gt; &lt;/head&gt; &lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于file_get_contents("php://input")]]></title>
    <url>%2F2017%2F20170721-1.html</url>
    <content type="text"><![CDATA[“php://input allows you to read raw POST data. It is a less memory intensive alternative to $HTTP_RAW_POST_DATA and does not need any special php.ini directives. php://input is not available with enctype=”multipart/form-data”. 翻译过来，是这样：“php://input可以读取没有处理过的POST数据。相较于$HTTP_RAW_POST_DATA而言，它给内存带来的压力较小，并且不需要特殊的php.ini设置。php://input不能用于enctype=multipart/form-data”找了一通资料，原来是这么回事： 1，Coentent-Type仅在取值为application/x-www-data-urlencoded和multipart/form-data两种情况下， PHP才会将http请求数据包中相应的数据填入全局变量$_POST 2，PHP不能识别的Content-Type类型的时候，会将http请求包中相应的数据填入变量$HTTP_RAW_POST_DATA 3, 只有Coentent-Type不为multipart/form-data的时候，PHP不会将http请求数据包中的相应数据填入php://input， 否则其它情况都会。填入的长度，由Coentent-Length指定。 4，只有Content-Type为application/x-www-data-urlencoded时，php://input数据才跟$_POST数据相一致。 5，php://input数据总是跟$HTTP_RAW_POST_DATA相同，但是php://input比$HTTP_RAW_POST_DATA更凑效， 且不需要特殊设置php.ini 6，PHP会将PATH字段的query_path部分，填入全局变量$_GET。通常情况下，GET方法提交的http请求，body为空。 从官网信息来看，php://input是一个只读信息流，当请求方式是post的，并且enctype不等于”multipart/form-data”时，可以使用php://input来获取原始请求的数据。 看一个简单的例子。 客户端就是一个表单，非常简单。 123456789&lt;form action="" method="POST"&gt; name: &lt;input type="text" name="name" value="tom" /&gt;&lt;br /&gt; age:&lt;input type="text" name="age" value="22" /&gt;&lt;br /&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt; 将表单提交到服务端，服务端使用file_get_contents获取php://input内容 123$content = file_get_contents("php://input");echo $content; //输出name=tom&amp;amp;age=22 官网关于php://input的说明中，反复有提到$HTTP_RAW_POST_DATA这个变量，这个变量其实和file_get_contents(php://input)的内容是一样的。如果要开启这个变量，需要修改配置文件，找到always_populate_raw_post_data这个选项，设置为On，然后重新启动web服务器，就可以了。而使用php://input不需要修改php配置文件。 在项目应用中，如摄像头拍照，上传保存，就可以用到php://input。客户端拍照后，把图片流传送到服务端，服务端使用file_get_getcontents(‘php://input’)就能获取到图片流，然后把图片流保存到一个文件，这个文件就是图片了]]></content>
  </entry>
  <entry>
    <title><![CDATA[gitbook安装与使用]]></title>
    <url>%2F2017%2F20170719-1.html</url>
    <content type="text"><![CDATA[gitbook安装 安装npm从网站 https://nodejs.org/#download 下载node.js源代码（点击绿色的INSTALL），解压./configuremakemake install成功执行后，npm就被安装好了。 gitbook 安装npm install -g gitbook-cligitbook -V查看gitbook是否安装成功。 gitbook使用 根据目录生成图书结构 1.1 README.md 与 SUMMARY编写README.md这个文件相当于一本Gitbook的简介。12$ mkdir test_gitbook$ touch README.md SUMMARY.md这个文件是一本书的目录结构，使用Markdown语法，如我们这本书的SUMMARY.md：12$ touch SUMMARY.md$ vim SUMMARY.md 输入 12345678* [简介](README.md)* [第一章](chapter1/README.md) - [第一节](chapter1/section1.md) - [第二节](chapter1/section2.md)* [第二章](chapter2/README.md) - [第一节](chapter2/section1.md) - [第二节](chapter2/section2.md)* [结束](end/README.md) 1.2 生成图书结构当这个目录文件创建好之后，我们可以使用Gitbook的命令行工具将这个目录结构生成相应的目录及文件：$ gitbook init$ tree . #查看建立的目录和文件.├── chapter1│ ├── README.md│ ├── section1.md│ └── section2.md├── chapter2│ ├── README.md│ ├── section1.md│ └── section2.md├── end│ └── README.md├── README.md└── SUMMARY.md 我们可以看到，gitbook给我们生成了与SUMMARY.md所对应的目录及文件。 每个目录中，都有一个README.md文件，相当于一章的说明。 生成图书 2.1 输出为静态网站你有两种方式输出一个静态网站：2.1.1 本地预览时自动生成当你在自己的电脑上编辑好图书之后，你可以使用Gitbook的命令行进行本地预览： $ gitbook serve 然后浏览器中输入 http://localhost:4000 就可以预览生成的以网页形式组织的书籍。这里你会发现，你在你的图书项目的目录中多了一个名为_book的文件目录，而这个目录中的文件，即是生成的静态网站内容。使用build参数生成到指定目录与直接预览生成的静态网站文件不一样的是，使用这个命令，你可以将内容输入到你所想要的目录中去：12$ mkdir /tmp/gitbook$ gitbook build --output=/tmp/gitbook 2.2 输出PDF输入为PDF文件，需要先使用NPM安装上gitbook pdf：$ sudo npm install gitbook-pdf -g我在执行上面这条命令的时候出现了下面的错误：12345678910111213141516171819202122232425262728293031***************************************************Downloading http://cdn.bitbucket.org/ariya/phantomjs/downloads/phantomjs-1.9.7-linux-i686.tar.bz2Saving to /usr/local/lib/node_modules/gitbook-pdf/node_modules/phantomjs/phantomjs/phantomjs-1.9.7-linux-i686.tar.bz2Error: connect ETIMEDOUT at exports._errnoException (util.js:746:11) at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1010:19)npm ERR! Linux 3.2.0-4-686-paenpm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;gitbook-pdf&quot; &quot;-g&quot;npm ERR! node v0.12.7npm ERR! npm v2.11.3npm ERR! code ELIFECYCLEnpm ERR! phantomjs@1.9.7-5 install: `node install.js`npm ERR! Exit status 1npm ERR! npm ERR! Failed at the phantomjs@1.9.7-5 install script &apos;node install.js&apos;.npm ERR! This is most likely a problem with the phantomjs package,npm ERR! not with npm itself.npm ERR! Tell the author that this fails on your system:npm ERR! node install.jsnpm ERR! You can get their info via:npm ERR! npm owner ls phantomjsnpm ERR! There is likely additional logging output above.npm ERR! Please include the following file with any support request:npm ERR! /home/wangxq/repository/phantomjs/npm-debug.log*************************************************** 由错误报告内容的第一行可以知道，发生错误的原因是下载phantomjs发生了错误，因此我们需要手动下载和安装。 解决方法：[1]123456789$ git clone git://github.com/ariya/phantomjs.git$ sudo apt-get install build-essential g++ flex bison gperf ruby perl \ libsqlite3-dev libfontconfig1-dev libicu-dev libfreetype6 libssl-dev \ libpng-dev libjpeg-dev python libx11-dev libxext-dev #安装编译需要的工具和依赖$ cd phantomjs$ git checkout 1.9.7 #注意：这里的1.9.7是phantom的版本号，可以由错误报告的第一行找出 $ ./build.sh --jobs 4$ sudo cp bin/phantomjs /bin/$ sudo npm install gitbook-pdf -g #重新进行安装 然后，使用下面的命令，要PDF文件，首先安装依赖库： 12$ sudo apt-get install calibre $ gitbook -v 2.1.0 pdf 发生错误：12345678910111213141516171819202122232425262728293031*****************************************************info: start conversion to pdf ....ERRORError: Command failed: /bin/sh -c ebook-convert /tmp/tmp-29384ctltwbk/SUMMARY.html /tmp/tmp-29384ctltwbk/index.pdf --title=&quot;&quot; --comments=&quot;这本书是gitbook的一个例子&quot; --language=&quot;en&quot; --book-producer=&quot;GitBook&quot; --publisher=&quot;GitBook&quot; --chapter=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter &apos;)]&quot; --chapter-mark=&quot;pagebreak&quot; --page-breaks-before=&quot;/&quot; --level1-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-1 &apos;)]&quot; --level2-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-2 &apos;)]&quot; --level3-toc=&quot;descendant-or-self::*[contains(concat(&apos; &apos;, normalize-space(@class), &apos; &apos;), &apos; book-chapter-3 &apos;)]&quot; --no-chapters-in-toc --max-levels=&quot;1&quot; --breadth-first --margin-left=&quot;62&quot; --margin-right=&quot;62&quot; --margin-top=&quot;56&quot; --margin-bottom=&quot;56&quot; --pdf-default-font-size=&quot;12&quot; --pdf-mono-font-size=&quot;12&quot; --paper-size=&quot;a4&quot; --pdf-header-template=&quot;&lt;p class=&apos;header&apos;&gt;&lt;span&gt;&lt;/span&gt;&lt;/p&gt;&quot; --pdf-footer-template=&quot;&lt;p class=&apos;footer&apos;&gt;&lt;span&gt;_SECTION_&lt;/span&gt; &lt;span style=&apos;float:right;&apos;&gt;_PAGENUM_&lt;/span&gt;&lt;/p&gt;&quot;Usage: ebook-convert input_file output_file [options]Convert an ebook from one format to another.input_file is the input and output_file is the output. Both must be specified as the first two arguments to the command.The output ebook format is guessed from the file extension of output_file. output_file can also be of the special format .EXT where EXT is the output file extension. In this case, the name of the output file is derived the name of the input file. Note that the filenames must not start with a hyphen. Finally, if output_file has no extension, then it is treated as a directory and an &quot;open ebook&quot; (OEB) consisting of HTML files is written to that directory. These files are the files that would normally have been passed to the output plugin.After specifying the input and output file you can customize the conversion by specifying various options. The available options depend on the input and output file types. To get help on them specify the input and output file and then use the -h option.For full documentation of the conversion system seehttp://manual.calibre-ebook.com/conversion.htmlWhenever you pass arguments to ebook-convert that have spaces in them, enclose the arguments in quotation marks.ebook-convert: error: no such option: --pdf-default-font-size***************************************************** 解决方法[2]1234$ sudo -v &amp;&amp; wget -nv -O- https://raw.githubusercontent.com/kovidgoyal/calibre/master/setup/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\n&apos;); exec(sys.stdin.read()); main()&quot;$ gitbook -v 2.1.0 pdf . # 重新执行命令生成pdf，目标文件为book.pdf https://github.com/zhangjikai/gitbook-use/]]></content>
  </entry>
  <entry>
    <title><![CDATA[绊脚石]]></title>
    <url>%2F2017%2F20170410-1.html</url>
    <content type="text"><![CDATA[今天发布了这样一条朋友圈： 有时候，一些不是特别良好的状态产生时，都会有一种体验特别不舒服的忧虑感。大多数这种情况的产生最终还是会产生正面的结果。因为在敢于承担的过程，在问题解决以后会觉得某些地方有些提升。所以今天的忧虑都是靠这个说服自己。 这段话引起了朋友进一步追问的兴趣，我凯凯而回，说只是装X的东西。自己又想表达的一个观点是，老罗说他创业五年很多失败的经历是成长过程宝贵的财富。自己有意去挖掘一些这样的失败案例。到不为自己所为的成功，但却有成长的必要。 想到这里，突然想到，学生时代看过的一些求职面试宝典，说面试官可能会问你之前的工作生活中，遇到的最大的空难是什么，你是如何解决的。虽然，以后可能找工作的次数不会太多。但好像此刻对这个问题，有了比较豁然的想法：又要重复那段话了。战胜的最大困难，就是心理斗争的过程，多数的时候由于不好的状态产生时，这种心理上的阴影是最大困难的产生，我有及其良好的态度能说服自己承担下来，战胜它。最后会凯凯而笑，自己又成长了。 这样的素材，希望能够不断的积累，可能有这些，会让自己的人生道路变得充实一些吧。 说了好多也都在总结一些空话。素材只做点录：渠道产品逻辑调整，解决终极问题，虽有风险顾虑，却有勇气坚持自己的观点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vagrant打造开发环境]]></title>
    <url>%2F2017%2F20170405-1.html</url>
    <content type="text"><![CDATA[下载安装123456VirtualBox 5.1.8下载地址 https://www.virtualbox.org/wiki/Download_Old_Builds_5_1Vagrant 1.8.6下载地址：https://releases.hashicorp.com/vagrant/1.8.6/切记根据自己的操作系统下载，同时分32位和64位 vagrant常用命令 查看vagrant listuiste:box uiste$ vagrant box list 添加vagrant boxuiste:box uiste$ vagrant box add ubuntu1404 ubuntu1404.box 添加虚拟机 123uiste:local_lamp_dev uiste$ pwd/Users/uiste/vagrant/local_lamp_devuiste:local_lamp_dev uiste$ vagrant init ubuntu1404 启动虚拟机uiste:local_lamp_dev uiste$ vagrant up 取得链接 12uiste:local_lamp_dev uiste$ vagrant sshvagrant@vagrant-ubuntu-trusty-64:~$ 退出、挂起虚拟机 1234vagrant@vagrant-ubuntu-trusty-64:~$ exitlogoutConnection to 127.0.0.1 closed.uiste:local_lamp_dev uiste$ vagrant suspend 重启虚拟机 1uiste:local_lamp_dev uiste$ vagrant reload 对虚拟机进行优化 替换源123456789101112131415sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak #备份vagrant@vagrant-ubuntu-trusty-64:~$ sudo vim /etc/apt/sources.list #修改源deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversevagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get update #更新列表 L(A|N)MP软件安装 安装nginx 1234567891011121314vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install nginx -y// 安装成功测试vagrant@vagrant-ubuntu-trusty-64:~$ nginx -vnginx version: nginx/1.4.6 (Ubuntu)vagrant@vagrant-ubuntu-trusty-64:~$ curl -I &apos;http://127.0.0.1&apos;HTTP/1.1 200 OKServer: nginx/1.4.6 (Ubuntu)Date: Tue, 04 Apr 2017 17:17:02 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Tue, 04 Mar 2014 11:46:45 GMTConnection: keep-aliveETag: &quot;5315bd25-264&quot;Accept-Ranges: bytes 安装Apache 1234567891011121314151617181920212223242526272829vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install apache2 -y// 安装成功测试vagrant@vagrant-ubuntu-trusty-64:~$ apache2 -vServer version: Apache/2.4.7 (Ubuntu)// nginx 服务停止vagrant@vagrant-ubuntu-trusty-64:~$ sudo /etc/init.d/nginx stop// 启动 apache2 服务vagrant@vagrant-ubuntu-trusty-64:~$ sudo /etc/init.d/apache2 start * Starting web server apache2 AH00558: apache2: Could not reliably determine the server&apos;s fully qualified domain name, using 10.0.2.15. Set the &apos;ServerName&apos; directive globally to suppress this message * vagrant@vagrant-ubuntu-trusty-64:~$ curl -I &apos;http://127.0.0.1&apos;HTTP/1.1 200 OKDate: Tue, 04 Apr 2017 17:24:09 GMTServer: Apache/2.4.7 (Ubuntu)Last-Modified: Tue, 04 Apr 2017 17:18:42 GMTETag: &quot;2cf6-54c5a77b221fa&quot;Accept-Ranges: bytesContent-Length: 11510Vary: Accept-EncodingContent-Type: text/html#端口修改-Apachevagrant@vagrant-ubuntu-trusty-64:~$ sudo vim /etc/apache2/ports.confListen 8888vagrant@vagrant-ubuntu-trusty-64:~$ sudo /etc/init.d/apache2 restart#端口修改-Nginx#修改成9000端口 ，默认sock模式cd /etc/php5/fpm/pool.dsudo vim www.conf # search listen = 127.0.0.1:9000sudo /etc/init.d/php5-fpm restart 安装MySQL软件 12345678#服务器端vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install mysql-server安装期间会提示输入为mysql设置root密码，我这边不操作，直接enter 不设置密码#客户端vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install mysql-client#测试连接库，上面安装服务端没有设置密码，这里直接enter进入vagrant@vagrant-ubuntu-trusty-64:~$ mysql -uroot -pEnter password: 安装PHP 12345678910111213#安装phpvagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install php5-cli -y#安装成功测试vagrant@vagrant-ubuntu-trusty-64:~$ php -vPHP 5.5.9-1ubuntu4.21 (cli) (built: Feb 9 2017 20:54:58)#安装php扩展vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install php5-mcrypt php5-mysql php5-gd -y#支持apache2的php模块vagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install libapache2-mod-php5#支持nginx fastcgi 启动phpvagrant@vagrant-ubuntu-trusty-64:~$ sudo apt-get install php5-cgi php5-fpm#开发Apache文件.htaccess重写功能vagrant@vagrant-ubuntu-trusty-64:/$ sudo a2enmod rewrite 安装git 1vagrant@vagrant-ubuntu-trusty-64:/home/www/code$ sudo apt-get install git -y Vagrant高级配置 端口转发 12345678配置 config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8888 config.vm.network &quot;forwarded_port&quot;, guest: 8888, host: 8889测试效果http://127.0.0.1:8888/http://127.0.0.1:8889/ 网络设置 1234567配置config.vm.network &quot;private_network&quot;, ip: &quot;192.168.199.101&quot;效果http://192.168.199.101/ 或者 http://192.168.199.101:80/http://192.168.199.101:8888/ *共享目录123配置config.vm.synced_folder &quot;/Users/uiste/www/code/&quot;, &quot;/home/www&quot; 框架配置tp5123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354git clone https://github.com/top-think/think tp5然后切换到tp5目录下面，再克隆核心框架仓库：cd tp5 &amp;&amp; git clone https://github.com/top-think/framework thinkphpnginx 配置server &#123; server_name tp5.code.com; root /home/www/code/tp5/public; index index.php index.html; location / &#123; if ( -f $request_filename) &#123; break; &#125; if ( !-e $request_filename) &#123; rewrite ^/(.*)$ /index.php/$1 last; break; &#125; &#125; location ~ \.php &#123; set $script $uri; set $path_info &quot;&quot;; if ($uri ~ &quot;^(.+\.php)(/.+)&quot;) &#123; set $script $1; set $path_info $2; &#125; include fastcgi_params; fastcgi_index index.php?IF_REWRITE=1; fastcgi_pass 127.0.0.1:9000; fastcgi_param PATH_INFO $path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param SCRIPT_NAME $script; try_files $uri =404; &#125; &#125;针对fasecgi要配置下php-fpmvim /etc/php5/fpm/pool.d/www.conf;listen = /var/run/php5-fpm.socklisten = 127.0.0.1:9000无法查看日志 sudo chmod -R 755 /var/log/nginxapache 配置 &lt;VirtualHost *:8888&gt; ServerName tp5.imooc.test DocumentRoot /home/www/code/tp5/public/ ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined &lt;/VirtualHost&gt;无法查看日志sudo chmod -R 755 /var/log/apache2Forbidden解决办法cd /etc/apache2sudo vim apache2.conf &lt;Directory /&gt; Options FollowSymLinks AllowOverride None #修改成AllowOverride ALL 打开rewrite #Require all denied #把这行屏蔽掉，拒绝一切链接 &lt;/Directory&gt;测试效果http://tp5.code.com 或者 http://tp5.code.com:8888做个测试页面 http://tp5.code.com/index/index/test 或者 http://tp5.code.com:8000/index/index/test yii2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960下载：github.com/yiisoft/yii2/releases/download/2.0.10/yii-basic-app-2.0.10.tgznginx 配置server &#123; charset utf-8; client_max_body_size 128M; listen 80; server_name yii.code.com; root /home/www/code/yii2/web; index index.php; location ~* \.(eot|otf|ttf|woff)$ &#123; add_header Access-Control-Allow-Origin *; &#125; location / &#123; try_files $uri $uri/ /index.php?$args; &#125; location ~ \.php$ &#123; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; try_files $uri =404; &#125;&#125;apache 配置 &lt;VirtualHost *:8888&gt; ServerName yii.code.com DocumentRoot /home/www/code/yii2/web #&lt;Directory &quot;/home/www/code/yii2/web&quot;&gt; #RewriteEngine on #RewriteCond %&#123;REQUEST_FILENAME&#125; !-f #RewriteCond %&#123;REQUEST_FILENAME&#125; !-d #RewriteRule . index.php #&lt;/Directory&gt; ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined &lt;/VirtualHost&gt;测试效果 * http://yii.code.com 或者 http://yii.code.com:8888 * 做个测试页面 http://yii.code.com/site/test 或者 http://yii.code.com:8000/site/test问题runtime/logs&quot;: mkdir(): Permission denied权限不够 chmod -R 777 runtime (如果在虚拟机不能修改文件权限，请使用nfs共享目录)yii\web\Request::cookieValidationKey must be configured with a secret key.config/web.php cookieValidationKey 赋值如果打不开 site/test ，请修改config/web.php 中urlManager 注释打开&apos;db&apos; =&gt; require(__DIR__ . &apos;/db.php&apos;),&apos;urlManager&apos; =&gt; [ &apos;enablePrettyUrl&apos; =&gt; true, &apos;showScriptName&apos; =&gt; false, &apos;rules&apos; =&gt; [ ],],yii2/web/.htaccessRewriteEngine on#If a directory or a file exists, use it directlyRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-d#Otherwise forward it to index.phpRewriteRule . index.php laravel51234567891011121314151617181920212223242526272829303132333435下载： down.golaravel.com/laravel/laravel-v5.1.11.zipnginx 配置server &#123; charset utf-8; client_max_body_size 128M; listen 80; server_name laravel.code.com; root /home/www/code/laravel/public; index index.php; location ~* \.(eot|otf|ttf|woff)$ &#123; add_header Access-Control-Allow-Origin *; &#125; location / &#123; try_files $uri $uri/ /index.php?$args; &#125; location ~ \.php$ &#123; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; try_files $uri =404; &#125;&#125;apache 配置 &lt;VirtualHost *:8888&gt; ServerName laravel.code.com DocumentRoot /home/www/code/laravel/public/ ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined &lt;/VirtualHost&gt;测试效果http://laravel.code.com 或者 http://laravel.code.com:8888 vagrant虚拟机配置虚拟机名称vb.name = &quot;ubuntu_code&quot;虚拟机主机名config.vm.hostname = &quot;code&quot;配置虚拟机内存和CPUvb.memory = &quot;1024&quot;vb.cpus = 2 打包命令vagrant package --output uiste.box 打包升级 123456789config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2apt-get insatll -y redis-serverSHELL#执行安装命令vagrant reload --provisionuiste:box uiste$ vagrant box add new_uiste uiste.box]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thinkphp5中使用PHPExcel]]></title>
    <url>%2F2017%2F20170404-1.html</url>
    <content type="text"><![CDATA[安装 项目所在目录：uiste:tp5.0 uiste$ composer require phpexcel/phpexcel 简单上手 实例化对象$objPHPExcel = new \PHPExcel(); 获取活动sheet，设置sheet名字 12$objSheet = $objPHPExcel-&gt;getActiveSheet(); $objSheet -&gt;setTitle(&quot;demo&quot;);//可以给sheet设置名称为&quot;demo&quot; 然后就是在表格中写入数据 123456789101112//数据量大的时候使用第一种方法$objSheet-&gt;setCellValue(&quot;A1&quot;,&quot;姓名&quot;)-&gt;setCellValue(&quot;B1&quot;,&quot;分数&quot;); $objSheet-&gt;setCellValue(&quot;A2&quot;,&quot;张三&quot;)-&gt;setCellValue(&quot;B2&quot;,&quot;100&quot;); //数据量小的时候使用第二种方法$array = array( array(), array(&apos;姓名&apos;,&apos;分数&apos;), array(&apos;张三&apos;,&apos;60&apos;), array(&apos;李四&apos;,&apos;61&apos;), array(&apos;王五&apos;,&apos;62&apos;), ); $objSheet -&gt; fromArray($array);//数据较大时，不建议使用此方法，建议使用setCellValue() 保存写入的数据 12$objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel, &apos;Excel2007&apos;);//生成一个Excel2007文件 $objWriter-&gt;save(&apos;/Users/uiste/www/tp5.0/public/test.xlsx&apos;);//保存文件 在浏览器上输出Excel12345678910111213141516171819202122232425262728293031323334353637383940414243$filename = &apos;student.xls&apos;;$type = &apos;Excel2007&apos;;$objPHPExcel = new \PHPExcel();for ($i=0; $i &lt;= 1; $i++) &#123; // 如果sheet大于0 则创建一个新的sheet if ($i&gt;0) &#123; $objPHPExcel-&gt;createSheet(); &#125; $objPHPExcel-&gt;setActiveSheetIndex($i);//把当前创建的sheet设置为活动sheet $objSheet = $objPHPExcel-&gt;getActiveSheet();//获得当前活动Sheet $objSheet-&gt;setTitle(&quot;student&quot; . $i); if($i==0)&#123; $student = Db::name(&apos;student&apos;)-&gt;where([&apos;sex&apos;=&gt;10])-&gt;select(); &#125;else&#123; $student = DB::name(&apos;student&apos;)-&gt;where(&apos;sex != 10&apos;)-&gt;select(); &#125; $objSheet-&gt;setCellValue(&apos;A1&apos;,&apos;序号&apos;) -&gt;setCellValue(&apos;B1&apos;,&apos;姓名&apos;) -&gt;setCellValue(&apos;C1&apos;,&apos;年龄&apos;) -&gt;setCellValue(&apos;D1&apos;,&apos;性别&apos;) -&gt;setCellValue(&apos;E1&apos;,&apos;创建时间&apos;) -&gt;setCellValue(&apos;F1&apos;,&apos;更新时间&apos;); $j = 2; // 从第二行开始写入 foreach ($student as $key =&gt; $value) &#123; $objSheet-&gt;setCellValue(&apos;A&apos;.$j,$value[&apos;id&apos;]) -&gt;setCellValue(&apos;B&apos;.$j,$value[&apos;name&apos;]) -&gt;setCellValue(&apos;C&apos;.$j,$value[&apos;age&apos;]) -&gt;setCellValue(&apos;D&apos;.$j,$value[&apos;sex&apos;]) -&gt;setCellValue(&apos;E&apos;.$j,$value[&apos;created_at&apos;]) -&gt;setCellValue(&apos;F&apos;.$j,$value[&apos;updated_at&apos;]); $j++; &#125; &#125;$objWriter = \PHPExcel_IOFactory::createWriter($objPHPExcel,&apos;Excel5&apos;);//生成excel文件//$objWriter-&gt;save($dir.&quot;/export_1.xls&quot;);//保存文件if($type==&quot;Excel5&quot;)&#123; header(&apos;Content-Type: application/vnd.ms-excel&apos;);//告诉浏览器将要输出excel03文件&#125;else&#123; header(&apos;Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&apos;);//告诉浏览器数据excel07文件&#125;header(&apos;Content-Disposition: attachment;filename=&quot;&apos;.$filename.&apos;&quot;&apos;);//告诉浏览器将输出文件的名称header(&apos;Cache-Control: max-age=0&apos;);//禁止缓存$objWriter-&gt;save(&quot;php://output&quot;); 读取指定Excel文件中的数据1234567891011121314151617181920212223242526272829303132header(&quot;Content-Type:text/html;charset=utf-8&quot;);$filename=ROOT_PATH . &apos;public&apos; . DS . &quot;test.xlsx&quot;; // 读取文件$sheetName=array(&quot;demo&quot;); //只加载指定的sheet$rowStart = 1; //指定开始读取的行数$fileType=\PHPExcel_IOFactory::identify($filename);//自动获取文件的类型提供给phpexcel用$objReader=\PHPExcel_IOFactory::createReader($fileType);//获取文件读取操作对象$objReader-&gt;setLoadSheetsOnly($sheetName);//只加载指定的sheet$objPHPExcel=$objReader-&gt;load($filename);//加载文件/* 数据量小的时候使用 *//**$sheetCount=$objPHPExcel-&gt;getSheetCount();//获取excel文件里有多少个sheetfor($i=0;$i&lt;$sheetCount;$i++)&#123; $data=$objPHPExcel-&gt;getSheet($i)-&gt;toArray();//读取每个sheet里的数据 全部放入到数组中 print_r($data);&#125;**//* 数据量大的时候使用 */foreach($objPHPExcel-&gt;getWorksheetIterator() as $sheet)&#123;//循环取sheet foreach($sheet-&gt;getRowIterator() as $row)&#123;//逐行处理 if($row-&gt;getRowIndex()&lt;$rowStart)&#123; continue; &#125; foreach($row-&gt;getCellIterator() as $cell)&#123;//逐列读取 $data=$cell-&gt;getValue();//获取单元格数据 echo $data.&quot; &quot;; &#125; echo &apos;&lt;br/&gt;&apos;; &#125; echo &apos;&lt;br/&gt;&apos;;&#125;exit; 小案例-POST发送读取文件数据发送到服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public function operate()&#123; $filename=ROOT_PATH . &apos;public&apos; . DS . &quot;test.xlsx&quot;; // 读取文件 $sheetName=array(&apos;工作表2&apos;); //只加载指定的sheet $rowStart = 1; //指定开始读取的行数 $url = &apos;http://www.test.com/history/study4/MVC_1/index.php?c=products&amp;a=add&apos;; $receive = [&apos;proname&apos;,&apos;proguige&apos;,&apos;proprice&apos;,&apos;proamount&apos;,&apos;proimages&apos;,&apos;proweb&apos;]; // 定义接收方的数据下标 // 第一步读取文件 if (!$data = $this-&gt;_fileRead($filename, $sheetName, $rowStart)) &#123; echo &apos;无法读取文件中的数据！！！&apos;; &#125; // dump($data);die; // 第二步发送数据请求 foreach ($data as $sheet) &#123; // 工作表 foreach ($sheet as $key1 =&gt; $rows) &#123; // 工作表行 if (count($rows) != count($receive)) &#123; echo &apos;表中数据列数与要发送的字段数不一致请核实！！！&apos;;die; &#125; $row = array(); foreach ($rows as $key =&gt; $cell) &#123; //单元格 $row[$receive[$key]] = $cell; &#125; if (!empty($row)) &#123; // $url = &quot;http://localhost/web_services.php&quot;; // $post_data = array (&quot;username&quot; =&gt; &quot;bob&quot;,&quot;key&quot; =&gt; &quot;12345&quot;); $post_data = $row; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);// post数据 curl_setopt($ch, CURLOPT_POST, 1);// post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); //打印获得的数据 if ($output) &#123; echo &apos;第 &apos; . $key1+1 . &apos; 行录入成功！！！&apos; . &apos;&lt;br/&gt;&apos;; &#125;else&#123; echo &apos;第 &apos; . $key1+1 . &apos; 行录入失败！！！&apos; . &apos;&lt;br/&gt;&apos;; &#125; &#125; &#125; &#125; echo &apos;录入完成 ， 哈哈哈&lt;br&gt;&apos;;&#125;public function _fileRead($filename, $sheetName = [&apos;sheet1&apos;], $rowStart = 1)&#123; header(&quot;Content-Type:text/html;charset=utf-8&quot;); $fileType=\PHPExcel_IOFactory::identify($filename);//自动获取文件的类型提供给phpexcel用 $objReader=\PHPExcel_IOFactory::createReader($fileType);//获取文件读取操作对象 $objReader-&gt;setLoadSheetsOnly($sheetName);//只加载指定的sheet $objPHPExcel=$objReader-&gt;load($filename);//加载文件 /* 数据量小的时候使用 */ $sheetCount=$objPHPExcel-&gt;getSheetCount();//获取excel文件里有多少个sheet $data = array(); for($i=0;$i&lt;$sheetCount;$i++)&#123; $data[$sheetName[$i]]=$objPHPExcel-&gt;getSheet($i)-&gt;toArray();//读取每个sheet里的数据 全部放入到数组中 &#125; return $data; /* 数据量大的时候使用 */ // $data = array(); // foreach($objPHPExcel-&gt;getWorksheetIterator() as $sheet)&#123;//循环取sheet // foreach($sheet-&gt;getRowIterator() as $row)&#123;//逐行处理 // if($row-&gt;getRowIndex()&lt;$rowStart)&#123; // continue; // &#125; // foreach($row-&gt;getCellIterator() as $cell)&#123;//逐列读取 // $data=$cell-&gt;getValue();//获取单元格数据 // echo $data.&quot; &quot;; // &#125; // echo &apos;&lt;br/&gt;&apos;; // &#125; // echo &apos;&lt;br/&gt;&apos;; // &#125; exit;&#125; 相关文章PHPExcel的使用]]></content>
      <tags>
        <tag>PHPExcel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7个高级技巧帮助你释放大量Mac OS X硬盘空间]]></title>
    <url>%2F2017%2F20170319-2.html</url>
    <content type="text"><![CDATA[硬盘空间用尽是一件很让人头疼的事情，尤其是MacBook Air等设备上的固态硬盘可用的储存空间很少。下面为大家介绍7个高级技巧来释放大量的硬盘空间，当然这些高级技巧更改了系统功能和文件，必须通过使用命令行实现，还需要使用rm或rf这样的危险命令，所以Mac OS X新手还是要谨慎尝试。 1：禁用SafeSleep休眠模式——能节省出4GB-16GB空间 Screen Shot 2013-05-11 at 3.57.34 AM.jpg 下面的命令可以关闭OS X原生的休眠功能，也就是SafeSleep。这种休眠模式当Mac休眠或者没电池时会将内存中的内容储存在硬盘上的sleepimage文件上。sleepimage文件与Mac电脑的内存一样大，这意味着如果你的内存是4GB，该文件就有4GB，如果是16GB，该文件就有16GB。关闭SafeSleep可以不让系统自动创建该文件，缺点就是当Mac电脑没电池时，你不能恢复到之前的状态。不过我们可以使用OS X的自动保存功能在电池将要耗尽的时候保存自己的工作。 如果想要禁用SafeSleep功能，我们需要在终端中输入下面的命令： sudo pmset -a hibernatemode 0 复制代码然后定位到/private/var/vm/删除已经存在的sleepimage文件 cd /private/var/vm/ 复制代码使用下面的命令删除该文件 sudo rm sleepimage 复制代码最后我们要防止OS X继续创建该文件，所以我们需要下面的命令生成一个无法被替换的空文件 touch sleepimagechmod 000 /private/var/vm/sleepimage 复制代码当然，如果你想要重新开启SafeSleep功能，只需下面的命令即可。 sudo pmset -a hibernatemode 3sudo rm /private/var/vm/sleepimage 复制代码 2：移除系统嗓音文件——可以节省出500MB-3GB+硬盘空间 Screen Shot 2013-05-11 at 3.56.52 AM.jpg 如果你不适用文字转语音功能，那么你肯定不会使用到OS X内置的嗓音文件。你可以删除这些文件重新获得硬盘空间。在终端应用中，使用下面的命令即可，首先定位到文件所在文件夹： cd /System/Library/Speech/ 复制代码然后执行删除命令，将所有嗓音文件删除 sudo rm -rf Voices/* 复制代码 如果你执行了命令，那么你将无法使用系统的文字转语音功能。 3：删除所有系统日志——可以节省出100MB-2GB硬盘空间 随着你使用Mac的时间越来越长，系统日志文件也会越来越多，根据电脑的用量、错误和服务，这些文件会越来越多。这些系统日志文件是用来调试和排除故障的，如果你感觉没有用，可以使用下面的命令删除： sudo rm -rf /private/var/log/* 复制代码 系统日志文件会不断的产生，所以你可以定时执行这条命令。 4：删除快速查看生成的缓存文件——可以节省出100MB-300MB硬盘空间 Screen Shot 2013-05-11 at 3.58.21 AM.jpg 快速查看功能是OS X系统内置的文件预览功能，在Finder中选择任何文件后都可以点击空格来查看文件的详情。不过快速查看功能依靠缓存功能才能更流畅，而且这些缓存文件会一直增加，通过下面的命令移除缓存： sudo rm -rf /private/var/folders/ 复制代码 5：删除Emacs——可以节省出60MB+的硬盘空间 如果你都不知道什么是Emacs，那么你可以放心的将其移除。Emacs是终端中的文本编辑器，如果你使用的固态硬盘空间实在太小，那么删除它就是不错的选择，况且你还可以使用vi和nano在终端中编辑文本。下面是删除Emacs的命令： sudo rm -rf /usr/share/emacs/ 复制代码 6：删除临时文件——可以节省500MB-5GB硬盘空间 /private/var/tmp/是存放系统缓存的文件夹，通常情况下会在系统重启时清楚，不过有时确不会。而且如果你长时间不关闭Mac，也不重启的话，缓存文件会越来越多。使用下面的命令清楚这些临时文件： cd /private/var/tmp/rm -rf TM* 复制代码 7：清除缓存文件——可以节省1GB-10GB硬盘空间 缓存文件有很多种，比如网页浏览记录，应用meta数据等等。这些缓存文件的容量究竟多大跟用户使用的应用有关，也与Mac重启的频率有关。此外，很多在线音乐播放app也会产生大量的缓存文件，我们可以通过下面的命令删除这些缓存文件： cd ~/Library/Caches/rm -rf ~/Library/Caches/* 复制代码 这里介绍的7个高级方法都需要使用终端才能实现，而且有的方法有些风险，所以请大家使用时注意！]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac如何查看隐藏文件夹？苹果mac显示隐藏文件夹方法和命令介绍]]></title>
    <url>%2F2017%2F20170319-1.html</url>
    <content type="text"><![CDATA[很多时候，无论是Windows还是Mac OS系统一些重要的文件夹和文件都是要被隐藏起来的，以防止用户因为误操作修改或者删除而导致系统或者软件的损坏。但是很多时候我们Mac用户，也需要修改隐藏的文件，才能实现一些操作。所以这个时候我们就需要将隐藏的文件或者文件夹显示出来。那么Mac系统怎么显示隐藏的文件夹和文件呢？或者说Mac显示隐藏文件好文件夹的命令是什么呢？命令方式最简单，键入如下两行命令你就可以实现对文件的现实和隐藏功能了。这个时候肯定会有童鞋问：“在哪里敲命令呢？”，Launchpad——其他——终端，打开之后就可以键入命令了。显示：defaults write com.apple.finder AppleShowAllFiles -bool true隐藏：defaults write com.apple.finder AppleShowAllFiles -bool false]]></content>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2.0 对数据库 查询的一些简单的操作]]></title>
    <url>%2F2017%2F20170226-1.html</url>
    <content type="text"><![CDATA[1： 此方法返回 [&#39;name&#39; =&gt; &#39;daxia&#39;] 的所有数据； User::find()-&gt;where([&#39;name&#39; =&gt; &#39;daxia&#39;])-&gt;all();2： 此方法返回 [&#39;name&#39; =&gt; &#39;daxia&#39;]的一条数据 User::find()-&gt;where([&#39;name&#39; =&gt; &#39;daxia&#39;])-&gt;one();3： 在条件name的基础上，额外添加另一个条件sex User::find()-&gt;where([&#39;name&#39; =&gt; &#39;daxia&#39;])-&gt;andWhere([&#39;sex&#39; =&gt; &#39;女&#39;])-&gt;one(); 或者： User::find()-&gt;where([&#39;name&#39; =&gt; &#39;daxia&#39;, &#39;sex&#39; =&gt; &#39;女&#39;])-&gt;one(); 说明： 这两种方法都是可以的4： andFilterWhere/andWhere应用： 在[1427925600-1427968800]之间查询 User::find()-&gt;andFilterWhere([&#39;between&#39;, &#39;regtime&#39;, &#39;1427925600&#39;, &#39;1427968800’])说到andFilterWhere，下面我把用到的各种的情况示例列出： 1) : sql: id=1 AND id=2 条件: [&#39;and&#39;, &#39;id=1&#39;, &#39;id=2&#39;] 2) : sql: id=1 OR id=2 条件: [&#39;or&#39;, &#39;id=1&#39;, &#39;id=2&#39;] 3) : sql: id BETWEEN 1 AND 10 条件: [&#39;between&#39;, &#39;id&#39;, 1, 10] 4) : sql: id IN (1, 2, 3) 条件: [&#39;in&#39;, &#39;id&#39;, [1, 2, 3]] 5) : sql: name LIKE ‘%tester%’ 模糊查询 条件: [&#39;like&#39;, &#39;name&#39;, &#39;tester&#39;] 6) : sql: age&gt;10 条件: [&#39;&gt;&#39;, &#39;age&#39;, 10] 5： orderBy() 应用 sql： ORDER BY id ASC, name DESC Yii对应的model书写如下：1234$query-&gt;orderBy([ &apos;id&apos; =&gt; SORT_ASC, 升序 默认 &apos;name&apos; =&gt; SORT_DESC, 降序]); 6： groupBy() 应用： sql: … GROUP BY id, status Yii对应的model书写如下： $query-&gt;groupBy([&#39;id&#39;, &#39;status&#39;]);7： having()应用： sql: … HAVING status = 1 Yii对应的model书写如下： $query-&gt;having([&#39;status&#39; =&gt; 1]);8： limit() offset() 应用： sql: … LIMIT 10 OFFSET 20 Yii对应的model书写如下 $query-&gt;limit(10)-&gt;offset(20);9： 用自己书写的sql语句，去查询符合的数据 User::findBySql(&#39;SELECT * FROM user&#39;)-&gt;one(); 此方法是用 sql 语句查询 user 表里面的一条数据； User::findBySql(&#39;SELECT * FROM user&#39;)-&gt;all(); 此方法是用 sql 语句查询 user 表里面的所有数据；说明： 测试 - 你也许想要测试或者使用一个由 yii\db\Query 对象创建的 SQL 语句。 你可以使用以下的代码来达到目的： $query-&gt;createCommand()-&gt;getRawSql();下面就是官网上面展示的，一些比较常见的查询方法：12345678yii\db\Query 提供了一整套的用于不同查询目的的方法。 ● yii\db\Query::all(): 将返回一个由行组成的数组，每一行是一个由名称和值构成的关联数组（译者注：省略键的数组称为索引数组）。 ● yii\db\Query::one(): 返回结果集的第一行。 ● yii\db\Query::column(): 返回结果集的第一列。 ● yii\db\Query::scalar(): 返回结果集的第一行第一列的标量值。 ● yii\db\Query::exists(): 返回一个表示该查询是否包结果集的值。 ● yii\db\Query::count(): 返回 COUNT 查询的结果。 ● 其它集合查询方法: 包括 yii\db\Query::sum(), yii\db\Query::average(), yii\db\Query::max(), yii\db\Query::min() 等. $q 是一个必选参数， 既可以是一个字段名称，又可以是一个 DB 表达式。]]></content>
      <tags>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阶段性搬砖总结]]></title>
    <url>%2F2017%2F20170225-1.html</url>
    <content type="text"><![CDATA[原因因为最近工作的原因,断了学习成长的一个节奏，想着还是做个记录。虽然暂更博客内容的时间不长，却在这短暂的时间有所迷失了自己的方向，麻木的生活，重复的工作，好像一把机械性的操手。沉浸与思考之后，又自我感觉忧虑。 也许一辈子都不能做成什么大事，还是希望能做好这一件小事。 以后静心学习，慢一点，稳一点，走好脚下的路…]]></content>
  </entry>
  <entry>
    <title><![CDATA[Html Body 莫名加上'MacOSX ATTRV'原因及解决]]></title>
    <url>%2F2016%2F20161113-1.html</url>
    <content type="text"><![CDATA[前言 今天上传项目时是由Mac tar打包上传到Linux服务器解包的，部署完成后访问页面发现页面的Body之前都被加入了 一行奇怪的字符。 Mac环境解决方案 Google后发现Mac解决方案 xattr -r -d com.apple.quarantine file-path原文地址http://entropytc.com/got-com-apple-quarantine-problems/ 不过在Linux下没有xattr命令，就去Linux目录下ls -a发现每个文件都被克隆了一个.开头的文件，由于检查过原始文件并未遭到改动，果然删除这些.开头文件即解决了问题 Linux解决方案 - 批量删除._开头文件 find ./ -name &quot;._*&quot; -exec rm -f {} \;]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 Group by 之内(前)实现 Order by 排序]]></title>
    <url>%2F2016%2F20161015-1.html</url>
    <content type="text"><![CDATA[发现问题统计功能需求时，比如统计某 APP 在一小时内最后一笔交易的时间点，测试后发现数据实为该小时内的第一笔交易。 SQL 语句示例 1234567SELECT appid, created_timeFROM orderWHERE paid = 1 AND created_time &gt;= &apos;2016-01-26 17:00:00&apos; AND created_time &lt; &apos;2016-01-26 18:00:00&apos;GROUP BY appidORDER BY created_time DESC; 执行后发现实际 ORDER BY created_time DESC 仅是在 GROUP BY 外排序，而没有满足需求在 GROUP BY 内排序。 解决问题方法一、使用 MAX 函数 SQL 语句示例 123456SELECT appid, created_time, MAX(created_time) AS latest_created_timeFROM orderWHERE paid = 1 AND created_time &gt;= &apos;2016-01-26 17:00:00&apos; AND created_time &lt; &apos;2016-01-26 18:00:00&apos;GROUP BY appid; 其中 created_time 为该小时内第一笔交易，latest_created_time 为该小时内最后一笔交易 优点: 使用简单，逻辑清楚缺点: 全表排，效率低，大数据量慎用 方法二、使用子查询 SQL 语句示例 123456789101112131415SELECT appid, created_time, latest_created_time FROM ( SELECT appid, created_time FROM order WHERE paid = 1 AND created_time &gt;= &apos;2016-01-26 17:00:00&apos; AND created_time &lt; &apos;2016-01-26 18:00:00&apos; ORDER BY created_time ASC ) AS temp_table_a , ( SELECT created_time AS latest_created_time FROM order WHERE paid = 1 AND created_time &gt;= &apos;2016-01-26 17:00:00&apos; AND created_time &lt; &apos;2016-01-26 18:00:00&apos; ORDER BY created_time DESC ) AS temp_table_bGROUP BY appid; 同上，其中 created_time 为该小时内第一笔交易，latest_created_time 为该小时内最后一笔交易 优点: 效率高，适用大数据量缺点: 语句较复杂，需要脱离框架，手动拼接实现 总结 不必纠结了，数据量小于200万就使用第一种方法吧，反之使用第二种。]]></content>
  </entry>
  <entry>
    <title><![CDATA[连接SSH时出现UNPROTECTED PRIVATE KEY FILE]]></title>
    <url>%2F2016%2F20161010-1.html</url>
    <content type="text"><![CDATA[原因 使用密钥连接 SSH 时提示 WARNING: UNPROTECTED PRIVATE KEY FILE，找到原因是由于之前重新配置了 ~/.ssh 目录权限，导致密钥能够通过其他用户访问。所以将密钥或者 .ssh 目录权限设置为仅当前用户具有访问权限即可解决。若提示 Bad owner or permissions, 也可以通过下述方案解决。 解决方案 sudo chown -R uiste:staff .sshsudo chmod -R 700 .ssh]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP开发安全问题总结]]></title>
    <url>%2F2016%2F20160523-2.html</url>
    <content type="text"><![CDATA[安全保护一般性要点不相信表单对于一般的Javascript前台验证，由于无法得知用户的行为，例如关闭了浏览器的javascript引擎，这样通过POST恶意数据到服务器。需要在服务器端进行验证，对每个php脚本验证传递到的数据，防止XSS攻击和SQL注入 不相信用户要假设你的网站接收的每一条数据都是存在恶意代码的，存在隐藏的威胁，要对每一条数据都进行清理 关闭全局变量在php.ini文件中进行以下配置： register_globals = Off如果这个配置选项打开之后，会出现很大的安全隐患。例如有一个process.php的脚本文件，会将接收到的数据插入到数据库，接收用户输入数据的表单可能如下： &lt;input name=&quot;username&quot; type=&quot;text&quot; size=&quot;15&quot; maxlength=&quot;64&quot;&gt;这样，当提交数据到process.php之后，php会注册一个$username变量，将这个变量数据提交到process.php，同时对于任何POST或GET请求参数，都会设置这样的变量。如果不是显示进行初始化那么就会出现下面的问题：123456&lt;?php// Define $authorized = true only if user is authenticatedif (authenticated_user()) &#123; $authorized = true;&#125;?&gt; 此处，假设authenticated_user函数就是判断$authorized变量的值，如果开启了register_globals配置，那么任何用户都可以发送一个请求，来设置$authorized变量的值为任意值从而就能绕过这个验证。 所有的这些提交数据都应该通过PHP预定义内置的全局数组来获取，包括$_POST、$_GET、$_FILES、$_SERVER、$_REQUEST等，其中$_REQUEST是一个$_GET/$_POST/$_COOKIE三个数组的联合变量，默认的顺序是$_COOKIE、$_POST、$_GET。 推荐的安全配置选项error_reporting设置为Off：不要暴露错误信息给用户，开发的时候可以设置为ON safe_mode设置为Off register_globals设置为Off 将以下函数禁用：system、exec、passthru、shell_exec、proc_open、popen open_basedir设置为 /tmp ，这样可以让session信息有存储权限，同时设置单独的网站根目录 expose_php设置为Off allow_url_fopen设置为Off allow_url_include设置为Off SQL注入攻击对于操作数据库的SQL语句，需要特别注意安全性，因为用户可能输入特定语句使得原有的SQL语句改变了功能。类似下面的例子： $sql = &quot;select * from pinfo where product = &#39;$product&#39;&quot;;此时如果用户输入的$product参数为： 39&#39;; DROP pinfo; SELECT &#39;FOO那么最终SQL语句就变成了如下的样子： select product from pinfo where product = &#39;39&#39;; DROP pinfo; SELECT &#39;FOO&#39;这样就会变成三条SQL语句，会造成pinfo表被删除，这样会造成严重的后果。 这个问题可以简单的使用PHP的内置函数解决： $sql = &#39;Select * from pinfo where product = &#39;&quot;&#39; mysql_real_escape_string($product) . &#39;&quot;&#39;;防止SQL注入攻击需要做好两件事： 对输入的参数总是进行类型验证 对单引号、双引号、反引号等特殊字符总是使用mysql_real_escape_string函数进行转义 但是，这里根据开发经验，不要开启php的Magic Quotes，这个特性在php6中已经废除，总是自己在需要的时候进行转义。 防止基本的XSS攻击XSS攻击不像其他攻击，这种攻击在客户端进行，最基本的XSS工具就是防止一段javascript脚本在用户待提交的表单页面，将用户提交的数据和cookie偷取过来。 XSS工具比SQL注入更加难以防护，各大公司网站都被XSS攻击过，虽然这种攻击与php语言无关，但可以使用php来筛选用户数据达到保护用户数据的目的，这里主要使用的是对用户的数据进行过滤，一般过滤掉HTML标签，特别是a标签。下面是一个普通的过滤方法：12345678910111213141516function transform_HTML($string, $length = null) &#123;// Helps prevent XSS attacks // Remove dead space. $string = trim($string); // Prevent potential Unicode codec problems. $string = utf8_decode($string); // HTMLize HTML-specific characters. $string = htmlentities($string, ENT_NOQUOTES); $string = str_replace(&quot;#&quot;, &quot;#&quot;, $string); $string = str_replace(&quot;%&quot;, &quot;%&quot;, $string); $length = intval($length); if ($length &gt; 0) &#123; $string = substr($string, 0, $length); &#125; return $string;&#125; 这个函数将HTML的特殊字符转换为了HTML实体，浏览器在渲染这段文本的时候以纯文本形式显示。如bold会被显示为： &lt;STRONG&gt;BoldText&lt;/STRONG&gt; 上述函数的核心就是htmlentities函数，这个函数将html特殊标签转换为html实体字符，这样可以过滤大部分的XSS攻击。 但是对于有经验的XSS攻击者，有更加巧妙的办法进行攻击：将他们的恶意代码使用十六进制或者utf-8编码，而不是普通的ASCII文本，例如可以使用下面的方式进行： &lt;a href=&quot;http://host/a.php?variable=%22%3e %3c%53%43%52%49%50%54%3e%44%6f%73%6f%6d%65%74%68%69%6e%67%6d%61%6c%69%63%69%6f%75%73%3c%2f%53%43%52%49%50%54%3e&quot;&gt;这样浏览器渲染的结果其实是： &lt;a href=&quot;http://host/a.php?variable=&quot;&gt; &lt;SCRIPT&gt;Dosomethingmalicious&lt;/SCRIPT&gt;这样就达到了攻击的目的。为了防止这种情况，需要在transform_HTML函数的基础上再将#和%转换为他们对应的实体符号，同时加上了$length参数来限制提交的数据的最大长度。 使用SafeHTML防止XSS攻击上述关于XSS攻击的防护非常简单，但是不包含用户的所有标记，同时有上百种绕过过滤函数提交javascript代码的方法，也没有办法能完全阻止这个情况。 目前，没有一个单一的脚本能保证不被攻击突破，但是总有相对来说防护程度更好的。一共有两个安全防护的方式：白名单和黑名单。其中白名单更加简单和有效。 一种白名单解决方案就是SafeHTML，它足够智能能够识别有效的HTML，然后就可以去除任何危险的标签。这个需要基于HTMLSax包来进行解析。 安装使用SafeHTML的方法： 1、前往http://pixel-apes.com/safehtml/?page=safehtml 下载最新的SafeHTML 2、将文件放入服务器的classes 目录，这个目录包含所有的SafeHTML和HTMLSax库 3、在自己的脚本中包含SafeHTML类文件 4、建立一个SafeHTML对象 5、使用parse方法进行过滤123456789101112131415&lt;?php/* If you&apos;re storing the HTMLSax3.php in the /classes directory, along with the safehtml.php script, define XML_HTMLSAX3 as a null string. */define(XML_HTMLSAX3, &apos;&apos;);// Include the class file.require_once(&apos;classes/safehtml.php&apos;);// Define some sample bad code.$data = &quot;This data would raise an alert &lt;script&gt;alert(&apos;XSS Attack&apos;)&lt;/script&gt;&quot;;// Create a safehtml object.$safehtml = new safehtml();// Parse and sanitize the data.$safe_data = $safehtml-&gt;parse($data);// Display result.echo &apos;The sanitized data is &lt;br /&gt;&apos; . $safe_data;?&gt; SafeHTML并不能完全防止XSS攻击，只是一个相对复杂的脚本来检验的方式。 使用单向HASH加密方式来保护数据 单向hash加密保证对每个用户的密码都是唯一的，而且不能被破译的，只有最终用户知道密码，系统也是不知道原始密码的。这样的一个好处是在系统被攻击后攻击者也无法知道原始密码数据。 加密和Hash是不同的两个过程。与加密不同，Hash是无法被解密的，是单向的；同时两个不同的字符串可能会得到同一个hash值，并不能保证hash值的唯一性。 MD5函数处理过的hash值基本不能被破解，但是总是有可能性的，而且网上也有MD5的hash字典。 使用mcrypt加密数据 MD5 hash函数可以在可读的表单中显示数据，但是对于存储用户的信用卡信息的时候，需要进行加密处理后存储，并且需要之后进行解密。 最好的方法是使用mcrypt模块，这个模块包含了超过30中加密方式来保证只有加密者才能解密数据。123456789101112131415161718192021222324252627282930313233&lt;?php$data = &quot;Stuff you want encrypted&quot;;$key = &quot;Secret passphrase used to encrypt your data&quot;;$cipher = &quot;MCRYPT_SERPENT_256&quot;;$mode = &quot;MCRYPT_MODE_CBC&quot;;function encrypt($data, $key, $cipher, $mode) &#123;// Encrypt datareturn (string) base64_encode ( mcrypt_encrypt ( $cipher, substr(md5($key),0,mcrypt_get_key_size($cipher, $mode)), $data, $mode, substr(md5($key),0,mcrypt_get_block_size($cipher, $mode)) ) );&#125;function decrypt($data, $key, $cipher, $mode) &#123;// Decrypt data return (string) mcrypt_decrypt ( $cipher, substr(md5($key),0,mcrypt_get_key_size($cipher, $mode)), base64_decode($data), $mode, substr(md5($key),0,mcrypt_get_block_size($cipher, $mode)) );&#125;?&gt; mcrypt函数需要以下信息： 1、待加密数据 2、用来加密和解密数据的key 3、用户选择的加密数据的特定算法（cipher：如 MCRYPT_TWOFISH192,MCRYPT_SERPENT_256， MCRYPT_RC2, MCRYPT_DES, and MCRYPT_LOKI97） 4、用来加密的模式 5、加密的种子，用来起始加密过程的数据，是一个额外的二进制数据用来初始化加密算法 6、加密key和种子的长度，使用mcrypt_get_key_size函数和mcrypt_get_block_size函数可以获取 如果数据和key都被盗取，那么攻击者可以遍历ciphers寻找开行的方式即可，因此我们需要将加密的key进行MD5一次后保证安全性。同时由于mcrypt函数返回的加密数据是一个二进制数据，这样保存到数据库字段中会引起其他错误，使用了base64encode将这些数据转换为了十六进制数方便保存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP网站常见安全漏洞及防御方法]]></title>
    <url>%2F2016%2F20160523-1.html</url>
    <content type="text"><![CDATA[常见PHP网站安全漏洞对于PHP的漏洞，目前常见的漏洞有五种。分别是Session文件漏洞、SQL注入漏洞、脚本命令执行漏洞、全局变量漏洞和文件漏洞。这里分别对这些漏洞进行简要的介绍。 session文件漏洞Session攻击是黑客最常用到的攻击手段之一。当一个用户访问某一个网站时，为了免客户每进人一个页面都要输人账号和密码，PHP设置了Session和Cookie用于方便用户的使用和访向。 SQL注入漏洞在进行网站开发的时候，程序员由于对用户输人数据缺乏全面判断或者过滤不严导致服务器执行一些恶意信息，比如用户信息查询等。黑客可以根据恶意程序返回的结果获取相应的信息。这就是月行胃的SQL注入漏洞。 脚本执行漏洞脚本执行漏洞常见的原因是由于程序员在开发网站时对用户提交的URL参数过滤较少引起的，用户提交的URL可能包含恶意代码导致跨站脚本攻击。脚本执行漏洞在以前的PHP网站中经常存在，但是随着PHP版本的升级，这些间题已经减少或者不存在了。 全局变量漏洞PHP中的变量在使用的时候不像其他开发语言那样需要事先声明，PHP中的变量可以不经声明就直接使用，使用的时候系统自动创建，而且也不需要对变量类型进行说明，系统会自动根据上下文环境自动确定变量类型。这种方式可以大大减少程序员编程中出错的概率，使用起来非常的方便。 文件漏洞文件漏洞通常是由于网站开发者在进行网站设计时对外部提供的数据缺乏充分的过滤导致黑客利用其中的漏洞在Web进程上执行相应的命令。假如在lsm.php中包含这样一段代码:include($b.”/aaa.php”.)，这对黑客来说，可以通过变量$b来实现远程攻击，可以是黑客自已的代码，用来实现对网站的攻击。可以向服务器提交a.php include=http://lZ7.0.0. 1/b.php,然后执行b.php的指令。 PHP常见漏洞的防范措施对于Session漏洞的防范从前面的分析可以知道，Session攻击最常见的就是会话劫持，也就是黑客通过各种攻击手段获取用户的Session ID，然后利用被攻击用户的身份来登录相应网站。为此，这里可以用以下几种方法进行防范:一是定期更换Session ID，更换Session ID可以用PHP自带函数来实现;二是更换Session名称，通常情况下Session的默认名称是PHPSESSID，这个变量一般是在cookie中保存的，如果更改了它的名称，就可以阻档黑客的部分攻击;三是对透明化的Session ID进行关闭处理，所谓透明化也就是指在http请求没有使用cookies来制定Session id时，Sessioin id使用链接来传递.关闭透明化Session ID可以通过操作PHP.ini文件来实现;四是通过URL传递隐藏参数，这样可以确保即使黑客获取了session数据，但是由于相关参数是隐藏的，它也很难获得Session ID变量值。 对SQL注入漏洞的防范黑客进行SQL注入手段很多，而且灵活多变，但是SQL注人的共同点就是利用输入过滤漏洞。因此，要想从根本上防止SQL注入，根本解决措施就是加强对请求命令尤其是查询请求命令的过滤。具体来说，包括以下几点:一是把过滤性语句进行参数化处理，也就是通过参数化语句实现用户信息的输入而不是直接把用户输入嵌入到语句中。二是在网站开发的时候尽可能少用解释性程序，黑客经常通过这种手段来执行非法命令;三是在网站开发时尽可能避免网站出现bug，否则黑客可能利用这些信息来攻击网站;仅仅通过防御SQL注入还是不够的，另外还要经常使用专业的漏洞扫描工具对网站进行漏洞扫描。 对脚本执行漏洞的防范黑客利用脚本执行漏洞进行攻击的手段是多种多样的，而且是灵活多变的，对此，必须要采用多种防范方法综合的手段，才能有效防止黑客对脚本执行漏洞进行攻击。这里常用的方法方法有以下四种。一是对可执行文件的路径进行预先设定。可以通过safe_moade_exec_dir来实现;二是对命令参数进行处理，一般用escapeshellarg函数实现;三是用系统自带的函数库来代替外部命令;四是在操作的时候进可能减少使用外部命令。 对全局变量漏洞防范对于PHP全局变量的漏洞问题，以前的PHP版本存在这样的问题，但是随着PHP版本升级到5.5以后，可以通过对php.ini的设置来实现，设置ruquest_order为GPC。另外在php.ini配置文件中，可以通过对Magic_quotes_runtime进行布尔值设置是否对外部引人的数据中的溢出字符加反斜线。为了确保网站程序在服务器的任何设置状态下都能运行。可以在整个程序开始的时候用get_magic_quotes_runtime检测设置状态决定是否要手工处理，或者在开始(或不需要自动转义的时候)用set_magic_quotes_runtime(0)关掉。 对文件漏洞的防范对于PHP文件漏桐可以通过对服务器进行设置和配置来达到防范目的。这里具体的操作如下:一是把PHP代码中的错误提示关闭，这样可以避免黑客通过错误提示获取数据库信息和网页文件物理路径;二是对open_basedir尽心设置，也就是对目录外的文件操作进行禁止处理;这样可以对本地文件或者远程文件起到保护作用，防止它们被攻击，这里还要注意防范Session文件和上载文件的攻击;三是把safe-made设置为开启状态，从而对将要执行的命令进行规范，通过禁止文件上传，可以有效的提高PHP网站的安全系数。]]></content>
      <tags>
        <tag>web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器架构]]></title>
    <url>%2F2016%2F20160522-1.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PSR规范]]></title>
    <url>%2F2016%2F20160521-1.html</url>
    <content type="text"><![CDATA[PSR是由PHP Framework Interoperability Group（PHP通用性框架小组）发布的一系列标准/规范，目前包括了PSR-0~PSR-4共4个，而PSR-0就是其中的自动加载标准（其后的PSR-4称为改进的自动加载的标准，是PSR-0的补充。PSR-0使用更广泛）。https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md 强制要求下面描述了具体互操作性的自动加载所必须的条件： 一个完全合格的namespace和class必须符合这样的结构 \* 每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字） 每个namespace可以有多个子namespace 当从文件系统中加载时，每个namespace的分隔符要转换成 DIRECTORY_SEPARATOR(操作系统路径分隔符) 在CLASS NAME（类名）中，每个下划线(_)符号要转换成DIRECTORY_SEPARATOR。在namespace中，下划线(_)符号是没有（特殊）意义的。 当从文件系统中载入时，合格的namespace和class一定是以 .php 结尾的 verdor name,namespaces,class名可以由大小写字母组合而成（大小写敏感的） 除此之外可能还会遵循这个规则：如果文件不存在则返回false。 例子1234567\Doctrine\Common\IsolatedClassLoader =&gt; /path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php\Symfony\Core\Request =&gt; /path/to/project/lib/vendor/Symfony/Core/Request.php\Zend\Acl =&gt; /path/to/project/lib/vendor/Zend/Acl.php\Zend\Mail\Message =&gt; /path/to/project/lib/vendor/Zend/Mail/Message.phpNameSpace和Class Name中的下划线\namespace\package\Class_Name =&gt; /path/to/project/lib/vendor/namespace/package/Class/Name.php\namespace\package_name\Class_Name =&gt; /path/to/project/lib/vendor/namespace/package_name/Class/Name.php 将下划线转换成DIRECTORY_SEPARATOR实际上是出于兼容PHP5.3之前的版本的考虑 12345678910111213141516171819&lt;?php function autoload($className) &#123; //这里的$className一般是用namespace的方式来引用的，文章开头已有介绍 //去除$className左边的'\' 这是PHP5.3的一个bug，详见https://bugs.php.net/50731 $className = ltrim($className, '\\'); $fileName = ''; $namespace = ''; //找到最后一个namespace分隔符的位置 if ($lastNsPos = strrpos($className, '\\')) &#123; $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $fileName = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; &#125; $fileName .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; require $fileName; &#125; ?&gt; NameSpace（命名空间）namespace是PHP5.3版本加入的新特性，用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 PHP 命名空间中的元素使用了类似文件系统的原理。例如，类名可以通过三种方式引用： 非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod();。如果当前命名空间是 currentnamespace，foo 将被解析为 currentnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为foo。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 使用命名空间：后备全局函数名称/常量名称。 限定名称,或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod();。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 currentnamespace\subnamespace\foo。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为subnamespace\foo。 完全限定名称，或包含了全局前缀操作符的名称，例如， $a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name)currentnamespace\foo。另外注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 \strlen() 或 \Exception 或 \INI_ALL。 123456789101112&lt;?php use My\Full\Classname as Another, My\Full\NSname; $obj = new Another; // 实例化一个 My\Full\Classname 对象 $obj = new \Another; // 实例化一个Another对象 $obj = new Another\thing; // 实例化一个My\Full\Classname\thing对象 $obj = new \Another\thing; // 实例化一个Another\thing对象 $a = \strlen(&apos;hi&apos;); // 调用全局函数strlen $b = \INI_ALL; // 访问全局常量 INI_ALL $c = new \Exception(&apos;error&apos;); // 实例化全局类 Exception ?&gt; Autoload（自动加载）通过定义的一个或一系列autoload函数，它会在试图使用尚未被定义的类时自动调用。通过调用autoload函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。这个autoload函数可以是默认的__autoload()，如下： 1234567&lt;?php function __autoload($class_name) &#123; require_once $class_name . &apos;.php&apos;; &#125; $obj = new MyClass(); ?&gt; 也可以采用更灵活的方式，通过spl_autoload_register()来定义我们自己的__autoload()函数：1234567&lt;?php function my_autoload($class_name) &#123; require_once $class_name . &apos;.php&apos;; &#125; spl_autoload_register(&quot;my_autoload&quot;); $obj = new MyClass(); ?&gt; 以上代码将my_autoload()函数注册到autoload栈中，从而取到autoload()函数（注意autoload()函数将不再起作用，但可以显式的将其注册到autoload栈）。注意到刚才提到了__autoload栈，意味着我们可以注册多个autoload函数，根据注册的顺序依次加载（通过spl_autoload_register的第三个参数可以改变这一顺序)。在这里我们展示了autoload函数最简单的例子，当然通过一些规则的设置，也可以胜任实际环境中许多复杂的情况。]]></content>
      <tags>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP正则]]></title>
    <url>%2F2016%2F20160123-1.html</url>
    <content type="text"><![CDATA[没有金刚钻，别揽瓷器活！正则使用方便也有性能隐患！！！PHP 正则替换正则中的一些概念元字符. 匹配除换行符意外的任意字符 \w 匹配字母或数字或下划线 \s 匹配任意的空白符 \d 匹配数字 \b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 [x] 匹配x字符，如匹配字符串中的 a、b 和 c 字符 \W \w的反义，即匹配任意非字母，数字，下划线和汉字的字符 \S \s的反义，即匹配任意非空白符的字符 \D \d的反义，即匹配任意非数字的字符 \B \b的反义，即不是单词开头或结束的位置 [^x] 匹配除了 x 以外的任意字符，如 [^abc] 匹配除了 abc 这几个字母之外的任意字符 重复* 重复零次或更多次 + 重复 1 次或更多次 ? 重复零次或 1 次 {n} 重复 n 次 {n,} 重复 n 次或更多次 {n,m} 重复 n 到 m 次 模式修正符i 模式中的字符将同时匹配大小写字母m 字符串视为多行s 将字符串视为单行，换行符作为普通字符x 将模式中的空白忽略e preg_replace() 函数在替换字符串中对逆向引用作正常的替换，将其作为 PHP 代码求值，并用其结果来替换所搜索的字符串。A 强制仅从目标字符串的开头开始匹配D 模式中的 $ 元字符仅匹配目标字符串的结尾U 匹配最近的字符串u 模式字符串被当成 UTF-8 PHP正则函数在 PHP 应用中，正则表达式主要用于： 正则匹配：根据正则表达式匹配相应的内容 2. 正则替换：根据正则表达式匹配内容并替换 3. 正则分割：根据正则表达式分割字符串 PHP 正则表达式匹配 preg_match 与 preg_match_all 函数preg_match()preg_match() 函数用于进行正则表达式匹配，成功返回 1 ，否则返回 0 。 语法： int preg_match( string pattern, string subject [, array matches ] )参数说明：pattern 正则表达式 subject 需要匹配检索的对象 matches 可选，存储匹配结果的数组， $matches[0] 将包含与整个模式匹配的文本，$matches[1] 将包含与第一个捕获的括号中的子模式所匹配的文本，以此类推 preg_match_all()preg_match_all() 函数用于进行正则表达式全局匹配，成功返回整个模式匹配的次数（可能为零），如果出错返回 FALSE 。 语法： int preg_match_all( string pattern, string subject, array matches [, int flags ] )参数说明:pattern: 正则表达式subject: 需要匹配检索的对象matches: 存储匹配结果的数组flags: 可选，指定匹配结果放入 matches 中的顺序，可供选择的标记有： PREG_PATTERN_ORDER：默认，对结果排序使 $matches[0] 为全部模式匹配的数组，$matches[1] 为第一个括号中的子模式所匹配的字符串组成的数组，以此类推 PREG_SET_ORDER：对结果排序使 $matches[0] 为第一组匹配项的数组，$matches[1] 为第二组匹配项的数组，以此类推 3. PREG_OFFSET_CAPTURE：如果设定本标记，对每个出现的匹配结果也同时返回其附属的字符串偏移量 部分实例//1，过滤所有html标签的正则表达式： &lt;/?[^&gt;]+&gt; //2，过滤所有html标签的属性的正则表达式： $html = preg_replace(“/&lt;([a-zA-Z]+)[^&gt;]*&gt;/”,“&lt;\\1&gt;“,$html); //3，过滤部分html标签的正则表达式的排除式（比如排除，即不过滤）： &lt;/?[^pP/&gt;]+&gt; //4，过滤部分html标签的正则表达式的枚举式（比如需要过滤等）： &lt;/?[aApPbB][^&gt;]*&gt; //5，过滤部分html标签的属性的正则表达式的排除式（比如排除alt属性，即不过滤alt属性）： \s(?!alt)[a-zA-Z]+=[^\s]* //6，过滤部分html标签的属性的正则表达式的枚举式（比如alt属性）： (\s)alt=[^\s]* 正则表达式中排除不需要匹配的字符串或字符(1)排除不需要匹配的某个字符： 例： [^\w] 排除匹配中的一个数字或字符串 (2) 排除匹配中不需要的字符串：例：(?!元宝商城|游戏特权|图说新游|多玩策划|新游视频|娱乐视频|多玩演播室|多玩画报) 加上|用于或选择。上面列出的字符串都不会参与匹配 常用正则删除空行: \r\n\r\n =&gt; \r\n 删除有空格的空行: ^ +$ =&gt;]]></content>
      <tags>
        <tag>PHP正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP数据缓存]]></title>
    <url>%2F2016%2F20160119-1.html</url>
    <content type="text"><![CDATA[缓存技术是web开发用来提高网站访问速度和减缓服务器压力的的重要手段之一，缓存主要分为页面缓存和数据缓存，一般情况下首页都采用页面缓存技术，其他的一些页面采用数据缓存比较多。下面贴上最近用php实现的数据缓存代码 cache.php1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass Cache &#123;private $cache_path;//path for the cacheprivate $cache_expire;//seconds that the cache expires//cache constructor, optional expiring time and cache pathfunction __construct($exp_time=3600,$path=”cache/”)&#123;$this-&gt;cache_expire=$exp_time;$this-&gt;cache_path=$path;&#125;//returns the filename for the cacheprivate function fileName($key)&#123;return $this-&gt;cache_path.md5($key);&#125;//creates new cache files with the given data, $key== name of the cache, data the info/values to storepublic function put($key, $data)&#123;$values = serialize($data);$filename = $this-&gt;fileName($key);$file = fopen($filename, ‘w’); if ($file)&#123;//able to create the file fwrite($file, $values); fclose($file); return true; &#125; else return false;&#125;//returns cache for the given keypublic function get($key)&#123;$filename = $this-&gt;fileName($key);if (!file_exists($filename) || !is_readable($filename))&#123;//can’t read the cachereturn false;&#125;if ( time() &lt; (filemtime($filename) + $this-&gt;cache_expire) ) &#123;//cache for the key not expired$file = fopen($filename, “r”);// read data file if ($file)&#123;//able to open the file $data = fread($file, filesize($filename)); fclose($file); return unserialize($data);//return the values &#125; else return false;&#125;else return false;//was expired you need to create new &#125;&#125;?&gt; 调用方法（完整列子）：123456789101112131415161718192021222324252627function get_cache_data($key)&#123; //从缓存从读取键值 $key 的数据 $values = $this-&gt;data_cache-&gt;get($key); //返回读取结果 return $values; &#125; function put_cache_data($key,$data)&#123; //insert code here… //写入键值 $key 的数据 $is_write = $this-&gt;data_cache-&gt;put($key, $data); return $is_write; &#125; /** * 最新成交列表 */ public function get_lastbargainlist() &#123; $list_xml = $this-&gt;get_cache_data(“lastbargainlist”); if(!$list_xml)&#123; $list_xml = $this-&gt;soap_client-&gt;doRequest($this-&gt;request_xml(“HS”,”lastbargainlist”)); if(!$this-&gt;put_cache_data(“lastbargainlist”,$list_xml))&#123; // echo “&lt;script&gt; alert(‘失败！’); &lt;/script&gt;”; &#125; &#125; $list_arr = simplexml_load_string($list_xml); return $list_arr; &#125; 实现页面缓存需要用到 ob_start ob_get_content ob_clean等函数，下次有需要的时候再去实现]]></content>
      <tags>
        <tag>缓存优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 经典SQL语句]]></title>
    <url>%2F2015%2F20151210-Library-sql-library.html</url>
    <content type="text"><![CDATA[随机推荐SQL原生：mysql&gt; select goods_id,goods_name from sh_goods order by rand() limit 5; ThinkPHP：$this-&gt;field(&#39;goods_id,goods_name,goods_thumb,goods_price&#39;)-&gt;where($where)-&gt;order(&#39;rand()&#39;)-&gt;limit($limit)-&gt;select(); 字段拼接select group_concat(concat(b.attr_name,&#39;:&#39;,a.goods_attr_values) separator &#39;&lt;br/&gt;&#39; ) as ga from sh_goods_atr a left join sh_attribute b on a.attr_id = b.attr_id where a.id in (36,41); 集合优化方法一：通过模糊查询select * from goods where `goods_status` like &#39;%hot%&#39;; 模糊查询，以%百分号开头的查询无法使用索引，只能是全表扫描。效率低下 方法二：使用find_in_set(值，集合)select * from goods where find_in_set(&#39;best&#39;,`goods_status`); 优化了方法一，效率提高了。但find_in_set()函数本身是个全表扫描的函数 方法三：使用位运算符查找best：select * from goods where goods_status &amp; 1;查找既有best又有hot同时存在：select * from goods where goods_status &amp; 1 and goods_status &amp; 4]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 钩子函数使用]]></title>
    <url>%2F2015%2F20151201-1.html</url>
    <content type="text"><![CDATA[注册 -&gt; 邮箱验证通过钩子函数完成数据入库前后的操作–Model12345678910111213141516171819202122&lt;?php/** * 插入的前置钩子函数在注册数据入库前，进行密码加密 * @param array &amp;$data 表单提交过来的数据 * @param array $option 表名和模型名以及一些查询条件（如果有） */public function _before_insert(&amp;$data,$option)&#123; $data['salt'] = uniqid(); $data['password'] = md5(md5($data['password']) . $data['salt']);&#125;/** * 插入的后置钩子函数，在数据真正入库之后会被调用 * @param array $data 存入数据库的数据，包含主键id * @param array $option 表名和模型名 */public function _after_insert($data,$option)&#123; $email_key = md5($data['id'] . C('EMAIL_KEY')); $content = "尊敬的用户您好，欢迎注册京西购物网站！&lt;br&gt;&lt;a href='http://local.shop.com/index.php/Member/Member/active/id/'" .$data['id']. "email_key" . $email_key. " target='_blank'&gt;请点击激活您的账户&lt;/a&gt;"; sendMail($data['email'], '京西购物商城', $content );&#125;?&gt; –Controller1234567891011121314151617181920212223242526&lt;?php// 会员邮箱激活public function active()&#123; $id = I('id'); $email_key = I('email_key'); $memberModel = D('Member'); // 验证用户id与用户秘钥是否匹配 if (md5($id . C('EMAIL_KEY')) == $email_key) &#123; $userinfo = $memberModel-&gt;find($id); if ($userinfo) &#123; $where = array('id'=&gt;$id); // setField 返回更新信息影响的函数 $status = $memberModel-&gt;where($where)-&gt;setField('isactive', 1); if ($status) &#123; return $this-&gt;success('用户激活成功', U('Home/Index/index')); &#125;else&#123; return $this-&gt;error('用户激活失败', U('Home/Index/index')); &#125; &#125;else&#123; $this-&gt;error('用户不存在', U('Home/Index/index')); &#125; &#125;else&#123; return $this-&gt;error('非法操作，该用户不存在',U('Home/Index/index')); &#125;&#125;?&gt; 商品 -&gt; 商品模块（简版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;?php/*** +-------------------------------------------** | Author: uiste [ JUST DO IT ]** +-------------------------------------------** | Connection: &lt;blog.uiste.com&gt;** +-------------------------------------------*/namespace Admin\Model;use Think\Model;/*** 商品模块*/class GoodsModel extends Model &#123; //自动验证 protected $_validate = array( array('goods_name', 'require', '商品名称不能为空'), ); // 自动填充 protected $_auto = array( array('goods_sn','_goods_sn',1,'callback'), array('add_time','_add_time',1,'callback'), ); // 商品货号填充检查 protected function _goods_sn($sn)&#123; if (empty($sn)) &#123; return 'sn_' . uniqid(); &#125;else&#123; return $sn; &#125; &#125; // 商品添加时间检查 protected function _add_time($time)&#123; if (empty($time)) &#123; return time(); &#125;else&#123; return strtotime($time); &#125; &#125; // 搜索分页功能 public function search()&#123; $where = '1 and is_delete = 0'; // 查询添加依据是否传递查询字段，没有传递默认为空，条件不成立 if ($goods_name = I('get.gn')) &#123; $where .= " and `goods_name` like '%$goods_name%'"; &#125; // 排序字段与排序方式通过判断前台是否有传递，有传递使用，没有就用默认值 $orderBy = !empty(I('get.ob')) ? I('get.ob') : 'goods_id'; $orderWay = !empty(I('get.ow')) ? I('get.ow') : 'desc'; $count = $this-&gt;where($where)-&gt;count(); $size = 5; $page = new \Think\Page($count, $size); $page-&gt;setConfig('prev','«'); $page-&gt;setConfig('next','»'); $show = $page-&gt;show(); $list = $this-&gt;where($where) -&gt;alias('goods') -&gt;join('left join jx_category cate on goods.cate_id = cate.cate_id') -&gt;order("$orderBy $orderWay") -&gt;limit($page-&gt;firstRow . ',' . $page-&gt;listRows) -&gt;select(); return array( 'show' =&gt; $show, 'list' =&gt; $list, ); &#125; // 插入前置钩子函数处理图片上传 protected function _before_insert(&amp;$data, $option)&#123; return $this-&gt;UploadFile($data, $option); &#125; // 更新前置钩子函数处理更新信息 public function _before_update(&amp;$data, $options)&#123; // 如果文件上传成功，执行以下更新信息 // dump($options);exit(); // 如果没有文件$_FILES['goods_img']['error'] == 4 if ($_FILES['goods_img']['error']== '0' ) &#123; $status = $this-&gt;UploadFile($data, $option); // dump($status);exit(); if ($status) &#123; $goods_id = $options['where']['goods_id']; $goodsOldImg = $this-&gt;field('goods_img , goods_thumb')-&gt;find(); // dump($goodsOldImg);exit(); foreach ($goodsOldImg as $key =&gt; $value) &#123; @unlink( C('UPLOAD_ROOT_PATH') . $value ); &#125; &#125;else&#123; return false; &#125; &#125; &#125; // 图片上传处理函数 private function UploadFile(&amp;$data, $option)&#123; $configMaxSize = (int)C('MAX_UPLOAD_FILE_SIZE'); $phpiniMaxSize = (int)ini_get('upload_max_filesize'); $allowMaxSize = min($configMaxSize, $phpiniMaxSize); $rootPath = C('UPLOAD_ROOT_PATH'); $exts = C('ALLOW_EXTS'); $config = array( 'maxSize' =&gt; $allowMaxSize * 1024 * 1024, 'rootPath' =&gt; $rootPath, 'savePath' =&gt; 'Goods/', 'exts' =&gt; $exts, ); $upload = new \Think\Upload($config); $info = $upload-&gt;upload(); if ($info) &#123; // 图片上传路径 $data['goods_img'] = $info['goods_img']['savepath'] . $info['goods_img']['savename']; // 生成缩略图 $image = new \Think\Image(); $image-&gt;open( $rootPath . $data['goods_img'] ); $thumImg = $info['goods_img']['savepath'] . 'thumb_' . $info['goods_img']['savename']; $image-&gt;thumb( C('THUMB.THUMB_W'), C('THUMB.THUMB_H'), C('THUMB.THUMB_S') )-&gt;save($rootPath . $thumImg ); $data['goods_thumb'] = $thumImg; return true; &#125;else&#123; $uploadError = $upload-&gt;getError(); $this-&gt;error = $uploadError; return false; &#125; &#125;&#125;?&gt;]]></content>
      <tags>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx 负载均衡]]></title>
    <url>%2F2015%2F20151120-1.html</url>
    <content type="text"><![CDATA[Nginx与Apache的区别Apache：扩展模块众多，功能强大，并发性能表现一般Nginx：功能相对于Apache较少，但并发性能特别好。异步非阻塞方式 环境搭建Linux网络配置1234ONBOOT=yesBOOTPROTO=staticIPADDR=192.168.34.102NETMASK=255.255.255.0 yum源软件安装1234567891011121314[root@localhost ~]# mkdir /mnt/cdrom[root@localhost ~]# mount /dev/cdrom /mnt/cdrom/[root@localhost ~]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.bak[root@localhost yum.repos.d]# vi CentOS-Media.repo name=CentOS-$releasever - Media baseurl=file:///media/CentOS/ file:///mnt/cdrom/ file:///media/cdrecorder/ gpgcheck=1 enabled=1[root@localhost yum.repos.d]# yum install -y vim[root@localhost yum.repos.d]# yum -y install make gcc gcc-c++ openssl openssl-devel pcre-devel zlib-devel libxml2 libxml2-devel 安装nginx 解压[root@localhost LNMP]# tar -zxvf nginx-1.8.0.tar.gz 编译[root@localhost nginx-1.8.0]# ./configure --prefix=/usr/local/nginx 安装[root@localhost nginx-1.8.0]# make &amp;&amp; make install 启动[root@localhost nginx-1.8.0]# /usr/local/nginx/sbin/nginx 检查12[root@localhost nginx-1.8.0]# netstat -tunple|grep 80tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 0 24507 5148/nginx 图示： 安装PHP服务 解压[root@localhost LNMP]# tar -zxvf php-5.3.28.tar.gz 编译(服务)[root@localhost php-5.3.28]# ./configure --prefix=/usr/local/php --enable-fpm 安装[root@localhost php-5.3.28]# make &amp;&amp; make install 配置文件[root@localhost php-5.3.28]# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf[root@localhost conf]# cp /home/LNMP/php-5.3.28/php.ini-development /usr/local/php/lib/php.ini 启动/重启[root@localhost php-5.3.28]# /usr/local/php/sbin/php-fpm 1234567[root@localhost conf]# ps -aux|grep phpWarning: bad syntax, perhaps a bogus &apos;-&apos;? See /usr/share/doc/procps-3.2.8/FAQroot 4749 0.0 0.2 16256 2052 ? Ss 22:46 0:00 php-fpm: master process (/usr/local/php/etc/php-fpm.conf)nobody 4750 0.0 0.2 16256 1724 ? S 22:46 0:00 php-fpm: pool wwwnobody 4751 0.0 0.2 16256 1724 ? S 22:46 0:00 php-fpm: pool wwwroot 4759 0.0 0.0 5980 740 pts/0 S+ 22:53 0:00 grep php[root@localhost conf]# kill -USR2 4749 检查 12[root@localhost php-5.3.28]# netstat -tunple|grep 9000tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 0 86848 4749/php-fpm nginx关联php12345678910[root@localhost php-5.3.28]# cd /usr/local/nginx/conf/[root@localhost conf]# vim nginx.conf location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi.conf; &#125;[root@localhost conf]# /usr/local/nginx/sbin/nginx -s reload nginx配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#运行的用户#user nobody;#工作进程数量，建议工作进程数等于cpu个数worker_processes 1;#错误日志#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#记录nginx的主进程号的文件位置#pid logs/nginx.pid;#网络事件及连接数events &#123; #每个工作进程最大的并发连接数， worker_connections 1024;&#125;#web相关的配置项http &#123; #nginx能够识别的文件类型 include mime.types; #默认的文件类型 default_type application/octet-stream; #日志文件格式 #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #访问日志 #access_log logs/access.log main; #是否使用系统的sendfile函数输出 sendfile on; #tcp_nopush on; #超时时间 #keepalive_timeout 0; keepalive_timeout 65; #开启gzip压缩 #gzip on; #虚拟主机配置，每一个sever就是一个虚拟主机 server &#123; #监听80端口 listen 80; #域名 server_name abc.com; #charset koi8-r; #access_log logs/host.access.log main; #默认的匹配规则 location / &#123; root html; #web项目的根目录 index index.html index.htm; &#125; ... 配置虚拟主机 修改主配置文件 12345678910111213141516171819202122[root@localhost conf]# pwd/usr/local/nginx/conf[root@localhost conf]# vim nginx.confhttp &#123; include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include /usr/local/nginx/conf/vhost/*.conf;&#125; 创建vhost目录 123456789101112131415161718[root@localhost vhost]# vim uiste.confserver &#123; #监听80端口 listen 80; server_name www.uiste.com; root /usr/local/nginx/html/uiste; #虚拟主机站点根目录 #默认的匹配规则 location / &#123; index index.html index.htm; &#125; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125;&#125;[root@localhost vhost]# mkdir /usr/local/nginx/html/uiste[root@localhost vhost]# /usr/local/nginx/sbin/nginx -s reload 访问日志nginx下访问日志是由配置项中的log_format跟access_log两个参数控制 log_format作用：申明一个日志文件格式语法：log_format 别名 具体的信息 123log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log作用：使用某种日志格式记录信息语法：access_log 存储地址 使用的别名access_log logs/access.log main; 访问日志中的参数 123456789$remote_addr：客户端的IP地址$remote_user：客户端的用户信息 通过权限验证之后的用户信息$time_local：时间及时区信息$request：请求类型及协议请求的URL地址$status：状态码$body_bytes_sent：返回数据大小$http_referer：请求的来源$http_user_agent：客户的信息$http_x_forwarded_for：真实客户端的IP地址，使用透传才能获取到真实客户端的IP地址 访问日志的申明只能写在http与sever之间，不能写在server配置中。访问日志可以申明多个。相对于server,http是全局设置，在虚拟主机设置使用访问日志，优先使用虚拟主机设置的格式，如果在虚拟主机中没有设置，但是在全局http中有开启使用访问日志，就会使用全局的格式记录 日志分割crontab12345678基本格式 : * * * * * command 表示(分 时 日 月 周 命令) 第1列表示分钟1～59 每分钟用*或者 */1表示 第2列表示小时1～23（0表示0点） 第3列表示日期1～31 第4列表示月份1～12 第5列标识号星期0～6（0表示星期天） 第6列要运行的命令 思路 一个脚本 一个容器能够定时执行脚本 定时分割 创建cat_access.sh脚本 123456789101112[root@localhost uiste]# vim cat_access.sh# /bin/bashlogs_path=&quot;/usr/local/nginx/logs/&quot;#以前的日志文件log_name=&quot;access.log&quot;#指定nginx主进程号存储位置pid_path=&quot;/usr/local/nginx/logs/nginx.pid&quot;mkdir -p $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; +&quot;%Y&quot;)/$(date -d &quot;yesterday&quot; +&quot;%m&quot;)/mv $&#123;logs_path&#125;access.log $&#123;logs_path&#125;$(date -d &quot;yesterday&quot; +&quot;%Y&quot;)/$(date -d &quot;yesterday&quot; +&quot;%m&quot;)/access_$(date -d &quot;yesterday&quot; +&quot;%Y%m%d&quot;).log#重新加载配置文件kill -USR1 `cat $&#123;pid_path&#125;` 修改cat_access.sh脚本为可执行文件[root@localhost uiste]# chmod -R 777 cat_access.sh 测试cat_access.sh脚本运行情况[root@localhost uiste]# ./cat_access.sh 将脚本放入crontab中定时执行 12[root@localhost uiste]# crontab -e* * * * * /usr/local/nginx/html/uiste/cat_access.sh 查看结果[root@localhost uiste]# tail -f /var/log/cron 反向代理 建立测试文件（略） 修改主服务器配置文件实现反向代理将其他的locatin都删除掉只留下一个 /的location 123456789101112131415[root@localhost uiste]# cd /usr/local/nginx/conf/vhost[root@localhost vhost]# vim uiste.confserver &#123; #监听80端口 listen 80; server_name www.uiste.com; root /usr/local/nginx/html/uiste; #虚拟主机站点根目录 #默认的匹配规则 location / &#123; proxy_pass http://192.168.34.101; index index.html index.htm; &#125;&#125;[root@localhost vhost]# /usr/local/nginx/sbin/nginx -s reload 测试截图 负载均衡192.168.34.105作为反向代理服务器192.168.34.101真实处理请求的服务器192.168.34.102真实处理请求的服务器 配置nginx主配置文件 12345678910111213141516171819202122232425262728293031323334353637383940[root@localhost uiste]# vim /usr/local/nginx/conf/nginx.confhttp &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log logs/access.log main; # 配置代理服务器 upstream web&#123; server 192.168.34.101; server 192.168.34.102; &#125; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; include /usr/local/nginx/conf/vhost/*.conf;&#125;[root@localhost uiste]# vim /usr/local/nginx/conf/vhost/uiste.confserver &#123; #监听80端口 listen 80; server_name www.uiste.com; root /usr/local/nginx/html/uiste; #虚拟主机站点根目录 #默认的匹配规则 location / &#123; proxy_pass http://web; #反向代理一组服务器 index index.html index.htm; &#125;&#125;[root@localhost vhost]# /usr/local/nginx/sbin/nginx -s reload 测试效果 upstream语法说明语法：123Upstream 别名&#123; Server IP地址/域名 参数;&#125; 参数：123451、down标注服务器为关闭状态，不参与负载均衡2、weight=number：权重按照轮循的方式依据权重实现不同的负载3、max_fails=number：最大失败次数4、fail_timeout=number：超时时间5、backup ：表示为备用服务器。 负载均衡算法： 轮循 权重 最小连接 ip_hashnginx重启报错1234[root@localhost vhost]# /usr/local/nginx/sbin/nginx -s reloadnginx: [error] open() &quot;/usr/local/nginx/logs/nginx.pid&quot; failed (2: No such file or directory)#解决方法：`[root@localhost logs]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf` 使用nginx-c的参数指定nginx.conf文件的位置]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcache 分布式缓存]]></title>
    <url>%2F2015%2F20151119-1.html</url>
    <content type="text"><![CDATA[概念Memcache是一套分布式高速缓存系统，分布式是说你可以在多台服务器上安装Memcache服务，这样可以达到一个很好的集群效果，高速是因为Memcache所有的数据都是保存在内存中的，读取速度比存储在硬盘中的数据快的多。Memcache的作用，但应用访问量特别大的时候，数据库的访问量也特别大。Memcache就是在应用与数据库之间的一个缓冲层。第一次读取数据库之后就可以保存到Memcache中，之后可以优先通过Memcache访问Memcache可以理解为只有一张表的数据库，只有两个字段，分别是主键key和字段 Memcache是非持久化储存，一定要保存对数据的存储要求并不是特别高，即使数据丢失也不会对我们的数据造成太大的影响 Memcache是分布式的存储，对于内存的消耗是特别大的，如果是单机的情况，不建议使用Memcache 格式简单，key与value，保存除了资源以外的所有数据，都是通过内部序列化与反序列化的机制进行数据的存储的。 memcache的常用参数-p：指定memcache的tcp协议使用的端口号-d :start/stop：memcache的启动/关闭-d: install/uninstall ：memcache服务的安装/卸载-u：指定用户名，此参数只在Linux下使用-m：表示memcache能够使用的最大的内存，默认64M-c：表示指定memcache能够接受的最大的并发量，默认是1024个 在memcache中没有账号密码，因此memcache中的数据不太安全。解决办法： 将memcache服务器置于内网中，然后使用反向代理技术访问 只容许某个IP地址可以访问，通过服务器防火墙的配置 memcache中常用的操作指令set:作用：是用于设置(添加，修改)某个数据语法：set keyname(键名) 0|1(数据是否压缩处理) exprie(有效时间) length(字符长度)Value(具体的数据)注意写入具体的value数据时有回车换行操作 get:作用：获取某个键的值语法：get keyname add:作用：添加某个键语法：add keyname(键名) 0|1(数据是否压缩处理) exprie(有效时间) length(字符长度)Value(具体的数据) delete:作用：删除某个键语法：delete 键名 incr:作用：自增长语法：incr keyname num(具体增长的值) decr:作用：自减语法： decr keyname num flush_all:作用：清除所有的键语法:flush_all stats作用：表示memcache服务器状态语法：stats 对于memcache有一个命中率来衡量服务器性能如何命中率=get_hits/cmd_get*100% 存储数据类型memcache支持php中的除了资源类型外其他的都可以存储 Linux下安装memcache服务关闭防火墙service iptables stop 安装libevent 解压：[root@localhost memcache]# tar -zxvf libevent-2.0.20-stable （进入编译目录） 编译：[root@localhost libevent-2.0.20-stable]# ./configure --prefix=/usr/local/libevent 安装：[root@localhost libevent-2.0.20-stable]# make &amp;&amp; make install 安装Memcache： 解压：[root@localhost memcache]# tar -zxvf memcached-1.4.20.tar.gz (进入编译目录) 编译：[root@localhost memcached-1.4.20]# ./configure --prefix=/usr/local/memcache --with-libevent=/usr/local/libevent 安装：[root@localhost memcached-1.4.20]# make &amp;&amp; make install 启动： a. [root@localhost memcached-1.4.20]# cd /usr/local/memcache/bin b. [root@localhost bin]# ./memcached -u root -d start 检查：[root@localhost bin]# netstat -tunple | grep 11211 memcache实际应用： session 写入Memcache中 作为分布式存储系统：一个任务由多台服务器一起协调完成，如果一台服务器出现异常，整个任务链不能正常进行 addServer，依据键名实现分布式存储。 作为缓存系统使用 session写入Memcache中： 写入文件中： session过多，会导致文件过多，查询效率变慢负载均衡的项目不能正常使用 写入数据库中： session_save_handle($open,$close,$read,$write,$destroy,$gc) 写入Memcache中： session_save_handle();设置配置文件ini_set(‘session.save_handle’,’Memcache’);ini_set(‘session.save_path’,’tcp://127.0.0.1:11211’); Memcache作为缓存系统 读取数据时，先通过Memcache服务器读取，如果能读取到则直接使用，如果读取不到，则去数据库中查询，查询到以后将数据缓存到Memcache中 修改数据时，先将mysql中的数据修改掉，然后更新memcache缓存重点的数据(也可以之间删除对应的key)]]></content>
      <tags>
        <tag>服务器优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2015%2F20151119-2.html</url>
    <content type="text"><![CDATA[redis是一个基于内存的键值对的数据库。支持5中数据类型其中包括字符串，链表，哈希，无序集合、有序集合。并且支持数据持久化操作(保证数据安全，在服务器重启之后，会自动的将数据还原到内存中) 安装 解压[root@localhost redis]# tar -zxvf redis-2.6.14.tar.gz 安装[root@localhost redis-2.6.14]# make &amp;&amp; make install 创建软件目录[root@localhost redis-2.6.14]# mkdir /usr/local/redis 复制服务到软件目录[root@localhost redis-2.6.14]# cp src/redis-server /usr/local/redis/ 复制配置文件到软件目录[root@localhost redis-2.6.14]# cp redis.conf /usr/local/redis/ 进入软件目录下启动Redis[root@localhost redis-2.6.14]# /usr/local/redis/redis-server 修改Redis为后台启动 通过配置文件启动redis服务 查看是否正常运行netstat -tunple|grep 6379 基本使用 exists key检查某个key是否存在 del key删除某个key type key检查key所对应的value的类型在redis中对外显示没有整形，在内部有区分 keys pattern查找满足条件的所有的keykeys keys user_ rename oldkey newkey重命名某个keyexpire key为某个key设置过期时间 ttl key查看某个key的有效时间 select db切换数据库在redis中有数据库的概念。默认有16个数据库每个数据库之间相互没有关系，默认是连接到0数据库在redis配置项中有一个databases参数设置默认的数据个数 flushdb清空当前所在的数据库下的所有数据 redis的数据结构字符串可以包含任何数据，比如jpg图片或者序列化的对象(PHP中对象序列化函数serialize)。单个value最大值上限是512M如果说只用这种类型，Redis就像一个可以持久化的memcached服务器 常用命令1234567891011set key 设置key的值get key 获取key的值Mget key1 key2 ... 批量获取指定key的值Mset key1 value1 key2 value2 ... 批量设置值strlen key 返回字符串的长度incr key 对key的值进行自增decr key 对key的值进行自减incrby key num 对key值进行自加num操作decrby key num 对key值进行自减num操作append key value 对key值的值末尾追加value 如果key不存在则创建substr key start end 返回名称为key的字符串子串 哈希hash是一个string类型的field和value的映射表。hash特别适合用于存储对象。相较于将对象的每个字段存成单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。 常用命令123456789hset key field value 添加一个filed属性 值为valuehget key field 返回field属性的值hmset key field1 value1 field2 value2 批量设置key中field1和field2的值hmget key field1 field2 批量获取key总field1 field2的值hexists key field 检查key中为field属性的值是否存在hdel key field 删除key中的field的属性hlen key 返回key中属性的个数hvals key 返回key中所有的value值hgetall key 返回key总所有filed跟value对应值 链表list类型其实就是一个每个子元素都是string类型的双向链表链表可以使用在显示最新登录的用户，邮件队列。消息推送，抢购。 常用命令123456789rpush key value 表末添加一个元素lpush key value 表头添加一个元素lpop key 删除表头的元素rpop key 删除表尾的元素llen key 返回链表长度lrange key start end 返回list 中key从start开始end之间的元素ltrim key start end 截取名称为key 的list保留start到end之间的元素（该变了链表的元素）lindex key index 返回list中为index位置的元素iset key index value 给list中为index位置的元素赋值 集合很多字符串组合在一起就叫做集合，对于集合两两之间可以进行交集、并集、差集。主要应用在社交关系处理，例如计算两个人之间的共同好友可以通过集合取交集得到结果 常用命令12345678910111213sadd key value 添加一个元素（集合中不能有重复元素）strm key value 删除为value的元素smembers key 返回所有的元素spop value 返回一个随机被删除的元素（集合会被修改）scard key 返回集合中有多少个元素smove key key2 value 将key 中元素为value的转移到key2集合中，key2不存在则创建sismember key value 测试key集合中是否存在valuesinter key1 key2 集合求交集sinterstore key key1,key2 将集合key1和key2的交集保存到key集合中sunion key1 key2 求并集sunionstore key key1,key2 求并集 保存到key集合中sdiff key1 key2 求差集sidff key key1 key2 求差集保存到key集合中 有序集合有序集合是在无序集合的基础之上增加了一个权重score，可以用于排序操作。 常用命令123456zadd key score member 添加元素到集合中zrem key member 删除指定元素zcard key返回集合中的元素zincrby key num member 将member上的分值增加numzrank key member返回指定元素在集合中的排名 score从小到大排列zrange key start end 获取集合中指定区间的元素 持久化原理redis定期的将内存中的数据转存储到磁盘上，如果一旦出现重启情况，redis会自动的将磁盘中备份数据还原到内存中 ###snap shotting快照方式(默认方式) 实现1redis默认开启快照备份功能，能够将数据存储到默认是存储到dump.rdb文件中 参数描述12345save 900 1:表示在900秒之内(以上一次备份的时间)有一个key发生变化，就会触发备份操作save 300 10:表示在300秒之内(以上一次备份的时间)有10个key发生变化，就会触发备份操作save 60 10000:表示在60秒之内(以上一次备份的时间)有10000个key发生变化，就会触发备份操作注意：只要有一个条件满足就会执行备份问题：例如16:25这个时间点发生了一次备份，下次备份将会法师在16:40这个时间，然后16:30突然服务器重启了。还原过程中只能讲数据还原到16:25这个时间点上，因此数据丢失。 实现2手动备份可以通过在客户端上执行save或者bgsave命令备份save：表示前台备份，该方式会阻塞其他请求。bgsave：后台备份方式，此方式不会阻塞其他请求。阻塞过程中其他客户端不能正常操作数据 AOF备份原理aof备份会将每一个写入操作的命令都记录到某一个文件中，当redis重新运行起来之后，会把文件中记录的命令重新执行一遍，因此就能还原数据 开启aof备份AOF备份默认是关闭的，通过配置项appendonle参数控制(注意：开启aof会清空所有的数据)1234此三个参数是用于控制redis将命名写入文件中的速度always：每写入一个命名刷新缓冲区的内容到文件中，即每写入一个命令就将命令写入到文件中everysec:表示每秒钟写入一次no：由系统决定什么时候写入 aof备份文件压缩随着时间变长，redis中的aof备份文件会越来越大，有很多写入命名，在重复操作占用了空间，因此可以使用压缩功能将文件大小减少在客户端命令行下使用bgrewriteaof 主从复制192.168.34.101：作为主服务器也叫master服务器192.168.153.128：作为从服务器，去同步主服务器中的数据，也叫slave服务器 实现步骤 设置从服务器 重启Redis服务 验证从服务器数据 主服务器关闭防火墙 权限验证在redis中有权限验证的，验证方式只有密码，没有用户名，密码是存储在配置文件中，并且是明文存储，使用配置项requirepass指定密码。redis数据存储在内存，速度比较快可以暴力破解密码，因此建议可以不使用密码。通过服务器安全防护 修改配置文件中密码 重启Redis服务 进入Redis客户端 密码校验 PHP操作Redis 开启Redis扩展查看phpinfo中Thread Safety：enabled -&gt; TS版本 线程是否安全选择ts或者nts版本如果为5.3以上的版本有2个dll文件，并且顺序要是redis.dll的引入在下 PHP操作Redis数据 1234567891011121314151617&lt;?php // 实例化对象 $redis = new Redis(); $redis-&gt;connect('192.168.153.132',6379); // 密码验证 $redis-&gt;auth('123456'); // 赋值操作 $res = $redis-&gt;set('user','uiste'); var_dump($res); // 取值操作 $content = $redis-&gt;get('user'); var_dump($content); ?&gt;]]></content>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongodb]]></title>
    <url>%2F2015%2F20151119-3.html</url>
    <content type="text"><![CDATA[NOSQL：非关系型数据库 特性 读写速度特别快 原因内存映射机制：先将数据写入内存，写入完成后通过异步方式将内存中的数据写入文档中查询部分使用频率较高的数据还停留在内存中。所需空间特别大 数据无规则 每一条数据都可以随意添加减少属性 支持主从复制 支持主从复制实现数据同步，故可以实现读写分离。自带监察模式，主服务器出现问题，自动在从如曲奇中选择一个服务器作为主服务器 支持数据分片 支持分布式存储 不受SQL注入影响 适合储存的数据由于mongodb不支持事务处理，因此不适合存储业务逻辑比较强的数据适合存储数据量比较大，当时价值比较低的数据 Linux安装 解压进入编译目录 12345[root@localhost mongodb]# tar zxvf mongodb-linux-i686-rhel57-2.3.0.tgz -C /usr/local[root@localhost local]# cd /usr/local/[root@localhost local]# pwd/usr/local 创建软链接或改名 12[root@localhost local]# ln -sv mongodb-linux-i686-rhel57-2.3.0/ mongodb&quot;mongodb&quot; -&gt; &quot;mongodb-linux-i686-rhel57-2.3.0/&quot; 进入到mongodb目录[root@localhost local]# cd mongodb 创建数据存储目录及日志文件[root@localhost mongodb]# mkdir data[root@localhost mongodb]# touch log.log 启动mongodb 12345[root@localhost mongodb]# cd bin[root@localhost bin]# ./mongod --logpath=/usr/local/mongodb/log.log --dbpath=/r/local/mongodb/data/ --fork[root@localhost bin]# netstat -tunple | grep 27017tcp 0 0 0.0.0.0:27017 0.0.0.0:* LISTEN 0 15697 2571/./mongod --fork后台启动 使用配置文件启动 1234567891011121314[root@localhost bin]# pkill mongo[root@localhost mongodb]# pwd/usr/local/mongodb[root@localhost mongodb]# vim mongo.conflogpath=/usr/local/mongodb/log.logdbpath=/usr/local/mongodb/data/fork = true[root@localhost mongodb]# ./bin/mongod -f /usr/local/mongodb/mongo.confforked process: 2662all output going to: /usr/local/mongodb/log.loglog file [/usr/local/mongodb/log.log] exists; copied to temporary file [/usr/local/mongodb/log.log.2016-11-18T21-15-30]child process started successfully, parent exiting 检查启动状态并进入 123456[root@localhost bin]# netstat -tunple|grep 27017tcp 0 0 0.0.0.0:27017 0.0.0.0:* LISTEN 0 16183 2662/./bin/mongod[root@localhost bin]# ./mongoMongoDB shell version: 2.3.0connecting to: test&gt; mongodb结构体系数据库-》表-》记录Mysql:databases-&gt;table-&gt;row 数据库-》集合-》文档mongodb:databases-&gt;collection-&gt;document 数据库基本操作 创建数据库 隐式创建数据库,如果没有写入数据库，数据库则自动消失 12&gt; use uisteswitched to db uiste 查看数据库 123&gt; show dbslocal (empty)test (empty) 创建集合 12345手动创建集合&gt; db.createCollection(&apos;student&apos;)&#123; &quot;ok&quot; : 1 &#125;隐式创建集合&gt; db.child.insert(&#123;name:123&#125;) 查看集合 123456&gt; show collectionschildstudent&gt; show tableschildstudent 删除集合 12&gt; db.student.drop()true 删除数据库 12&gt; db.dropDatabase()&#123; &quot;dropped&quot; : &quot;uiste&quot;, &quot;ok&quot; : 1 &#125; 查看帮助help 数据基本操作 增加数据db.集合.insert(数据)&gt; db.student.insert({name:&#39;dumin&#39;,age:33}) 数据采用bson格式 删除数据db.集合.remove(条件) justOne可选参数默认为全部删除db.student.remove({age:23}),{justOne:1})操作符条件年龄大于24的：db.student.remove({age:{&#39;$gt&#39;:24}})`；$g:大于,$gte：大于等于，$lt：小于，$lte：小于等于 123&gt; db.student.remove(&#123;name:&apos;dumin&apos;&#125;)&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;582f9f107943ef82a49db406&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125; 修改数据db.集合.update(条件，新值，不存在是否添加:默认false，是否修改多条:默认false) 123456789101112131415&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;582f9f107943ef82a49db406&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa21c7943ef82a49db407&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa2267943ef82a49db408&quot;), &quot;name&quot; : &quot;dumin&quot;, &quot;age&quot; : 23 &#125;&gt; db.student.update(&#123;name:&apos;xiaozhang&apos;&#125;,&#123;&apos;score&apos;:23&#125;)&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;582f9f107943ef82a49db406&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa21c7943ef82a49db407&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa2267943ef82a49db408&quot;), &quot;name&quot; : &quot;dumin&quot;, &quot;age&quot; : 23 &#125;&gt; db.student.update(&#123;name:&apos;xiaozhang&apos;&#125;,&#123;&apos;score&apos;:23&#125;,1)&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;582f9f107943ef82a49db406&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa21c7943ef82a49db407&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa2267943ef82a49db408&quot;), &quot;name&quot; : &quot;dumin&quot;, &quot;age&quot; : 23 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;582fa8636da1e09f672deb59&quot;), &quot;score&quot; : 23 &#125; 修改器$set：修改某一个字段,如果该字段不存在就增这个字段，语法同操作符$inc：自增 查询数据12345678&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;582f9ccf7943ef82a49db405&quot;), &quot;name&quot; : &quot;dumin&quot;, &quot;age&quot; : 33 &#125;&gt; db.student.findOne(&#123;name:&apos;xiaolan&apos;&#125;)&#123; &quot;_id&quot; : ObjectId(&quot;582f9f107943ef82a49db406&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;age&quot; : 13&#125; 主从复制作用 实现读写分离 同步数据作为热备服务器 可以进行后台的数据统计 思路 确定谁是主服务器 确定谁是从服务器 从服务器从哪里获取数据 实现 主服务器插入数据 12345&gt; db.student.insert([&#123;name:&apos;dumin&apos;,sex:1,age:23&#125;,&#123;name:&apos;xiaolan&apos;,sex:0,age:28&#125;])&gt; db.student.find()&#123; &quot;_id&quot; : ObjectId(&quot;58330e07627dd4a28d28ca57&quot;), &quot;name&quot; : &quot;qiang&quot;, &quot;sex&quot; : 1, &quot;age&quot; : 22 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;58330e60d1dae1108d07fc20&quot;), &quot;name&quot; : &quot;dumin&quot;, &quot;sex&quot; : 1, &quot;age&quot; : 23 &#125;&#123; &quot;_id&quot; : ObjectId(&quot;58330e60d1dae1108d07fc21&quot;), &quot;name&quot; : &quot;xiaolan&quot;, &quot;sex&quot; : 0, &quot;age&quot; : 28 &#125; 关闭主服务器mongodb服务 12[root@localhost ~]# pkill mongo[root@localhost ~]# netstat -tunple|grep mongo 申明主服务器 12345[root@localhost bin]# ./mongod --logpath=/usr/local/mongodb/log.log --dbpath=/usr/local/mongodb/data/ --fork --masterforked process: 1303all output going to: /usr/local/mongodb/log.loglog file [/usr/local/mongodb/log.log] exists; copied to temporary file [/usr/local/mongodb/log.log.2016-11-21T14-59-32]child process started successfully, parent exiting 配置从服务器 123456789[root@localhost mongodb]# pkill mongo[root@localhost mongodb]# ./bin/mongod --logpath=/usr/local/mongodb/log.log --dbpath=/usr/local/mongodb/data/ --fork --slave --source=192.168.34.102forked process: 1744all output going to: /usr/local/mongodb/log.loglog file [/usr/local/mongodb/log.log] exists; copied to temporary file [/usr/local/mongodb/log.log.2016-11-21T15-14-45]child process started successfully, parent exiting``` 4. 进入客户端查看 [root@localhost mongodb]# ./bin/mongoMongoDB shell version: 2.3.0connecting to: test show dbslocal 0.0625GBuiste 0.0625GBuse uisteswitched to db uisteshow collectionsstudentsystem.indexesdb.student.find();{ “_id” : ObjectId(“58330e07627dd4a28d28ca57”), “name” : “qiang”, “sex” : 1, “age” : 22 }{ “_id” : ObjectId(“58330e60d1dae1108d07fc20”), “name” : “dumin”, “sex” : 1, “age” : 23 }{ “_id” : ObjectId(“58330e60d1dae1108d07fc21”), “name” : “xiaolan”, “sex” : 0, “age” : 28 }1234## 权限控制mongodb中每一个数据库都会具备管理员有一个隐藏的admin数据库，此数据库时超级管理员相关的信息1. 创建超级管理员 use adminswitched to db admindb.addUser(‘root’,’123456’){ “user” : “root”, “readOnly” : false, “pwd” : “34e5772aa66b703a319641d42a47d696”, “_id” : ObjectId(“583310bc627dd4a28d28ca58”)}122. 创建student用户 可读可写用户 use studentswitched to db studentdb.addUser(‘uiste’,’123456’){ “user” : “uiste”, “readOnly” : false, “pwd” : “2f77d219f5631ed7c0c8c833317d1ff5”, “_id” : ObjectId(“5833113c627dd4a28d28ca59”)}只读用户db.addUser(‘dumin’,’123456’,true){ “user” : “dumin”, “readOnly” : true, “pwd” : “36ad4172b50f7453498c00c80358d61a”, “_id” : ObjectId(“58331195627dd4a28d28ca5a”)}123. 启用mongodb密码 [root@localhost bin]# pkill mongo[root@localhost bin]# ./mongod –logpath=/usr/local/mongodb/log.log –dbpath=/usr/local/mongodb/data/ –fork –authforked process: 1408all output going to: /usr/local/mongodb/log.loglog file [/usr/local/mongodb/log.log] exists; copied to temporary file [/usr/local/mongodb/log.log.2016-11-21T15-26-12]child process started successfully, parent exiting12344. 使用密码访问* 权限校验：需要先选择数据库，然后登陆校验* 如果直接使用db.auth()校验，不会通过 show dbsuse uistedb.auth(‘uiste’,’123456’)show dbsshow tablesdb.student.insert({name:’zcc’})db.student.find()125. 删除用户 db.system.users.find()db.system.user.remove({user:’dumin’})123## PHP操作mongodbmongodb 客户端中的“.” 换成“-&gt;” bson格式的数据转化成数组 &lt;?php/** MongoClien实例化会自动执行构造方法进行连接 一、$mongo = new MongoClient();//直接连接本机上的mongodb服务器 二、$mongo = new MongoClient(‘192.168.34.102:27017’);//连接自动的mongodb服务器 三、$mongo = new MongoCLient(‘mongodb://root:123456@192.168.34.102:27017’);*/// 建立连接$mongo = new MongoCLient(‘mongodb://root:123456@192.168.34.102:27017’);// 选择数据库$db = $mongo-&gt;uiste;$data = $db-&gt;student-&gt;find();foreach ($data as $key =&gt; $value) { var_dump($value);}?&gt;`]]></content>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL架构 | 多种方式登录]]></title>
    <url>%2F2015%2F20151118-1.html</url>
    <content type="text"><![CDATA[集群由一组服务器相互独立的服务器，构建的高性能与可靠性的服务器架构 MySQL读写分离主从复制是读写分离的基础 主从复制原理 主服务器将修改的SQL语句写入到二进制（bin）日志中 从服务器中的IO线程通过授权账号读取二进制日志，将信息写入到中继日志中（relay） 从服务器中的SQL线程读取中继日志中的数据，然后将SQL语句执行，还原主服务器中的数据 实现主从复制 开启主服务器的二进制日志centos yum 安装MySQL配置文件路径： 123log-bin=mysql-binbinlog_format=mixedserver-id=101 重启主服务器MySQLservice mysqld restart 添加授权账号 12345[root@localhost etc]# mysql -uroot -pEnter password:mysql&gt; GRANT REPLICATION SLAVE ON *.* TO repuser@&quot;192.168.%.%&quot; IDENTIFIED BY &apos;123456&apos;; Query OK, 0 rows affected (0.00 sec)#&apos;&apos;引号内是授权账号的密码 在主服务器下刷新用户权限mysql&gt; FLUSH PRIVILEGES; 查看主服务器状态 123456789mysql&gt; show master status;+------------------+----------+--------------+------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |+------------------+----------+--------------+------------------+| mysql-bin.000001 | 326 | | |+------------------+----------+--------------+------------------+1 row in set (0.00 sec)File ：表示正在使用二进制文件Position：二进制当前所在的位置 修改从服务器mysql配置项 12[root@localhost ~]# vim /etc/my.cnfserver-id = 102 重启从服务器的mysql服务[root@localhost ~]# service mysqld restart 配置从服务器通过授权账号读取主服务器信息 12mysql&gt; CHANGE MASTER TO MASTER_HOST=&apos;192.168.34.101&apos;,MASTER_USER=&apos;repuser&apos;,MASTER_PASSWORD=&apos;123456&apos;,MASTER_LOG_FILE=&apos;mysql-bin.000001&apos;,MASTER_LOG_POS=326;Query OK, 0 rows affected (0.07 sec) 在从服务器上开启主从同步数据 12mysql&gt; slave start;Query OK, 0 rows affected (0.00 sec) 查看主从复制的状态 1234567891011121314mysql&gt; show slave status\G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.34.101 Master_User: repuser Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000001 Read_Master_Log_Pos: 326 Relay_Log_File: mysqld-relay-bin.000002 Relay_Log_Pos: 251 Relay_Master_Log_File: mysql-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes 成功在主服务器上建表，写入数据，查看重服务的数据表跟数据是否与主服务一样 slave_io_running与slave_sql_running要求都为yes则表示成功可以使用 slave stop关闭主从，使用reset slave 可以清空主从信息 从服务器配置参数 CHANGE MASTER TOMASTER_HOST=’192.168.81.128’,//指定主服务器的地址MASTER_USER=’repuser’,//指定授权账号的用户名MASTER_PASSWORD=’123456’,//指定授权账号的密码MASTER_LOG_FILE=’mysql-bin.000001’,//指定主服务的正在使用的二进制文件MASTER_LOG_POS=326;//指定主服务器当前记录到的SQL语句的文字 开启bin日志，相关配置文件 log-bin=mysql-bin 开启二进制日志，并且名称以mysql-bin开头binlog-format=mixed 指定二进制文件记录sql语句的格式。statement：用一条sql语句记录修改。row：表示记录每一条sql语句。mixed：表示混合使用由mysql自己决定server-id = 101 表示主从服务器每台的标识各不一样datadir=/var/lib/mysqlmysql-bin.index //索引文件，列出当前有哪些二进制文件mysql-bin.000001//记录修改的SQL语句bin日志，只记录修改表数据的SQL语句：inser、delete、update 读写分离原理判断sql语句，如果是insert、update、delete类型sql语句则直接连接主服务器修改数据；如果是select语句则从slave服务器中选择一台进行查询。 实现读写分离ThinkPHP实现读写分离 修改配置项 123456789101112&apos;DB_DEPLOY_TYPE&apos; =&gt; 1, // 数据库部署方式:0 集中式(单一服务器),1 分布式(主从服务器)&apos;DB_RW_SEPARATE&apos; =&gt; true, // 数据库读写是否分离 主从式有效&apos;DB_MASTER_NUM&apos; =&gt; 1, // 读写分离后 主服务器数量&apos;DB_SLAVE_NO&apos; =&gt; &apos;&apos;, // 指定从服务器序号/* 数据库设置 */&apos;DB_TYPE&apos; =&gt; &apos;mysql&apos;, // 数据库类型&apos;DB_HOST&apos; =&gt; &apos;192.168.34.101,192.168.34.102&apos;, // 服务器地址&apos;DB_NAME&apos; =&gt; &apos;test&apos;, // 数据库名&apos;DB_USER&apos; =&gt; &apos;root,root&apos;, // 用户名&apos;DB_PWD&apos; =&gt; &apos;123456,123456&apos;, // 密码&apos;DB_PORT&apos; =&gt; &apos;3306,3306&apos;, // 端口&apos;DB_PREFIX&apos; =&gt; &apos;&apos;, // 数据库表前缀 代码书写 1234567891011public function read()&#123; $model = M(&apos;slave&apos;); $data = $model-&gt;select(); dump($data);&#125;public function write()&#123; $model = M(&apos;slave&apos;); $data=array(&apos;name&apos;=&gt;&apos;dumin&apos;,&apos;age&apos;=&gt;&apos;18&apos;,&apos;sex&apos;=&gt;&apos;女&apos;); $res = $model -&gt; add($data); dump($res);&#125; 分库分表垂直分表 冷热字段区分 水平分表 逻辑分表 MySQL内部完成 物理分表 可通过主键取余、MD5加密数据字母与数据分表等 逻辑分表key：取模算法hash：哈希算法range：某一个范围list：某些值得中间 创建语法1234567891011121314151617181920212223create table 表名(具体某些字段信息)engine=myisam default charset=utf8partition by key(分表字段) partitions num;create table 表名(具体某些字段信息)engine=myisam default charset=utf8partition by hash(分表字段) partitions num;create table 表名(具体某些字段信息)engine=myisam default charset=utf8partition by range(字段)( partition 别名 values less than (常量));create table 表名(具体某些字段信息)engine=myisam default charset=utf8partition by list(字段)( partition 别名 values in (列表)); 添加语法1234567求余算法：alter table 表名 add partition partitions 5;条件算法： alter table 表名 add partition( partition 名称 values less than (常量) 或 partition 名称 in (n,n,n)); 分表与多方式登录数据表1234567891011121314151617181920212223242526#创建一个不重复的IDcreate table blog_people_uid( uid int not null auto_increment comment &apos;用户唯一id&apos;, primary key(uid))engine=myisam default charset=utf8;create table blog_people( id int not null auto_increment comment &apos;用户表id&apos;, uid int not null default 0 comment &apos;用户唯一id&apos;, name char(24) not null default &apos;&apos; comment &apos;用户名&apos;, pwd char(32) not null default &apos;&apos; comment &apos;密码&apos;, tel char(11) not null default &apos;&apos; comment &apos;手机号码&apos;, email char(30) not null default &apos;&apos; comment &apos;电子邮件&apos;, primary key(id), unique key (uid), unique key (name), unique key (tel), unique key (email))engine=myisam default charset=utf8;create table blog_people_index( id int not null auto_increment comment &apos;登录检索表索引&apos;, uid int not null default 0 comment &apos;检索用户id&apos;, name char(30) not null default &apos;&apos; comment &apos;检索用户信息&apos;, primary key(id))engine=myisam default charset=utf8; laravel 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public function register()&#123; if($input = Input::all()); // 定义验证规则 $rules = [ 'pwd' =&gt; 'required|between:6,20', 'name' =&gt; 'alpha_num', 'name' =&gt; 'unique:people,tel', 'email' =&gt; 'email', 'tel' =&gt; 'integer', ]; // 提示信息 $message = [ 'name.alpha_num' =&gt; '用户名只能是字符和数字', 'name.unique' =&gt; '该用户已经存在请重新输入', 'email.email' =&gt; '请输入合法邮箱', 'tel.integer' =&gt; '请输入合法手机号码', 'pwd.required' =&gt; '密码不能为空', 'pwd.between' =&gt; '密码必须在6-20位之间', ]; $validator = Validator::make($input,$rules,$message); if($validator-&gt;passes())&#123;//验证规则通过 $pwd = $input['pwd']; $tel = $input['tel']; $email = $input['email']; // 检查用户名是否存在 $name = People::where('name','=',$input['name'])-&gt;first(); $tel = People::where('tel','=',$input['tel'])-&gt;first(); $email = People::where('email','=',$input['email'])-&gt;first(); if($name!=null)&#123; $data = array( 'sign' =&gt; 0, 'code' =&gt; 'register error', 'msg' =&gt; '该用户名已经存在，请返回登录或重新注册！' ); return json_encode($data); &#125; if($tel!=null)&#123; $data = array( 'sign' =&gt; 0, 'code' =&gt; 'register error', 'msg' =&gt; '该手机已经注册，请返回登录或重新注册！' ); return json_encode($data); &#125; if($email!=null)&#123; $data = array( 'sign' =&gt; 0, 'code' =&gt; 'register error', 'msg' =&gt; '该邮箱已经存在，请返回登录或重新注册！' ); return json_encode($data); &#125; $uid = DB::table('people_uid')-&gt;insertGetId(array()); $input['uid']=$uid; $input['pwd'] = Crypt::encrypt($input['pwd']); DB::table('people')-&gt;insert($input); DB::table('people_index')-&gt;insert(array('uid'=&gt;$uid,'name'=&gt;$input['name'])); DB::table('people_index')-&gt;insert(array('uid'=&gt;$uid,'name'=&gt;$input['tel'])); $res = DB::table('people_index')-&gt;insert(array('uid'=&gt;$uid,'name'=&gt;$input['email'])); if($res)&#123; // 成功 $data = array( 'sign' =&gt; 1, 'code' =&gt; 'register success', 'msg' =&gt; '注册成功！' ); echo json_encode($data);exit(); &#125;else&#123; // 入库失败 $data = array( 'sign' =&gt; 0, 'code' =&gt; 'insert error', 'msg' =&gt; '入库失败请联系管理员！' ); echo json_encode($data);exit(); &#125; &#125;else&#123; // 服务器端验证规则 $messages = $validator-&gt;messages(); $data = array( 'sign' =&gt; 0, 'code' =&gt; 'insert error', 'msg' =&gt; $messages-&gt;first(), ); echo json_encode($data);exit(); &#125;&#125;?&gt;]]></content>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用yum快速搭建LAMP环境]]></title>
    <url>%2F2015%2F20151117-1.html</url>
    <content type="text"><![CDATA[yum 源配置 挂载光驱 配置yum源 创建挂载点：[root@localhost mnt]# mkdir /mnt/cdrom 挂载系统安装光盘： 12[root@localhost mnt]# mount /dev/cdrom /mnt/cdrommount: block device /dev/sr0 is write-protected, mounting read-only 配置本地yum源 12345678[root@localhost mnt]# cd /etc/yum.repos.d/[root@localhost yum.repos.d]# ll总用量 16-rw-r--r--. 1 root root 1926 11月 27 2013 CentOS-Base.repo //本地配置源-rw-r--r--. 1 root root 638 11月 27 2013 CentOS-Debuginfo.repo-rw-r--r--. 1 root root 630 11月 27 2013 CentOS-Media.repo //网络配置源-rw-r--r--. 1 root root 3664 11月 27 2013 CentOS-Vault.repo[root@localhost yum.repos.d]# 修改CentOS-Media.repo在baseurl 中修改第2个路径为/mnt/cdrom（即为光盘挂载点）将enabled=0改为1 123456789[root@localhost yum.repos.d]# vi CentOS-Media.repo[c6-media]name=CentOS-$releasever - Mediabaseurl=file:///media/CentOS/ file:///mnt/cdrom/ //改为挂载点 file:///media/cdrecorder/gpgcheck=1enabled=1 //改为1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6 禁用默认的yum 网络源[root@localhost yum.repos.d]# mv CentOS-Base.repo CentOS-Base.repo.bak yum方式安装gcc，gcc-c++、make、openssl-devel[root@localhost yum.repos.d]# yum -y install make gcc gcc-c++ openssl openssl-devel pcre-devel zlib-devel libxml2 libxml2-devel Apache安装[root@localhost ~]# yum -y install httpd开机自启动[root@localhost ~]# chkconfig httpd on启动httpd服务[root@localhost ~]# service httpd start安装Apache一些扩展[root@localhost ~]# yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql 关闭防火墙[root@localhost ~]# service iptables stop输入服务器IP地址测试 [root@localhost ~]# vim /var/www/html/ 安装MySQL[root@localhost ~]# yum -y install mysql mysql-server mysql-devel mysql客户端程序mysql-server 服务器程序mysql-devel 开发设计的库 开机启动[root@localhost ~]# chkconfig mysqld on[root@localhost ~]# chkconfig --add mysqld查看开机启动设置是否成功： 12[root@localhost ~]# chkconfig --list | grep mysql*mysqld 0:关闭 1:关闭 2:启用 3:启用 4:启用 5:启用 6:关闭 启动mysqld服务[root@localhost ~]# service mysqld start或：[root@localhost ~]# /etc/init.d/mysqld start 登录客户端设置远程访问，默认没有密码。 修改密码：mysqladmin -u root password &#39;123456&#39; 123456789101112131415161718192021222324252627282930313233343536[root@localhost ~]# mysql -uroot -pEnter password:mysql&gt; use mysql;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedmysql&gt; select host,user from user;+-----------------------+------+| host | user |+-----------------------+------+| 127.0.0.1 | root || localhost | || localhost | root || localhost.localdomain | || localhost.localdomain | root |+-----------------------+------+5 rows in set (0.00 sec)mysql&gt; update user set host=&apos;%&apos; where user =&apos;root&apos; and host =&apos;127.0.0.1&apos;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; delete from user where host!=&apos;%&apos;;Query OK, 4 rows affected (0.00 sec)mysql&gt; select host,user from user;+------+------+| host | user |+------+------+| % | root |+------+------+1 row in set (0.00 sec)mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 报错 123[root@localhost yum.repos.d]# mysql -uroot -pEnter password:ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/var/lib/mysql/mysql.sock&apos; (111) mysql进程使用了同一个socket12[root@localhost yum.repos.d]# mv /var/lib/mysql/mysql.sock /var/lib/mysql/mysql.sock.bak[root@localhost yum.repos.d]# service mysqld start 重启MySQL服务[root@localhost ~]# service mysqld restart /usr/bin/mysql_secure_installation进行安全性设置 安装PHP[root@localhost ~]# yum -y install php php-mysql1234[root@localhost ~]# yum -y install php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt php-bcmath php-mhash libmcrypt---[root@localhost ~]# yum -y install php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc 配置文件路径PHP配置文件/etc/php.iniApache配置文件/etc/httpd/conf/httpd.confMySQL配置文件/etc/my.cnf若my.cnf精简可以从安装目录拷贝[root@localhost mysql]# cp /usr/share/mysql/my-medium.cnf /etc/my.cnfmysql解锁mv /var/lib/mysql/mysql.sock /var/lib/mysql/mysql.sock.bak 测试 [root@localhost ~]# service httpd restart[root@localhost ~]# vim /var/www/html/1.php 卸载yum卸载：yum -y remove mysql*rpm卸载：rpm -e mysql]]></content>
      <tags>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAMP 安装 Memcache | redis]]></title>
    <url>%2F2015%2F20151116-5.html</url>
    <content type="text"><![CDATA[Memcachehttps://github.com/uiste/PHP_Class_Library/tree/master/php-memcached 参考文章： Redis一.下载安装 下载：http://redis.io/ 移动：uiste:~ uiste$ cd downloads 解压：uiste:local uiste$ sudo tar -zxf redis-3.2.5.tar.gz 进入：uiste:local uiste$ cd redis-3.2.5 测试编译：uiste:redis-3.2.5 uiste$ sudo make test 安装： 123456789101112131415161718uiste:redis-3.2.5 uiste$ sudo make installPassword:cd src &amp;&amp; /Applications/Xcode.app/Contents/Developer/usr/bin/make install INSTALL redis-sentinel CC redis-cli.o LINK redis-cli CC redis-benchmark.o LINK redis-benchmark INSTALL redis-check-rdbHint: It&apos;s a good idea to run &apos;make test&apos; ;) INSTALL install INSTALL install INSTALL install INSTALL install INSTALL installuiste:redis-3.2.5 uiste$ 配置文件redis.confredis解压目录里有一个配置文件redis.conf ，编辑此配置文件，找到 dir ./ 这一行。redis会将内存中的数据写入文件中，而此配置就是指定数据文件保存的路径。我本机指定的目录为：247 dir /Users/uiste/Software/redis_data/ 编辑过后，将配置文件移动到 /usr/local/etc 目录下uiste:redis-3.2.5 uiste$ sudo mv redis.conf /usr/local/etc 启动uiste:redis-3.2.5 uiste$ /usr/local/bin/redis-server /usr/local/etc/redis.conf 服务启动成功画面： 测试连通性 123456uiste:~ uiste$ cd /usr/local/binuiste:bin uiste$ ./redis-cli127.0.0.1:6379&gt; set name uisteOK127.0.0.1:6379&gt; get name&quot;uiste&quot; 设置开机自动启动redis server新建plist文件uiste:~ uiste$ sudo vi /Library/LaunchDaemons/io.redis.redis-server.plist文件内容如下 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;io.redis.redis-server&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/redis-server&lt;/string&gt; &lt;string&gt;/usr/local/etc/redis.conf&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt;&lt;true/&gt; &lt;/dict&gt;&lt;/plist&gt; 使用launchctl设置开机自动启动uiste:~ uiste$ sudo launchctl load /Library/LaunchDaemons/io.redis.redis-server.plist 使用launchctl启动redis serveruiste:~ uiste$ sudo launchctl start io.redis.redis-server 使用launchctl停止redis serveruiste:~ uiste$ sudo launchctl stop io.redis.redis-server 启动uiste:~ uiste$ redis-cli 上述方法启动redis时是以非密码形式登录的，许多操作可能会出现 (error) NOAUTH Authentication required.解决此问题的方法之一就是找到 /etc/redis.conf，并将＃requirepass 前的 “＃” 去掉。由于每个人电脑不同，有可能没法在 /etc 路径下找到redis.conf， 因此可以选择采用第二种方法：（1）、按照原来方式 ./redis-cli 进入redis 客户端， 输入config set requirepass XXX，其中XXX是你要设置的密码。此时会出现 “OK”；（2）、之后返回bin目录下，输入 redis-cli -h 127.0.0.1 -p 6379 -a XXX， 就相当于以密码形式登录了。此后也不会再有身份验证失败问题。（3）、可以使用config get requirepass 查看密码 四.服务器配置 上面只是基本的安装，如果要用到生产环境，得配置一些文件 1.首先把redis-cli 移动到/usr/local/bin 目录，方便执行，和JAVA_HOME 类似 默认install 的时候已经有了 2.创建你存放配置文件和数据文件的目录 sudo mkdir /etc/redissudo mkdir /var/redis3.复制初始化脚本到/etc/init.d 目录,建议默认只有这个端口,作开机启动 $ sudo cp utils/redis_init_script /etc/init.d/redis_63794.进入脚本,确保你的REDISPORT 是你正在使用的 sudo vi /etc/init.d/redis_63795.复制redis.conf ,和脚本保持一致 sudo cp redis.conf /etc/redis/6379.conf6.创建一个存放工作数据的目录 sudo mkdir /var/redis/6379同时可以对redis.conf配置其他属性 daemonize：是否以后台daemon方式运行pidfile：pid文件位置port：监听的端口号timeout：请求超时时间loglevel：log信息级别logfile：log文件位置databases：开启数据库的数量save ：保存快照的频率，第一个表示多长时间，第三个表示执行多少次写操作。在一定时间内执行一定数量的写操作时，自动保存快照。可设置多个条件。rdbcompression：是否使用压缩dbfilename：数据快照文件名（只是文件名，不包括目录）dir：数据快照的保存目录（这个是目录）appendonly：是否开启appendonlylog，开启的话每次写操作会记一条log，这会提高数据抗风险能力，但影响效率。appendfsync：appendonlylog如何同步到磁盘（三个选项，分别是每次写都强制调用fsync、每秒启用一次fsync、不调用fsync等待系统自己同步）7.最后将脚本设置默认启动 sudo update-rc.d redis_6379 defaults8.现在可以执行脚本了 /etc/init.d/redis_6379 start]]></content>
      <tags>
        <tag>服务器优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化]]></title>
    <url>%2F2015%2F20151116-4.html</url>
    <content type="text"><![CDATA[MySQL优化着手点 存储层（数据）：存储引擎、列类型、范式规范（三范式与逆范式）myisam查询速度快，但不支持事务 设计层（单台服务器）：索引、缓存、分区索引：主键、唯一键、普通键、外键约束缓存：表结构与表数据没有发生变化时，MySQL会将第一次查询的结果缓存到内存中分区： 架构层（多台服务器）：读写分离或者分布式 语句层：更合适的sql语句select 具体字段与（*），黄金索引 存储引擎MySQL中的数据是通过各种不同的技术（格式）存储在文件（或者内存）中的。技术和本身的特性就称为“存储引擎” 每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术（格式），获取适合的效果。 查询存储引擎：show engines是否支持引擎：Support：default，默认是否支持事务：Transaction MySQL默认支持8种存储引擎，默认是innodb引擎，memory存储引擎是将数据存储在内存中，服务器重启会导致内存中的数据丢失 myisam引擎和innodb引擎的区别myisam myisam数据的读写速度相对于innodb引擎会快 支持表锁 数据压缩功能 支持全文索引（只支持英文）搜索引擎：sphinx，solr+ik 分词器 .frm：数据表的结构.MYD：数据表对应的数据.MYI：表锁数据表的索引文件 myisam引擎特有的压缩功能蠕虫复制insert into address select null,sheng,shi form address MySQL server/bin/myisampack.exe进行数据压缩用法：myisampack数据表的地址shell&gt;&gt;myisampack.exe ‘C:\Server\mysql_data\t_myisam\t_address’ 解决索引失效的问题Romember to run myisa -rq on compressed tables用法：myisamchk.exe -rq 表地址 压缩后的数据是一个只读数据表，不能写入数据，如果要写入数据必须解压 解压缩数据表myisamchk –unpach(两个-) 删除多余文件：flush table 表名批量写入数据时，开关索引alter table disable(onable) keys典型的应用场景使用mysql储存日志文件信息 innodb 行锁 在5.6之前是不支持全文索引 支持事务 支持外键 .frm：表示数据表的结构在datadir指向的目录下有一个ibdata1的文件该文件储存了innodb引擎数据表信息及索引的文件。此方式也叫共享文件存储 开启innodb引擎单独文件存储 数据备份还原 备份还原myisam引擎myisam引擎由于数据表结构、索引、数据都是用单独的文件存储，备份还原数据只需要复制粘贴文件即可 备份还原innodb引擎对于innodb引擎如果是使用单独文件存储依旧不能使用复制的方式备份数据，只能借助于mysql自带的根据备份备份使用：mysqldump工具还原使用:mysql工具备份用法：mysqldump -u 用户名 -p 密码 对应数据库名称 &gt; 具体存储地址还原的用法：mysql -u 用户名 -p 密码 对应数据库名称 &lt; 具体存储地址 数据类型的选择decimal 金钱使用char访问速度优于varchar char与varchar的区别 存储的最大字符数不一样，char最多能够存储255个字符，varchar以utf8编码最大长度65535/3-1 varchar存储多少个字符，占用多少个空间 对于末尾的空格处理不一样，char会过滤末尾的空格，varchar会保留空格 ip与整形数据的转换MySQL内置函数：inet_aton(ip)inet_ntoaPHP内置函数ip2longlong2ip 数据库三范式数据表设计规范 第一范式：所有的字段都是原子不可再分 第二范式：所有的字段都与主键有关系 第三范式： 所有字段必须与主键有直接关系 索引索引是针对某个字段A进行了排序然后写到了一个单独的文件（myisam），innodb在共享文件中存储。以后使用该字段查询数据时，先到索引文件中查找，然后根据物理存储地址直接找到对应的数据 索引类型主键索引：primary key ，唯一不重复，不能为空唯一索引：unique key， 唯一不重复，可以为空普通索引：key全文索引：fulltext 只支持英文，中文使用：sphinx软件、solr+ik分词器 索引的结构非聚族其它索引（myisam）：主键与其他索引排序方式一样簇族索引（innodb） ：二分查找法相似 在簇族索引下主键索引在最终的叶子节点储存的数据是对应的所有数据（传值） 其他索引最终的叶子节点储存的是主键信息 执行计划sql语句分析 语法检查 执行分析 执行sql语句 返回执行结果 explain + select 语句ID ：执行顺序select_typepossible_keys：可能会用到的索引key：实际将会使用到的索引rows：受影响的行数，将要检索多少条数据type：执行的类型，按照从优到差的顺序排列。system &gt; const &gt;eq_ref &gt; ref &gt; index &gt; all]]></content>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大型项目优化]]></title>
    <url>%2F2015%2F20151116-3.html</url>
    <content type="text"><![CDATA[问题与优化方案客户端与服务器之间的问题描述：由于客户端跟服务器之间的网络不同，导致信号传输缓慢解决：使用多线路服务器（运维处理） Apache性能问题描述：Apache在并发访问情况下，表现很一般并发：在同一秒中有多少个用户在访问，一般来说并发达到100就特别到了解决：使用负载均衡技术（服务器架构） PHP引擎性能问题描述：PHP代码整个解析效率根据引擎不一样，速度不一样解决：1、代码优化 2、更换引擎 MySQL性能问题描述：同样MySQL在并发请求比较高的情况下会故障，并发过高MySQL服务器会处于宕机状态。工具：bin/mysqlslap压力测试工具mysqlslap.exe -a -c 10 -i 10 -uroot -p123456mysqlslap.exe:Error when connecting to server:1040 Too many connections解决：由于mysql的并发请求特别高，解决该问题可以减少mysql的请求量。可以使用一个高速的存储系统储存数据，以后每次找存储系统获取数据。即使用memcache 优化具体方法 网站开发中尽量使用较小的资源文件 使用压缩技术（gzip压缩） 使用cdn加速资源文件（负载均衡） 使用缓存技术（内存缓存 redis/memcache/页面静态化） 对数据库进行优化（索引、存储引擎、表规范、sql优化） 网站架构重构采用分层模式设计，面向接口（API）编程 使用负载均衡技术（请求分流） 数据库使用读写分离或者分布式技术 对相关软件配置进行优化 硬件升级 延迟加载 项目承载的并发量单机+nginx+memcache+文件缓存+mysql数据库测试出的并发量：300 MemcacheMemcache是一款基于内存的键值对的缓存系统，具备高速读写的特性，并且支持分布式存储Memcached是一个高性能的分布式的内存对象缓存系统，使用这个缓存项目来构建大负载的网站，来分担数据库的压力，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。 概述为什么内存中的数据读写速度快计算机数据运算流程数据运算在CPU上进行的，cpu本身不能存储数据，cpu需要运算的数据来源于内存。内存本身可以存储部分数据，也可以从其他存储介质（磁盘）上读取数据 设计机制在磁盘上决定数据读写速度的是磁头定位查找数据。磁盘专属越高读写速度越快，对于MySQL优化，第一步可以将磁盘换成固态硬盘。内存是使用电流信号，所以速度特别快。 ###缓存系统只是临时存储数据的位置（非持久性数据），真实数据还是靠其他的存储介质保存。因为内存中的数据安全性不够，当由于异常服务器重启，内存中的数据会全部丢失。 分布式存储将数据拆分到不同的Memcache服务器上存储。能够解决单台Memcache服务器存储的上线 Memcache安装windows安装启动安装方法一：一次性 方法二：加载到服务memcached.exe -d install memcached.exe -d start 启动方法一：服务启动方法二：memcached.exe -d start方法三：net start &quot;memcached Server&quot; 使用Memcache是一个基于tcp协议的第三方应用。可以使用Telnet工具操作Memcache 开启Telnet客户端控制面板-&gt;程序功能-&gt;启用或关闭windows功能-&gt;勾选Telnet 使用Telnet客户端连接方式：进入cmd执行telent ip地址 端口号 Linux安装 [root@localhost libevent-2.0.20-stable]# make &amp;&amp; make install 2.1234[root@localhost libevent-2.0.20-stable]# cd ../[root@localhost memcache]# tar -zxvf memcached-1.4.20.tar.gz[root@localhost memcached-1.4.20]# ./configure --prefix=/usr/local/memcache --with-libevent=/usr/local/bibevent[root@localhost memcached-1.4.20]# make &amp;&amp; make install 常用命令memcache的基本命令 权限问题在Memcache中没有账号密码，因此Memcache中的数据不太安全。解决办法： 将Memcache服务器置于内网中，然后使用反向代理技术访问 通过服务器防火墙的配置，只允许某个IP地址可以访问在Linux可以使用hosts.allow跟hosts.deny文件控制访问权限，也叫黑白名单 123[root@localhost ~]# cd /etc/hosthost.conf hosts hosts.allow hosts.deny[root@localhost ~]# cd /etc/host.allow 常用操作命令设置数据 | set语法：12set keyname(键名) 0|1 (数据是否压缩处理) exprie(有效时间) length(字符长度)Value(具体的数据) 如果数据已经存在则修改数据 写入具体的value数据时有回车换行操作对于键名的操作一般不操作250字节一般情况数据不压缩，压缩会将数据的体积变小，但读取数据时需要进行解压操作，因此整个效率降低了（时间 &lt;==&gt; 空间）有效时间：针对Memcache中每一个键，都可以设置一个过期时间，如果时间一到，该键数据会消失，时间采用的是秒为单位，即多少秒之后过期，0表示永不过期 获取数据 | get配合set使用 添加数据 | add语法：add key 0|1 失效时间 值的长度 注意：在使用add时，如果键已经存在，则添加失败。 删除数据 | delete语法：delete key 删除所有 | flush_all语法：flush_all 项目中慎用该命令 加法操作 | incr语法：incr key number 对数据向下取整 减法操作 | decr语法：decr key number 使用decr就可以模拟秒杀系统，比如一开始设置值为100 有效期为60秒 状态操作 | stats通过查看stats主要计算命中率命中率 = get_hits/cmd_get 自然是命中率越高越好，如果命中率很低，则说明缓存效率低，需要调整缓存的数据内容，一般项目命中率能够到70%-90%就算很好。如果内存不够用，先删除快过期的，再删除不常用的，由系统底层监控 PHP操作Memcache安装扩展通过phpinfo查看php.ini所在位置，PHP的版本号，及Thread Safety。 根据以上信息选择对应版本，Enable 选择使用ts版本。否则使用nts版本， 在php.ini中通过extension_dir查看扩展包所在路径 将php_memcache.dll文件拷贝到扩展目录下修改php.ini加入配置项：extension = php_memcache.dll 重启Apache，查看phpinfo() ，是否包含Memcache扩展模块 使用Memcache 实例化memcache对象$mem = new Memcache(); 与memcache服务器建立连接$mem-&gt;connect(&#39;27.0.0.1&#39;,11211); 向memcache中写入数据$mem-&gt;set(&#39;name&#39;,&#39;uiste&#39;); 查询数据$res = $mem-&gt;get(&#39;name&#39;); 存储原理Memcache可以正常存储PHP的标量类型、符合类型、空类型，但不能存储资源类型。在Memcache中本身存储的是字符串，Memcache类的set方法在向Memcache写入数据时会先将数据序列化，在get获取数据后然后反序列化。 应用场景 session写入Memcache中 作为分布式存储系统 作为缓存系统使用]]></content>
      <tags>
        <tag>数据库优化</tag>
        <tag>服务器优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一键安装lnmp环境]]></title>
    <url>%2F2015%2F20151116-2.html</url>
    <content type="text"><![CDATA[一键安装lnmp环境1.使用putty或类似的SSH工具登陆VPS或服务器 2.下载并安装LNMP一键安装包安装LNMP执行:wget -c http://soft.vpser.net/lnmp/lnmp1.3-full.tar.gztar zxvf lnmp1.3-full.tar.gzcd lnmp1.3-full./install.sh lnmp默认安装lnmp可不写，如需要安装LNMPA或LAMP，将./install.sh 后面的参数替换为lnmpa或lamp即可按上述命令执行后，会出现如下提示lnmp-1.3-install-1.png需要设置MySQL的root密码（不输入直接回车将会设置为root）如果输入有错误需要删除时，可以按住Ctrl再按Backspace键进行删除。输入后回车进入下一步，如下图所示lnmp-1.3-install-2.png询问是否需要启用MySQL InnoDB，InnoDB引擎默认为开启，一般建议开启，直接回车或输入 y ，如果确定确实不需要该引擎可以输入 n，输入完成，回车进入下一步选择MySQL版本，目前提供了较多版本的MySQL和MariaDB，需要注意的是MySQL 5.6,5.7及MariaDB 10必须在1G以上内存的更高配置上才能选择lnmp-1.3-install-3.png输入对应MySQL或MariaDB版本前面的序号，回车进入下一步，选择PHP版本：注意：选择PHP7等高版本时需要自行确认是否与自己的程序兼容lnmp-1.3-install-4.png输入要选择的PHP版本的序号，回车进入下一步，选择是否安装内存优化lnmp-1.3-install-5.png可以选择不安装、Jemalloc或TCmalloc，输入对应序号回车，直接回车为默认为不安装。如果是LNMPA或LAMP的话还会提示“Please enter Administrator Email Address:”，需要设置管理员邮箱，该邮箱会在报错时显示在错误页面上lnmp-1.3-install-6.png再选择Apache版本lnmp-1.3-install-7.png按提示输入对应版本前面的数字序号，回车。提示”Press any key to install…or Press Ctrl+c to cancel”后，按回车键确认开始安装。LNMP脚本就会自动安装编译Nginx、MySQL、PHP、phpMyAdmin、Zend Optimizer这几个软件。安装时间可能会几十分钟到几个小时不等，主要是机器的配置网速等原因会造成影响 3.安装完成如果显示Nginx: OK，MySQL: OK，PHP: OKlnmp-1.3-install-sucess.png并且Nginx、MySQL、PHP都是running，80和3306端口都存在，并提示Install lnmp V1.3 completed! enjoy it.的话，说明已经安装成功 LNMP状态管理命令LNMP状态管理命令：LNMP 1.2状态管理: lnmp {start|stop|reload|restart|kill|status}LNMP 1.2各个程序状态管理: lnmp {nginx|mysql|mariadb|php-fpm|pureftpd} {start|stop|reload|restart|kill|status}LNMP 1.1状态管理： /root/lnmp {start|stop|reload|restart|kill|status}Nginx状态管理：/etc/init.d/nginx {start|stop|reload|restart}MySQL状态管理：/etc/init.d/mysql {start|stop|restart|reload|force-reload|status}Memcached状态管理：/etc/init.d/memcached {start|stop|restart}PHP-FPM状态管理：/etc/init.d/php-fpm {start|stop|quit|restart|reload|logrotate}PureFTPd状态管理： /etc/init.d/pureftpd {start|stop|restart|kill|status}ProFTPd状态管理： /etc/init.d/proftpd {start|stop|restart|reload} LNMPA状态管理命令：LNMPA 1.2状态管理: lnmp {start|stop|reload|restart|kill|status}LNMPA 1.2各个程序状态管理: lnmp {httpd|mysql|mariadb|pureftpd} {start|stop|reload|restart|kill|status}LNMPA1.1状态管理： /root/lnmpa {start|stop|reload|restart|kill|status}Nginx状态管理：/etc/init.d/nginx {start|stop|reload|restart}MySQL状态管理：/etc/init.d/mysql {start|stop|restart|reload|force-reload|status}Memcached状态管理：/etc/init.d/memcached {start|stop|restart}PureFTPd状态管理： /etc/init.d/pureftpd {start|stop|restart|kill|status}ProFTPd状态管理： /etc/init.d/proftpd {start|stop|restart|reload}Apache状态管理：/etc/init.d/httpd {start|stop|restart|graceful|graceful-stop|configtest|status} LAMP状态管理命令：LAMP 1.2状态管理: lnmp {start|stop|reload|restart|kill|status}LAMP 1.2各个程序状态管理: lnmp {httpd|mysql|mariadb|pureftpd} {start|stop|reload|restart|kill|status} LNMP相关软件安装目录Nginx 目录: /usr/local/nginx/MySQL 目录 : /usr/local/mysql/MySQL数据库所在目录：/usr/local/mysql/var/MariaDB 目录 : /usr/local/mariadb/MariaDB数据库所在目录：/usr/local/mariadb/var/PHP目录 : /usr/local/php/PHPMyAdmin目录 : 0.9版本为/home/wwwroot/phpmyadmin/ 1.0及以后版本为 /home/wwwroot/default/phpmyadmin/ 强烈建议将此目录重命名为其不容易猜到的名字。phpmyadmin可自己从官网下载新版替换。默认网站目录 : 0.9版本为 /home/wwwroot/ 1.0及以后版本为 /home/wwwroot/default/Nginx日志目录：/home/wwwlogs//root/vhost.sh添加的虚拟主机配置文件所在目录：/usr/local/nginx/conf/vhost/PureFtpd 目录：/usr/local/pureftpd/PureFtpd web管理目录： 0.9版为/home/wwwroot/default/ftp/ 1.0版为 /home/wwwroot/default/ftp/Proftpd 目录：/usr/local/proftpd/Redis 目录：/usr/local/redis/ LNMP相关配置文件位置Nginx主配置(默认虚拟主机)文件：/usr/local/nginx/conf/nginx.conf添加的虚拟主机配置文件：/usr/local/nginx/conf/vhost/域名.confMySQL配置文件：/etc/my.cnfPHP配置文件：/usr/local/php/etc/php.iniphp-fpm配置文件：/usr/local/php/etc/php-fpm.confPureFtpd配置文件：/usr/local/pureftpd/pure-ftpd.confPureFtpd MySQL配置文件：/usr/local/pureftpd/pureftpd-mysql.confProftpd配置文件：/usr/local/proftpd/etc/proftpd.conf 1.2及之前版本为/usr/local/proftpd/proftpd.confProftpd 用户配置文件：/usr/local/proftpd/etc/vhost/用户名.confRedis 配置文件：/usr/local/redis/etc/redis.conf ##LNMPA相关目录文件位置Apache目录：/usr/local/apache/Apache配置文件：/usr/local/apache/conf/httpd.confApache虚拟主机配置文件目录：/usr/local/apache/conf/vhost/Apache默认虚拟主机配置文件：/usr/local/apache/conf/extra/httpd-vhosts.conf虚拟主机配置文件名称：/usr/local/apache/conf/vhost/域名.conf]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上使用brew安装MongoDB]]></title>
    <url>%2F2015%2F20151116-1.html</url>
    <content type="text"><![CDATA[Mac上使用brew安装MongoDBMongoDB的安装有好多种安装方法，有直接使用HomeBrew方式，也有源码编译方式。这里使用最简单的HomeBrew。 使用brew安装MongoDB,首先需要确保你的电脑上安装过了HomeBrew,在终端输入如下命令:ruby -e “$(curl -fsSkL raw.github.com/mxcl/homebrew/go)”安装HomeBrew。(如果已经安装过了HomeBrew,可以跳过这一步) 安装完brew后先更新一下:uiste:~ uiste$ brew update 然后就是安装MongoDB:uiste:~ uiste$ brew install mongodb等待几分钟,如果终端显示以下提示,说明MongoDB安装成功。 启动MongoDB,在命令行界面输入:uiste:~ uiste$ mongod --config /usr/local/etc/mongod.conf如果没有报错,说明mongod服务已经成功启动 使用mongo命令连接数据库,打开一个新的命令行窗口,然后输入mongo:uiste:~ uiste$ mongo 至此,MongoDB数据库安装和连接就成功了.]]></content>
      <tags>
        <tag>数据库优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 开发记录2]]></title>
    <url>%2F2015%2F20151115-1.html</url>
    <content type="text"><![CDATA[Migrations数据迁移创建数据表12345678910111213141516171819uiste:blog uiste$ php artisan make:migration create_links_tableCreated Migration: 2015_11_15_033430_create_links_table---public function up()&#123; Schema::create(&apos;links&apos;, function (Blueprint $table) &#123; $table-&gt;engine = &apos;MyISAM&apos;; $table-&gt;increments(&apos;link_id&apos;); $table-&gt;string(&apos;link_name&apos;)-&gt;default(&apos;&apos;)-&gt;comment(&apos;名称&apos;); $table-&gt;string(&apos;link_title&apos;)-&gt;default(&apos;&apos;)-&gt;comment(&apos;标题&apos;); $table-&gt;string(&apos;link_url&apos;)-&gt;default(&apos;&apos;)-&gt;comment(&apos;链接&apos;); $table-&gt;integer(&apos;link_order&apos;)-&gt;default(10)-&gt;comment(&apos;排序&apos;); &#125;);&#125;---Migration table created successfully.Migrated: 2015_11_15_033430_create_links_table 数据填充1234567891011121314151617181920212223242526272829303132uiste:blog uiste$ php artisan make:seeder LinksTableSeederSeeder created successfully.---public function run()&#123; $data = [ [ &apos;link_name&apos; =&gt; &apos;uiste技术博客&apos;, &apos;link_title&apos;=&gt; &apos;专注于技术分享，实战经验总结&apos;, &apos;link_url&apos; =&gt; &apos;http://blog.uiste.com&apos;, &apos;link_order&apos;=&gt; 1, ], [ &apos;link_name&apos; =&gt; &apos;uiste生活博客&apos;, &apos;link_title&apos;=&gt; &apos;分享生活，欣赏一切美好的事物&apos;, &apos;link_url&apos; =&gt; &apos;http://www.uiste.com&apos;, &apos;link_order&apos;=&gt; 2, ] ]; DB::table(&apos;links&apos;) -&gt; insert($data);&#125;---public function run()&#123; $this-&gt;call(LinksTableSeeder::class);&#125;---uiste:blog uiste$ php artisan db:seedSeeded: LinksTableSeeder]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 开发记录1]]></title>
    <url>%2F2015%2F20151112-3.html</url>
    <content type="text"><![CDATA[phpstrom快捷键： command + E 查看最近打开的文件或项目 command + shift + V 选择粘贴最近的剪切板内容 command + D 复制粘贴选中的文本 command + 1 切换窗口 alt + 上下方向键 调到上下函数 alt + 左右方向键 导航标签切换 command + shift + N 根据文件名查找 command + shift + alt + N 根据函数名查找 /** + Enter 自动生成注释 command + alt + L 格式化代码 command + R 替换 command + shift + R 全局替换 shift + Enter 智能跳到下一行 command + shift + U 大小写 表单提交相关视图引入静态资源文件：1&lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123;asset(&apos;resources/views/admin/style/css/ch-ui.admin.css&apos;)&#125;&#125;&quot;&gt; 控制器分配视图：return view(&#39;admin.login&#39;);控制器跳转：return redirect(&#39;admin/index&#39;); 在使用验证码、QQ登录、七牛存储、支付宝等第三方接口的时候，用到原生session的时候，由于laravel自有session的封装，无办法正常调用解决方法：在入口文件开启sessionsession_start(); 模板文件调用控制器方法：1&#123;&#123;url(&apos;admin/code&apos;)&#125;&#125; 验证表单是否有数据提交：Input::all() 等价于 ThinkPHP中的 IS_POST打印并终止程序继续运行：dd(); 等价于 ThinkPHP中的 dump();exit; csrf防护报错：TokenMismatchException in VerifyCsrfToken.php line 67: 解决：1&#123;&#123;csrf _ field()&#125;&#125; 登录成功session保存用户信息：session([&#39;user&#39;=&gt;$user]); 数据验证123456789101112131415161718// 定义验证规则$rules = [ 'password' =&gt; 'required|between:6,20|confirmed',];// 提示信息$message = [ 'password.required' =&gt; '新密码不能为空', 'password.between' =&gt; '新密码必须在6-20位之间', 'password.confirmed'=&gt; '新密码和确认密码不一致',];$validator = Validator::make($input,$rules,$message);if($validator-&gt;passes())&#123;//验证规则通过 echo 'ok!';&#125;else&#123; $validator-&gt;errors()-&gt;all();//测试打印错误信息 return back()-&gt;withErrors($validator);&#125;``` {{csrf_field()}}@if(count($errors)) @foreach($errors-&gt;all() as $error) @endforeach@endif *新密码： 新密码6-20位 *确认密码： 再次输入密码 12345678910111213141516171819202122232425## AJAX实现分类排序弹出窗插件：`layer.layui.com`文本编辑器：ueditor上传组件： `www.uploadify.com`树形分类（Model）```php// 树形分类public function getTree($data,$field_name,$field_id=&apos;id&apos;,$field_pid=&apos;pid&apos;,$pid=0)&#123; $tree = array(); foreach($data as $k =&gt; $v)&#123; if($v-&gt;$field_pid == $pid)&#123; $tree[] = $data[$k]; $data[$k][&apos;_&apos;.$field_name] = $data[$k][$field_name]; foreach($data as $m =&gt; $n)&#123; if($n-&gt;$field_pid == $v-&gt;$field_id)&#123; $data[$m][&apos;_&apos;.$field_name] = &apos;┣━ &apos;.$data[$m][$field_name]; $tree[] = $data[$m]; &#125; &#125; &#125; &#125; return $tree;&#125; 更新分类排序（view）1234567891011121314 &lt;input type="text" onchange="changeOrder(this,&#123;&#123;$v-&gt;cate_id&#125;&#125;)" name="ord[]" value="&#123;&#123;$v-&gt;cate_order&#125;&#125;"&gt; //ajax &lt;script type="text/javascript"&gt; function changeOrder(obj,cate_id)&#123; var cate_order = $(obj).val(); $.post("&#123;&#123;url('admin/cate/changeorder')&#125;&#125;",&#123;'_token':'&#123;&#123;csrf_token()&#125;&#125;','cate_id':cate_id,'cate_order':cate_order&#125;,function(data)&#123; if(data.status == 0)&#123; layer.msg(data.msg,&#123;icon:6&#125;); &#125;else&#123; layer.msg(data.msg,&#123;icon:5&#125;); &#125; &#125;); &#125;&lt;/script&gt; 更新分类排序（Controller）1234567891011121314151617public function changeOrder()&#123; $input = Input::all(); $cate = Category::find($input['cate_id']); $cate-&gt;cate_order = $input['cate_order']; if($cate-&gt;update())&#123; $data = [ 'status' =&gt; 0, 'msg' =&gt; '分类排序更新成功', ]; &#125;else&#123; $data = [ 'status' =&gt; 1, 'msg' =&gt; '分类排序更新失败,请稍后重试...', ]; &#125; return $data;&#125; 去除不需要的字段：$input = Input::except(&#39;_token&#39;)guarded 除了什么字段，其它都是可以填充的：protected $guarded = [];fillable 可以使用create方法填充的字段 更新分类字段update 方法使用put方式接受字段view代码12&lt;form action=&quot;&#123;&#123;url(&apos;admin/category&apos;.$cate_info-&gt;cate_id)&#125;&#125;&quot; method=&quot;post&quot;&gt;&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; 刷新页面：location.href = location.href; 图片上传uploadify插件12345678910111213141516171819202122232425262728&lt;script src="&#123;&#123;asset('resources/org/uploadify/jquery.uploadify.min.js')&#125;&#125;" type="text/javascript"&gt;&lt;/script&gt;&lt;link rel="stylesheet" type="text/css" href="&#123;&#123;asset('resources/org/uploadify/uploadify.css')&#125;&#125;"&gt;&lt;script type="text/javascript"&gt; &lt;?php $timestamp = time();?&gt; $(function() &#123; $('#file_upload').uploadify(&#123; 'buttonText' : '图片上传', 'formData' : &#123; 'timestamp' : '&lt;?php echo $timestamp;?&gt;', '_token' : '&#123;&#123;csrf_token()&#125;&#125;' &#125;, 'swf' : "&#123;&#123;asset('resources/org/uploadify/uploadify.swf')&#125;&#125;", 'uploader' : "&#123;&#123;url('admin/upload')&#125;&#125;", 'onUploadSuccess' : function(file,data,response)&#123; $('input[name=art_thumb]').val(data); $('#art_thumb_img').attr('src','/'+data); &#125;, &#125;); &#125;);&lt;/script&gt;&lt;style&gt; .uploadify&#123;display:inline-block;&#125; .uploadify-button&#123;border:none; border-radius:5px; margin-top:8px;&#125; table.add_tab tr td span.uploadify-button-text&#123;color: #FFF; margin:0;&#125;&lt;/style&gt;&lt;input id="file_upload" name="file_upload" type="file" multiple="true"&gt;&lt;img src="" alt="" id="art_thumb_img" style="max-width: 350px;max-height: 100px;"&gt; 图片上传12345678910111213// 图片上传public function upload()&#123; $file = Input::file('Filedata'); if($file-&gt;isValid())&#123; // 上传文件的后缀 $entension = $file-&gt;getClientOriginalExtension(); // 移动文件并重命名 $newName = date('YmdHis').mt_rand(100,999).'.'.$entension; $path = $file-&gt;move(base_path().'/uploads',$newName); $filepath = 'uploads/'.$newName; return $filepath; &#125;&#125; 分页12345$data = Article::orderBy(&apos;art_id&apos;,&apos;desc&apos;)-&gt;paginate(3);return view(&apos;admin.article.list&apos;,compact(&apos;data&apos;));&lt;div class=&quot;page_list&quot;&gt; &#123;&#123;$data-&gt;render()&#125;&#125;&lt;/div&gt;]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 开发前奏]]></title>
    <url>%2F2015%2F20151112-2.html</url>
    <content type="text"><![CDATA[目录结构 配置选项 php.iniextension=php_openssl.dllextension=php_mbstring.dllextension=php_pdo_mysql.dll 修改默认首页 server.php =&gt; index.php DirectoryIndex server.php 修改入口文件：DocumentRoot &quot;.../public&quot; 需要服务器支持修改入口文件或者子目录可以绑定域名 将伪静态配置文件.htaccess移动到项目根目录 基础路由• Route::get($uri, $callback);• Route::post($uri, $callback);• Route::put($uri, $callback);• Route::patch($uri, $callback);• Route::delete($uri, $callback);• Route::options($uri, $callback);• Route::match([‘get’, ‘post’], ‘/‘, $callback);• Route::any(‘foo’, $callback); 参数限定1234567891011Route::get(&apos;user/&#123;name&#125;&apos;, function($name)&#123; //&#125;)-&gt;where(&apos;name&apos;, &apos;[A-Za-z]+&apos;);Route::get(&apos;user/&#123;id&#125;/&#123;name&#125;&apos;, function($id, $name)&#123; //&#125;)-&gt;where([&apos;id&apos; =&gt; &apos;[0-9]+&apos;, &apos;name&apos; =&gt; &apos;[a-z]+&apos;]) postman插件路由参数不能使用-,需要使用_进行替换 基础控制器laravel 控制器没有像ThinkPHP 那种参数访问控制器的方法，所有的控制器访问都需要通过路由进行设置 手动创建路由与控制器相对繁琐 使用Atrisan方法创建 12uiste:blog uiste$ php artisan make:controller HomeControllerController created successfully. 控制器分文件夹 命名空间路由使用 \ 高级路由路由命名123456Route::get(&apos;/index&apos;, [&apos;as&apos;=&gt;&apos;index&apos;,function()&#123; echo route(&apos;index&apos;);&#125;]);//简单的命名方法---http://www.blog.com/index 控制路由命名Route::get(&#39;/index&#39;, [&#39;uses&#39;=&gt;&#39;Admin\IndexController@index&#39;,&#39;as&#39;=&gt;&#39;index&#39;]);Route::get(&#39;/index&#39;, &#39;Admin\IndexController@index&#39;)-&gt;name(&#39;index&#39;);return route(&#39;index&#39;);//控制器调用 路由分组将相同的路由放在一起，便于统一的管理12Route::get(&apos;admin/index&apos;, &apos;Admin\IndexController@index&apos;)-&gt;name(&apos;index&apos;);Route::get(&apos;admin/login&apos;, &apos;Admin\IndexController@login&apos;)-&gt;name(&apos;login&apos;); 使用group对平台及命名空间进行分组方式如下：1234Route::group([&apos;prefix&apos;=&gt;&apos;admin&apos;,&apos;namespace&apos;=&gt;&apos;Admin&apos;],function()&#123; Route::get(&apos;index&apos;, &apos;IndexController@index&apos;)-&gt;name(&apos;index&apos;); Route::get(&apos;login&apos;, &apos;IndexController@login&apos;)-&gt;name(&apos;login&apos;);&#125;); Terminal中显示路由列表uiste:blog uiste$ php artisan route:list RESTfun 资源路由控制器资源路由设置，优点：一条路由生成多种路由规则Route::resource(&#39;article&#39;,&#39;ArticleController&#39;); Middleware中间件HTTP 中间件提供一个方便的机制来过滤进入应用程序的 HTTP 请求。Laravel 框架已经内置一些中间件，包括维护、身份验证、CSRF 保护，等等。所有的中间件都位于 app/Http/Middleware 目录内。 自定义路由中间件app\Htp\Kernel.php kernel.php中定义中间件名 1234protected $routeMiddleware = [ &apos;admin.login&apos; =&gt; \App\Http\Middleware\AdminLogin::class,];//后台登录中间件，AdminLogin中间件名 使用Artisan创建中间件uiste:blog uiste$ php artisan make:middleware AdminLogin routes.php定义路由规则 12345Route::group([&apos;middleware&apos; =&gt; [&apos;web&apos;,&apos;admin.login&apos;]], function () &#123; Route::get(&apos;test&apos;,function()&#123; echo &apos;test a middleware&apos;; &#125;);&#125;); 书写中间件条件 123456public function handle($request, Closure $next)&#123; if(session(&apos;admin&apos;)) return redirect(&apos;admin/login&apos;); return $next($request);&#125; 使用web中间件，才能使用session 视图方法一：return view(&#39;greeting&#39;)-&gt;with(&#39;name&#39;, &#39;Victoria&#39;); 使用：$name; 可以多个with一同使用 方法二：return = view(&#39;greeting&#39;, $data); 方法三：return view(&#39;greeting&#39;,compact(&#39;data&#39;,&#39;title&#39;)); 模板引擎blade模板引擎 基础用法12345• &#123;&#123; $name &#125;&#125;• @&#123;&#123; $name &#125;&#125; 使用@符屏蔽语法解析• &#123;&#123; $name or &apos;Default&apos; &#125;&#125; 使用or设置默认值• &#123;&#123; isset($name) ? $name : &apos;Default&apos; &#125;&#125;• &#123;!! $str !!&#125; 算感叹号代表htmlspecialchars_decode() Blade模板引擎 流程控制有开始标志就要有结束标志• @if12345@if($data[&apos;score&apos;]&lt;60) 不及格 @else 及格 @endif • @unless 除非，用法同if• @for• @foreach1234@foreach($data[&apos;article&apos;] as $v) &#123;&#123; $v &#125;&#125; @endforeach &#125; • @forelse 是foreach的补充12345@forelse($data[&apos;article&apos;] as $v) $v @empty 没有数据 @endforelse • @while以上基本流程控制可以嵌套 Blade模板引擎 子视图• @include(common.header)• @include(common.name’, [‘some’ =&gt; ‘data’])• @extends(‘layouts.master’)• @yield(‘content’)• @section(‘content’)12345头文件@section(&apos;content&apos;)&lt;p&gt;父类模板文件中的内容&lt;/p&gt;@show脚文件 子视图文件12345@extends(&apos;layouts.home&apos;)@section(&apos;content&apos;) @parent 替换的内容 @section(&apos;content&apos;) 读取配置项echo config(&#39;database.connections.mysql.prefix&#39;);echo config(&#39;app.debug&#39;); 连接数据库12$pdo = DB :: connection()-&gt;getPdo();dd($pdo); //dd函数打印并终止程序继续运行 数据表操作• DB::table(‘user’)-&gt;get();• DB::table(‘user’)-&gt;where(‘user’,1)-&gt;get(); 模型创建• php artisan make:model User数据表操作• protected $table=”user”;• protected $primaryKey = ‘user_id’;• public $timestamps = false; //禁止默认时间戳]]></content>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 扩展工具]]></title>
    <url>%2F2015%2F20151112-1.html</url>
    <content type="text"><![CDATA[添加high一下效果很赞，整个页面渐进式摇摆，摇摆，还有音乐 在 Hexo\themes\next\layout_partials\header.swig 中的 ul 标签加入如下 li 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 &lt;li class="menu-item menu-item-search"&gt; &lt;a title="把这个链接拖到你的Chrome收藏夹工具栏中" href='javascript:(function() &#123; function c() &#123; var e = document.createElement("link"); e.setAttribute("type", "text/css"); e.setAttribute("rel", "stylesheet"); e.setAttribute("href", f); e.setAttribute("class", l); document.body.appendChild(e) &#125; function h() &#123; var e = document.getElementsByClassName(l); for (var t = 0; t &lt; e.length; t++) &#123; document.body.removeChild(e[t]) &#125; &#125; function p() &#123; var e = document.createElement("div"); e.setAttribute("class", a); document.body.appendChild(e); setTimeout(function() &#123; document.body.removeChild(e) &#125;, 100) &#125; function d(e) &#123; return &#123; height : e.offsetHeight, width : e.offsetWidth &#125; &#125; function v(i) &#123; var s = d(i); return s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r &#125; function m(e) &#123; var t = e; var n = 0; while (!!t) &#123; n += t.offsetTop; t = t.offsetParent &#125; return n &#125; function g() &#123; var e = document.documentElement; if (!!window.innerWidth) &#123; return window.innerHeight &#125; else if (e &amp;&amp; !isNaN(e.clientHeight)) &#123; return e.clientHeight &#125; return 0 &#125; function y() &#123; if (window.pageYOffset) &#123; return window.pageYOffset &#125; return Math.max(document.documentElement.scrollTop, document.body.scrollTop) &#125; function E(e) &#123; var t = m(e); return t &gt;= w &amp;&amp; t &lt;= b + w &#125; function S() &#123; var e = document.createElement("audio"); e.setAttribute("class", l); e.src = i; e.loop = false; e.addEventListener("canplay", function() &#123; setTimeout(function() &#123; x(k) &#125;, 500); setTimeout(function() &#123; N(); p(); for (var e = 0; e &lt; O.length; e++) &#123; T(O[e]) &#125; &#125;, 15500) &#125;, true); e.addEventListener("ended", function() &#123; N(); h() &#125;, true); e.innerHTML = " &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;"; document.body.appendChild(e); e.play() &#125; function x(e) &#123; e.className += " " + s + " " + o &#125; function T(e) &#123; e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)] &#125; function N() &#123; var e = document.getElementsByClassName(s); var t = new RegExp("\\b" + s + "\\b"); for (var n = 0; n &lt; e.length; ) &#123; e[n].className = e[n].className.replace(t, "") &#125; &#125; var e = 30; var t = 30; var n = 350; var r = 350; var i = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3"; var s = "mw-harlem_shake_me"; var o = "im_first"; var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"]; var a = "mw-strobe_light"; var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css"; var l = "mw_added_css"; var b = g(); var w = y(); var C = document.getElementsByTagName("*"); var k = null; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; if (E(A)) &#123; k = A; break &#125; &#125; &#125; if (A === null) &#123; console.warn("Could not find a node of the right size. Please try a different page."); return &#125; c(); S(); var O = []; for (var L = 0; L &lt; C.length; L++) &#123; var A = C[L]; if (v(A)) &#123; O.push(A) &#125; &#125;&#125;)() '&gt;High&lt;/a&gt; &lt;/li&gt; 站内搜索]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 队列应用]]></title>
    <url>%2F2015%2F20151111-8.html</url>
    <content type="text"><![CDATA[Laravel常用功能-队列应用]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 缓存使用]]></title>
    <url>%2F2015%2F20151111-7.html</url>
    <content type="text"><![CDATA[Laravel常用功能-错误与日志]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 邮件发送]]></title>
    <url>%2F2015%2F20151111-6.html</url>
    <content type="text"><![CDATA[Laravel常用功能-邮件发送]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 文件上传]]></title>
    <url>%2F2015%2F20151111-5.html</url>
    <content type="text"><![CDATA[laravel常用功能-文件上传]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据迁移与数据填充]]></title>
    <url>%2F2015%2F20151111-4.html</url>
    <content type="text"><![CDATA[数据迁移数据填充]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Artisan简介]]></title>
    <url>%2F2015%2F20151111-3.html</url>
    <content type="text"><![CDATA[Artisan简介由Symfony Console 组件驱动 Artisan基本用法 查看所有可用的Artisan的命令（list）php artisanphp artisan list 查看命令的帮助信息（help）php artisan help migrate 创建Student控制器、模型、中间件123456uiste:laravel uiste$ php artisan make:controller StudentControllerController created successfully.uiste:laravel uiste$ php artisan make:model StudentModel created successfully.uiste:laravel uiste$ php artisan make:middleware ActivityMiddleware created successfully. 命名应用程序php artisan app:name uiste Actisan主要作用创建好已经构建好模板的代码文件及其它高级用法 Laravel 用户认证功能Laravel中生成Auth所需文件12uiste:laravel uiste$ php artisan make:authAuthentication scaffolding generated successfully. routs/web.php 文件中，生成如下代码 12Auth::routes();Route::get(&apos;/home&apos;,&apos;HomeController@index&apos;); 生成resources/views/auth/login.blade.php &amp; register.blade.php 修改resources/views/layouts/app.blade.php文件 1234&lt;link href=&quot;/css/app.css&quot; rel=&apos;stylesheet&apos;&gt;改为：&lt;link href=&quot;&#123;asset(&apos;css/app.css&apos;)&#125;&quot; rel=&apos;stylesheet&apos;&gt;&lt;script src=&quot;/js/app.js&#125;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;&#123;asset(&apos;js/app.js&apos;)&#125;&quot;&gt;&lt;/script&gt; 路由文件：vendor/laravel/src/Routing/Router.php-&gt;Auth()方法中 生成数据库中所需要的表所需文件在：database/migrations中查找操作如下：1234uiste:laravel uiste$ php artisan migrateMigration table created successfully.Migrated: 2014_10_12_000000_create_users_tableMigrated: 2014_10_12_100000_create_password_resets_table 数据库中生成：migrations 迁移表password_resets 密码重置表users 用户表 配置选项.evn 文件修改数据库配置项]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Composer安装]]></title>
    <url>%2F2015%2F20151111-2.html</url>
    <content type="text"><![CDATA[全局安装Composer1.验证环境PHP环境1234uiste:Downloads uiste$ php -vPHP 5.6.24 (cli) (built: Aug 8 2015 16:58:37) Copyright (c) 1997-2015 The PHP GroupZend Engine v2.6.0, Copyright (c) 1998-2015 Zend Technologies 2.监测包安装文件uiste:Downloads uiste$ php composer.phar3.移动文件到全局目录uiste:Downloads uiste$ sudo mv composer.phar /usr/local/bin/composer若没有访问权限 1234567&gt;uiste:Downloads uiste$ composer&gt;-bash: /usr/local/bin/composer: Permission denied&gt;uiste:Downloads uiste$ cd /usr/local/bin/&gt;uiste:bin uiste$ ls -l&gt;....&gt;uiste:bin uiste$ sudo chmod -R 755 composer&gt; 4.切换到任意目录验证uiste:~ uiste$ composer 中国全量镜像查看当前的镜像地址12uiste:~ uiste$ composer config -g repo.packagist&#123;&quot;type&quot;:&quot;composer&quot;,&quot;url&quot;:&quot;https:\/\/packagist.phpcomposer.com&quot;&#125; uiste:~ uiste$ composer config -g repo.packagist composer https://packagist.phpcomposer.com 使用Composer主要命令搜索：search展示：show声明依赖：require安装：install更新：update uiste:test uiste$ composer search monolog123456789101112131415161718uiste:test uiste$ vim composer.json&#123; &quot;name&quot;: &quot;imooc/test&quot;, &quot;description&quot;: &quot;test composer&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;uiste&quot;, &quot;email&quot;: &quot;798407452@qq.com&quot; &#125; ], &quot;require&quot;: &#123; &quot;monolog/monolog&quot;:&quot;1.21.*&quot;, &quot;symfony/http-foundation&quot;: &quot;^3.1&quot; &#125;&#125;uiste:test uiste$ composer installuiste:test uiste$ composer require symfony/http-foundation Composer安装laravel框架方法一通过 composer Create-Project命令安装Laravelcomposer create-project laravel/laravel blog --prefer-dist[别名] 方法二laravel安装器12composer global require &quot;laravel/installer&quot;laravel new blog 检查安装状态12uiste:test uiste$ laravelLaravel Installer version 1.3.3 下载laravel12uiste:test uiste$ laravel new blogCrafting application...]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux LAMP环境搭建]]></title>
    <url>%2F2015%2F20151111-1.html</url>
    <content type="text"><![CDATA[软件安装与卸载软件安装 .rpm格式：二进制格式，相对于window下的.exe文件 .tar.gz：二进制源码包，需要借助于gcc 编译器进行源码编译安装 yum：自动解决依赖问题安装软件查询 基本语法：rpm -qa -q(query) 表示查询 -a(all) 表示所有 查询指定软件：rpm -qa | grep 软件名称 | 管道，可以针对前面的结果进行二次筛选 grep 匹配 卸载软件 基本语法：rpm -e 软件名称 (软件名称可以只选到软件名称) 软件安装 基本语法：rpm -ivh (软件名称) -i ：表示安装 vh：显示进度条 注意：镜像文件被正确选中，已连接的状态 cd /media/CentOS_6.5_Final/Packages/ 进入媒体文件夹（存储了很多安装包）源码编译安装 先解压 进入安装目录 编译 安装Apache 安装 进入LAMP安装目录 使用tar命令实现解压功能 tar -zxvf httpd-2.2.11.tar.gz 进入到解压目录并编译(需安装gcc) cd httpd-2.2.11 ./configure --prefix=/usr/local/apache --enable-so 安装 make &amp;&amp; make install 配置加载PHP vim /usr/local/apache/conf/httpd.conf AddType application/x-httpd-php .php启动Apache，并测试Apache 进入到Apache的bin目录启动Apache：[root@localhost usr]# cd /usr/local/apache/bin 修改Apache配置文件：[root@localhost bin]# vim ../conf/httpd.conf 开启并修改域名：ServerName localhost:80 重启Apache： 测试 关闭防火墙：service iptables stop；服务器重启之后防火墙会再次开启。实际应用场景可修改编辑（/etc/sysconfig/iptables文件,开启SSH端口22，或tcp80，数据库3306可以加上如下内容：-A RH-Firewall-1-INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT） 直接输入IP地址，测试 在命令行下使用curl工具：/usr/bin/curl http:127.0.0.1 通过端口的方式：netstat -tunple|grep 80 通过进程方式：ps - aux | grep httpd 报错排错：1234567891011121314[root@localhost bin]# ./apachectl start(98)Address already in use: make_sock: could not bind to address [::]:80(98)Address already in use: make_sock: could not bind to address 0.0.0.0:80no listening sockets available, shutting downUnable to open logs[root@localhost bin]# netstat -tunple|grep 80tcp 0 0 :::80 :::* LISTEN 0 59332 22963/httpdudp 0 0 :::57780 :::* 29 12263 1361/rpc.statdudp 0 0 fe80::20c:29ff:fe04:2b3c:123 :::* 0 13141 1573/ntpd[root@localhost bin]# pkill httpd[root@localhost bin]# netstat -tunple|grep 80udp 0 0 :::57780 :::* 29 12263 1361/rpc.statdudp 0 0 fe80::20c:29ff:fe04:2b3c:123 :::* 0 13141 1573/ntpd[root@localhost bin]# ./apachectl start PHP安装安装zlib压缩库 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf zlib-1.2.5.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd zlib-1.2.5` 2. `[root@localhost zlib-1.2.5]# ./configure` 安装1. `[root@localhost zlib-1.2.5]# make &amp;&amp; make install` 安装libxml2 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf libxml2-2.7.2.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd libxml2-2.7.2` 2. `[root@localhost libxml2-2.7.2]# ./configure --prefix=/usr/local/libxml2 -without-zlib` 安装1. `[root@localhost libxml2-2.7.2]# make &amp;&amp; make install` 安装jpeg8 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf jpegsrc.v8b.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd jpeg-8b/` 2. `[root@localhost jpeg-8b]# ./configure --prefix=/usr/local/jpeg --enable-shared --enable-static` 安装1. `[root@localhost jpeg-8b]# make &amp;&amp; make install` 安装libpng 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf libpng-1.4.3.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd libpng-1.4.3` 2. `[root@localhost libpng-1.4.3]# ./configure` 安装1. `[root@localhost libpng-1.4.3]# make &amp;&amp; make install` 安装freetype（字体库） 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf freetype-2.4.1.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd freetype-2.4.1` 2. `[root@localhost freetype-2.4.1]# ./configure --prefix=/usr/local/freetype` 安装1. `[root@localhost freetype-2.4.1]# make &amp;&amp; make install` 安装GD库 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zxvf gd-2.0.35.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd gd-2.0.35` 2. `[root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd --with-jpeg=/usr/local/jpeg/ --with-png --with-zlib --with-freetype=/usr/local/freetype` 安装1. `[root@localhost gd-2.0.35]# make &amp;&amp; make install` 安装PHP 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令实现解压功能1. `[root@localhost LAMP]# tar -zvxf php-5.3.28.tar.gz` 进入到解压目录并编译(需安装gcc)1. `[root@localhost LAMP]# cd php-5.3.28` 2. `[root@localhost php-5.3.28]#./configure --prefix=/usr/local/php --with-mysql=mysqlnd --with-pdo-mysql=mysqlnd --with-mysqli=mysqlnd --with-freetype-dir=/usr/local/freetype --with-gd=/usr/local/gd --with-zlib --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg --with-png-dir --enable-mbstring=all --enable-mbregex --enable-shared --with-config-file-path=/usr/local/php/etc --with-curlwrappers --with-apxs2=/usr/local/apache/bin/apxs` 安装1. `[root@localhost php-5.3.28]# make &amp;&amp; make install` 安装MySQLMySQL使用二进制包安装，已经安装过了的（安装前终止msyqld进程：pkill mysqld） 进入LAMP安装目录1. `[root@localhost home]# cd /home/LAMP` 使用tar命令，使用C指定解压目录1. `[root@localhost LAMP]# tar -zxvf mysql-5.5.38-linux2.6-i686.tar.gz -C /usr/local` 进入到解压目录/usr/local下1. `[root@localhost LAMP]# cd /usr/local` 创建软连接1. `[root@localhost local]# ln -sv mysql-5.5.38-linux2.6-i686/ mysql` 2. `[root@localhost local]# cd mysql` 使用vim INSTALL-BINARY查看安装提示 添加MySQL用户1. `[root@localhost local]# useradd mysql` 修改文件权限1. `[root@localhost mysql]# chown -R mysql.mysql ./` 安装MySQL1. `[root@localhost mysql]# ./scripts/mysql_install_db --user=mysql` 2. 成功提示： 再次修改权限1. `[root@localhost mysql]# chown -R root . ` 2. `[root@localhost mysql]# chown -R mysql data` 复制配置文件1. `[root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnf` 2. `cp：是否覆盖&quot;/etc/my.cnf&quot;？ y` 复制服务1. `[root@localhost mysql]# cp support-files/mysql.server /etc/init.d/mysqld` 将MySQL的服务添加到系统服务中1. `[root@localhost mysql]# chkconfig --add mysqld` 启动MySQL服务1. `[root@localhost mysql]# service mysqld start` 默认安装完成没有密码，修改密码 [root@localhost mysql]# ./bin/mysqladmin -u root password &#39;newpass&#39; 如果已经设置了密码可以通过如下方式设置 mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;newpass&#39;); [root@localhost mysql]# ./bin/mysqladmin -u root password oldpass &#39;newpass&#39; update user set password = password(&#39;newpass&#39;) where user = &#39;root&#39;; 如果密码丢失了，可以这样： mysql_safe --skip-grant-tables&amp;mysql -u root mysql mysql&gt; update user set password=password(&#39;new password&#39;) where user =&#39;root&#39;; mysql&gt;FLUSH PRIVILEGES; 打开MySQL客户端1. `[root@localhost mysql]# ./bin/mysql -uroot -p` 2. `Enter password:` 报错排错设置远程登录权限 mysql&gt; use mysql mysql&gt; select host,user from user; mysql&gt; update user set host=&#39;%&#39; where user =&#39;root&#39; and host =&#39;127.0.0.1&#39;; mysql&gt; delete from user where host != &#39;%&#39;; mysql&gt; FLUSH PRIVILEGES; 若没有关闭防火墙需要关闭防火墙 ervice iptables stop 开启静态IP 123456ONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticIPADDR=192.168.34.100NETMASK=255.255.255.0NM_CONTROLLED=no]]></content>
      <tags>
        <tag>LAMP环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2015%2F20151110-1.html</url>
    <content type="text"><![CDATA[Linux命令分为两类，内部命令和外部命令。内部命令比如cd、ls等等，外部命令就是shell文件。命令的格式：command [-选项] 参数 常用的命令pwd 查看当前工作目录ls 查看目录中的子文件cd 进入目录su 获取管理员权限init 改变系统运行登录runlevel 显示系统运行登录startx 启动窗口界面passwd 更改密码clear 清屏exit 退出当前工作环境或退出系统dir 查看当前目录下的文件和文件夹whoami 使用当前权限的用户who am i 查看登录的用户halt或power off或shut down 关机 reboot 重启man 命令 查看帮助 命令 --helpdu [-h] [-s] 查看磁盘容量df 查看分期ps -A 查看进程kill –9 进程号 或 pkill 进程名杀死进程grep 搜索字符串control + U 撤销非乱七八糟输入 关于目录和文件的命令cd 改变工作目录cd和cd ~ 进入主目录cd ../ 相对路径cd /../.. 绝对路径 mkdir 创建目录mkdir dir 创建目录mkdir dir1/dir2 在dir1目录下创建dir2(dir1必须存在)mkdir -p dir1/dir2 递归创建目录（dir1不存在）mkdir dir1 dir2 dir3 创建多个目录rmdir 删除目录rm –rf 文件/目录 删除文件或文件夹 cp 复制文件或目录cp file dir 将file复制到dir中cp file1 dir/file2 将file1复制到dir中并改名为file2cp file1 ./file2 将file1复制一份，并改名为file2 mv 移动文件或文件夹mv file1 file2 将file1改名为file2mv file1 dir1 将file1移动发哦dir1下mv dir1 dir2 如果dir2不存在就是将dir1改名为dir2，如果dir2存在将dir1移动到dir2下。mv dir1 dir2/dir3 dir3不存在就是将dir1移动到dir2中并改名为dir3。 查看文件内容cat file 将file文件内容全部显示tac file 将file文件内容反向查看cat file1 file2 &gt; file3 将file1和file3的内容合并到file3中more file 分屏显示，按回车键显示 不能上翻less file 分屏显示，可以上下翻head –n file 显示前n行tail -n file 显示后n行动态查看：tail -n 5 /etc/groupwc file 显示文件的行数，句数 字符数 创建和向文件中添加内容touch file 创建文件，可以一次创建多个echo 内容 &gt; 文件将内容清空写入文件echo 内容 &gt;&gt; 文件将内容追加写入文件cat file1 &gt; file2将file1的内容清空写入到file2cat file1 &gt;&gt; file2将file1的内容追加写到file2中 ##用户和组的操作 useradd 添加用户useradd uiste添加用户同时创建同名的组useradd -g group_name uiste添加用户指定所属组useradd -d home_path uiste添加用户指定家目录 uesrmod 修改用户-c comment修改备注信息-l login_name修改登录名称-d home_dir修改用户的家目录-g group_name修改用户所属组 userdel 删除用户-r同时删除用户的家目录 增加组groupadd添加组groupadd -g 组编号 itcast2 修改组groupmod -n myitcast itcast修改组名称groupmod -g 504 myitcast 修改组编号 删除组groupdel 组名称 删除组 查看组tail -n 5 /etc/group查看最后五条信息 组文件：/etc/group 组信息组名称 组密码（X占位符） 组编号（超级管理员0，1-499默认给系统使用，500+自定义用户组） 组内用户组密码：/etc/gshadow 目前组密码没有使用 组名称 组密码（！没有密码）用户文件：/etcpasswd 用户名 密码占位符 用户编号 用户所属组编号 用户全名（备注） 用户家目录 用户能够使用的指令（bin/bash用户表示可以登录到操作系统中，bin/nologin表示用户不能够登录到系统）密码：/etc/shadow 用户名 用户密码，散列算法加密密码。使用！！表示用户没有密码的用户不能登录到系统设置用户口令 passwdpasswd uiste (设置密码注意，检验过程)-S： status查看某个用户的状态-l： lock锁定某个用户，不能正常登录-u： unlock解除锁-d：delete清空用户密码禁止普通用户登录 锁定 删除密码 修改用户密码文件直接在前面加上 !! vim /etc/shadow 对应用户密码前面增加两个感叹号 禁止所有普通用户登录 在etc目录下创建一个空文件 nologin touch nologin 用户相关的其他命令 su : 切换用户 whoami：我是谁 id：用户信息 groups：用户所属组 用户资料信息 chfn 用户名：添加备注信息 finger 用户名：查看用户信息1. `cd /bin`与`cd /sbin`找不该命令 2. 安装 赋予用户特殊权限 直接编辑 /etc/sudoers visudo 修改文件 操作步骤 useradd dumin创建用户 passwd dumin创建密码 whereis useradd查询某个命令所在位置 修改/etc/sudoers文件给某个普通用户赋予权限1) `dumin localhost = /user/sbin/useradd` 切换用户执行命令1)` su dumin` 2) `sudo -l `显示拥有权限 date 查看或设置系统日期时间 | 管道运行符文件权限 第一列：代表文件权限信息 第二列：文件节点数 第三列：文件所有者（用户） 第四列：文件所属组（组）字母含义 第一个字母表示文件类型，-表示普通文件，d表示文件夹 后面九个字母，每三个为一组 第一组：所有者的权限 第二组：所有组的权限（所有组所在的组其他用户对文件的权限） 第三组：组外用户的权限 最后一个点，表示文件具备selinux安全文件权限数字转换，777，755，644§ r可读权限，使用数字4表示§ w写入权限，使用数字2表示§ x执行权限，使用数字1表示§ 0代表没有权限§ 777分别对应了所有者，组内用户，组外用户修改文件权限chmod修改权限[uiste@localhost ~]$ chmod -R 777 1.php-R参数表示递归chown修改文件拥有者chown -R uiste 1.phpchown -R uiste.uiste 1.phpchgrp修改所属组chgrp -R root 1.php基本语法：ln -sn 源文件地址 目标地址创建软连接相当于windows下的快捷方式vim(vi) 查看vim是否存在 vi file file存在就打开，不存在就新建后打开 vi + filename /vi + n + filename 打开文件定位到指定行数 vi + string filename打开文件并定位到string vi有三种模式命令模式、末行模式、编辑模式 末行模式 ：进入末行模式 :w保存 :w!强制保存 :q退出 :q!强制退出 :wq 保存退出 :x :wq!强制保存退出 set number或set nu 设置行号 set nonumber 或set nonu 取消行号 :n 跳转到第n行 /str 向下查找 n下一个 N上一个 ?str 向上查找 /xx/yy 将当前的xx改为yy s/xx/yy/g 将当前行的xx改为yy %s/xx/yy/g 将整个页面的xx改成yy u 撤销前一条指令 . 继续上一条指令 J连接上下两行 r+指定字符 用指定字符替换当前字符 编辑模式：按i、o 、a、s进入编辑模式，退出esc退出编辑模式 命令模式 光标的移动 单词级别操作 行级操作 $ 行尾 0 行首 段级 { 段的开始 } 段的结束 屏幕的级别 H：head 屏幕的首部 L：tail 屏幕的尾部 文档级 G 移动到文档的尾部 3G 移动的文本的第3行 删除操作 dd 删除当前行 x 删除当前字符 d+光标的区域 删除当前字符到光标达到的区域 复制 yy 复制当前行 p 粘贴]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX跨域请求与AJAX浏览器缓存处理]]></title>
    <url>%2F2015%2F20151106-1.html</url>
    <content type="text"><![CDATA[AJAX原生post 提交12345678910111213141516171819&lt;script type=&quot;text/javascript&quot;&gt;window.onload=function()&#123; document.getElementById(&apos;username&apos;).onblur=function()&#123; var username=document.getElementById(&apos;username&apos;).value; username=encodeURIComponent(username); //字符编码，防止与URL关键字相混淆 var req=new XMLHttpRequest(); req.open(&apos;post&apos;,&apos;./5-demo.php&apos;); //创建连接 req.onreadystatechange=function()&#123; //当状态发生变化 if(req.readyState==4 &amp;&amp; req.status==200)&#123; var result=req.responseText; //接受返回的信息 alert(result); &#125; &#125; req.setRequestHeader(&apos;Content-Type&apos;,&apos;application/x-www-form-urlencoded&apos;); //设置请求头 req.send(&apos;username=&apos;+username); //post提交数据 &#125;&#125;&lt;/script&gt;&lt;input type=&quot;text&quot; name=&quot;&quot; id=&quot;username&quot;&gt; 解决浏览器缓存 方法一：添加一个随机数，使得URL地址变得唯一req.open(&#39;open&#39;,&#39;./1.php?&#39;+Math.random()); 方法二：告知浏览器不要缓存页面header(&quot;Cache-Control:no-cache&quot;);header(&quot;Pragma:no-cache&quot;); 方法三：当浏览器接受到相应的时候，缓存就已经过期header(&quot;Expires:-1&quot;); 方法四：设置请求头：req.setRequestHeader(&#39;If-Modified-Since&#39;,&#39;0&#39;);客户端通过If-Modified-Since头将服务器端最后发过来的页面时间戳发送回去，服务器端通过时间戳判断客户端的页面是否是最新的，如果不是最新的则返回新的内容，如果是最新的，则返回304重定向到客户端缓存中的页面。 跨域请求背景：浏览器为了安全考虑，不允许跨域请求。同源策略：一个域名下的JS只能请求同一个域名下的文件，不能跨域请求解决方法： HTML标记的src属性没有同源限制&lt;script src=&quot;http://www.uiste.com/test.js&quot;&gt;&lt;/script&gt; PHP同域代理 12文件一：&lt;?php echo file_get_contents(&apos;http://www.uiste.com/test.php&apos;); ?&gt;文件二：&lt;script&gt;req.open(&apos;open&apos;,&apos;6-demo.php&apos;)&lt;/script&gt; 设置响应头 1234header(&quot;Access-Control-Allow-Origin: http://a.com&quot;); // 允许a.com发起的跨域请求 //如果需要设置允许所有域名发起的跨域请求，可以使用通配符 * header(&quot;Access-Control-Allow-Origin: *&quot;); // 允许任意域名发起的跨域请求 header(&apos;Access-Control-Allow-Headers: X-Requested-With,X_Requested_With&apos;); jsonpJSONP是客户端用get的方式传递一个回调函数的名字给服务器，服务器返回拼接好的调用函数字符串给客户端，然后客户端用js生成script标记，用script标记的src属性引入服务器生成的js代码， 123456789101112131415161718PHP文件一：$stu = array(&apos;tom&apos;,&apos;berry&apos;);$stu = json_encode($stu);$fn = $_GET[&apos;fn&apos;];echo &quot;$fn($stu)&quot;;HTML文件二：&lt;script type=&quot;text/javascript&quot;&gt;function show(msg)&#123;alert(msg);&#125;window.onload=function()&#123; document.getElementById(&apos;btn&apos;).onclick=function()&#123; var script=document.createElement(&apos;script&apos;); script.src=&quot;http://www.uiste.com/test.php?fn=show&quot;; var body=document.getElementByTagName(&apos;body&apos;)[0]; body.appendChild(script); &#125;&#125;&lt;/script&gt;&lt;input type=&quot;button&quot; value=&quot;点击&quot; id=&quot;btn&quot;&gt; jsonp案例 实例1test.html123456789101112&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery-1.5.2.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;ajax.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; ajax.js12345678910111213$.ajax(&#123; type : &quot;post&quot;, url : &quot;ajax.php&quot;, dataType : &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback) jsonpCallback:&quot;success_jsonpCallback&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名 success : function(json)&#123; alert(&apos;success&apos;); &#125;, error:function()&#123; alert(&apos;fail&apos;); &#125;&#125;); ajax.php1234567&lt;?php $data = &quot;.......&quot;;$callback = $_GET[&apos;callback&apos;];echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;exit;?&gt; jquery-1.5.2.min.js当使用jsonp时，使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 实例2test.html1234567891011121314151617&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;script src=&quot;jquery-1.5.2.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;ajax.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;form name=&quot;form&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;sex&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;button&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ajax.js12345678910111213141516171819202122232425262728293031$(document).ready(function()&#123; $(&quot;#btn&quot;).click(function(k) &#123; //... var j = $(&quot;form&quot;).serializeArray();//序列化name/value $.ajax(&#123; type: &apos;GET&apos;, //这里用GET url: &apos;ajax.php&apos;, dataType: &apos;jsonp&apos;, //类型 data: j, jsonp: &apos;callback&apos;, //jsonp回调参数，必需 async: false, success: function(result) &#123;//返回的json数据 alert(result.message); //回调输出 result = result || &#123;&#125;; if (result.msg==&apos;err&apos;)&#123; alert(result.info); &#125;else if (result.msg==&quot;ok&quot;)&#123; alert(&apos;提交成功&apos;); &#125;else&#123; alert(&apos;提交失败&apos;); &#125; &#125;, timeout: 3000 &#125;) //... &#125;); &#125;); ajax.php12345678&lt;?php$callback = isset($_GET[&apos;callback&apos;]) ? trim($_GET[&apos;callback&apos;]) : &apos;&apos;; //jsonp回调参数，必需$date = array(&quot;age&quot;=&gt;$_GET[&apos;age&apos;], &quot;message&quot;=&gt;$_GET[&apos;age&apos;]);$date[&quot;msg&quot;]=&quot;err&quot;;$date[&quot;info&quot;]=&quot;因人品问题，发送失败&quot;;$tmp= json_encode($date); //json 数据echo $callback . &apos;(&apos; . $tmp .&apos;)&apos;; //返回格式，必需?&gt;]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Role-Based Access Control]]></title>
    <url>%2F2015%2F20151101-1.html</url>
    <content type="text"><![CDATA[RBAC基于角色的访问控制 (Role-Based Access Control) 表设计12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#创建后台管理员表DROP TABLE IF EXISTS ugo_admin;CREATE TABLE ugo_admin( admin_id TINYINT UNSIGNED auto_increment PRIMARY KEY COMMENT '管理员id' , admin_name VARCHAR(50) NOT NULL COMMENT '用户名' , admin_pwd VARCHAR(50) NOT NULL COMMENT '密码' , admin_role_id TINYINT UNSIGNED NOT NULL COMMENT '角色编号') ENGINE = INNODB charset = utf8 COMMENT '管理员表';# 超级管理员测试数据insert into ugo_admin values (null,'aa','aa',0);#创建后台权限表DROP TABLE IF EXISTS ugo_authority;CREATE TABLE ugo_authority( auth_id INT UNSIGNED auto_increment PRIMARY KEY COMMENT 'auth_id' , auth_name VARCHAR(50) NOT NULL COMMENT '权限名称' , auth_pid INT UNSIGNED NOT NULL COMMENT '权限父级id' , auth_c VARCHAR(50) NULL COMMENT '控制器名' , auth_a VARCHAR(50) NULL COMMENT '方法名' , auth_path VARCHAR(50) NULL COMMENT '全路径,格式:父级id-子级id' , is_show TINYINT NOT NULL DEFAULT 1 COMMENT '是否显示在导航栏上') ENGINE = INNODB charset = utf8 COMMENT '权限表';#创建后台角色表DROP TABLE IF EXISTS ugo_role;CREATE TABLE IF NOT EXISTS ugo_role( role_id TINYINT UNSIGNED auto_increment PRIMARY KEY COMMENT 'role_id' , role_name VARCHAR(50) NOT NULL COMMENT '角色名称' , role_auth_ids VARCHAR(255) NOT NULL COMMENT '角色具有权限id的集合，格式1,2,5' , role_auth_ac text NOT NULL COMMENT '控制器和方法的组合，格式：控制器-方法名') ENGINE = INNODB charset = utf8 COMMENT '角色表';# *********************************************************** #-- 插入测试数据insert into ugo_authority values (1,'商品管理',0,'','',1,1);insert into ugo_authority values (2,'会员管理',0,'','',2,1);insert into ugo_authority values (3,'权限管理',0,'','',3,1);insert into ugo_authority values (4,'商品列表',1,'Goods','show','1-4',1);insert into ugo_authority values (5,'添加商品',1,'Goods','add','1-5',1);insert into ugo_authority values (6,'修改商品',1,'Goods','edit','1-6',0);insert into ugo_authority values (7,'删除商品',1,'Goods','del','1-7',0);insert into ugo_authority values (8,'会员列表',2,'Role','show','2-12',1);insert into ugo_authority values (9,'添加会员',2,'Role','add','2-13',1);insert into ugo_authority values (10,'修改会员',2,'Role','edit','2-14',0);insert into ugo_authority values (11,'删除会员',2,'Role','del','2-15',0);insert into ugo_authority values (12,'权限列表',3,'Authority','show','3-8',1);insert into ugo_authority values (13,'添加权限',3,'Authority','add','3-9',1);insert into ugo_authority values (14,'修改权限',3,'Authority','edit','3-10',0);insert into ugo_authority values (15,'删除权限',3,'Authority','del','3-11',0);insert into ugo_role values (1,'经理','1,4,5','Goods-show,Goods-add');insert into ugo_role values (2,'主管','1,4','Goods-show');insert into ugo_admin values (null,'aa','aa',0)# *********************************************************** # 菜单后台123456789101112131415161718public function menu()&#123; $admin = session('admin'); $role_id = $admin['admin_role_id']; if ($role_id==0) &#123; //超级管理员 $auth_info1 = M('authority')-&gt;where('auth_pid = 0 and is_show = 1')-&gt;select();//父级 $auth_info2 = M('authority')-&gt;where('auth_pid &gt; 0 and is_show = 1')-&gt;select();//子级 &#125;else&#123; $role = M('role')-&gt;find($role_id); //通过管理员角色id找到角色信息 $role_auth_ids = $role['role_auth_ids'];//获取该角色的权限信息 $auth_info1 = M('authority')-&gt;where("auth_pid = 0 and is_show =1 and auth_id in ($role_auth_ids)")-&gt;select(); $auth_info2 = M('authority')-&gt;where("auth_pid &gt; 0 and is_show =1 and auth_id in ($role_auth_ids)")-&gt;select(); &#125; $this-&gt;assign('menu_list',array( 'auth_info1' =&gt; $auth_info1, 'auth_info2' =&gt; $auth_info2 )); $this-&gt;display(); &#125; 菜单前台123456789101112&lt;volist name="menu_list.auth_info1" id="vo1"&gt; &lt;li class="collapse" key="&#123;$i&#125;_&#123;$vo1.auth_c&#125;" name="menu"&gt; &#123;$vo1.auth_name&#125; &lt;ul style="display: none;"&gt; &lt;volist name="menu_list.auth_info2" id="vo2"&gt; &lt;li class="menu-item"&gt; &lt;a href="/index.php/Admin/&#123;$vo2.auth_c&#125;/&#123;$vo2.auth_a&#125;" target="main-frame"&gt;&lt;if condition="$vo1.auth_id eq $vo2.auth_pid "&gt;&#123;$vo2.auth_name&#125;&lt;/if&gt; &lt;/a&gt; &lt;/li&gt; &lt;/volist&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/volist&gt; 防翻墙与越权访问12345678910111213141516171819202122232425262728293031323334class BaseController extends Controller&#123; public function __construct()&#123; parent::__construct(); $this-&gt;chenkLogin(); &#125; // 防翻墙 public function chenkLogin()&#123; if (strtoupper(CONTROLLER_NAME)=='LOGIN') &#123; return; &#125; $info = session('admin'); if (!$info) &#123; echo '&lt;script type="text/javascript"&gt;'; echo "parent.location.href='/index.php/Admin/Public/login'"; echo '&lt;/script&gt;'; exit; &#125; //放置越权访问 if ($info['admin_role_id']==0) &#123; return; &#125; //非管理员验证是否具有访问权限(防止越权方法) $allow_controller_array = array('INDEX');//所有权限都可以访问Index控制器 $controller_name = strtoupper(CONTROLLER_NAME);//将当前控制器名转大写 if (!in_array($controller_name, $allow_controller_array)) &#123; $role = M('role')-&gt;find($info['admin_role_id']); $allow_auth_ac = $role['role_auth_ac'];//当前角色允许的权限 $now_auth_ac = CONTROLLER_NAME . '-' . ACTION_NAME; //当前角色访问权限 if (FALSE === stripos($allow_auth_ac, $now_auth_ac)) &#123; $this-&gt;error('您没有此访问权限'); &#125; &#125; &#125;&#125; 五张表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748RBAC建表三张主表管理员表(it_admin) 角色表(it_role) 权限表(it_privilege)两张中间表角色表与权限表的关系（多对多）it_role_privilege一个角色，拥有多个权限一个权限，所属多个角色管理员表与角色表的关系（多对多）it_admin_role一个角色拥有多个管理员一个管理员也可以属于多个角色#创建一个管理员表 create table it_admin( id int unsigned primary key auto_increment, admin_name varchar(32) not null comment &apos;管理员名称&apos;, password char(32) not null comment &apos;管理员密码&apos;, salt char(6) not null comment &apos;密码的密钥&apos;)engine myisam charset utf8;密码的加密方式是这样的，md5(md5(password).salt)#在建管理员表时，要手工创建一个超级管理员密码:&apos;admin&apos;salt: df8trrinsert into it_admin(admin_name,password,salt) values(&apos;admin&apos;,&apos;a2040d1137c482b2b5379efb11909db5&apos;,&apos;df8trr&apos;);#创建一个角色表 create table it_role( id int unsigned primary key auto_increment, role_name varchar(32) not null comment &apos;角色名称&apos; )engine myisam charset utf8;#创建一个权限表(节点，按钮) 权限就是按钮 create table it_privilege( id int unsigned primary key auto_increment, priv_name varchar(32) not null comment &apos;权限名称&apos;, parent_id int not null default 0 comment &apos;权限的父权限&apos;, module_name varchar(32) not null comment &apos;权限对应模块的名称&apos;, controller_name varchar(32) not null comment &apos;权限对应控制器的名称&apos;, action_name varchar(32) not null comment &apos;权限对应方法的名称&apos;)engine myisam charset utf8;#创建一个角色与权限的中间表 create table it_role_privilege( role_id int not null comment &apos;角色的id&apos;, priv_id int not null comment &apos;权限的id&apos;)engine myisam charset utf8;#创建一个管理员与角色的中间表 create table it_admin_role( admin_id int not null comment &apos;管理员的id&apos;, role_id int not null comment &apos;角色的id&apos;)engine myisam charset utf8;]]></content>
      <tags>
        <tag>RBAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命名空间]]></title>
    <url>%2F2015%2F20151018-2.html</url>
    <content type="text"><![CDATA[学编程就像学开车，老司机带你装逼，带你飞 …··· 命名空间概述背景：如果一个项目很大，有很多文件，很可能有同名的文件。这时候如果组织这些文件就成了大问题。 命名空间通过namespace声明:12345678namespace China;function getInfo()&#123; &#125;namespace USA;function getInfo()&#123;&#125;getInfo();//访问USA的getInfo 命名空间是一种封装事物的方法命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。 定义命名空间受命名空间影响的是：类（包括抽象类和traits）、接口、函数和常量。语法：namespace MyProject 必须在其它所有代码之前声明命名空间，命名空间必须是程序脚本的第一条语句。除了一个以外：declare关键字 定义子命名空间命名空间的名字可以使用分层次的方式定义Example #1 声明分层次的单个命名空间123456&lt;?phpnamespace MyProject\Sub\Level;const CONNECT_OK = 1;class Connection &#123; /* ... */ &#125;function connect() &#123; /* ... */ &#125;?&gt; 可以使用文件的路径来做命名空间。在自动加载类的时候可以通过命名空间的路径来加载类 访问空间的三种方法 非限定名称访问 完全限定名称访问 [部分]限定名称访问 引入命名空间完全限定名称访问不方便书写，可以在当前的命名空间下引入其他的命名空间，然后再使用其他命名空间的元素通过use关键字来引入命名空间 1234567891011namespace China\Shanghai\PuDong;function getInfo()&#123; echo &apos;aaa&apos;;&#125;namespace USA\Washington;function getInfo()&#123; echo &apos;bb&apos;;&#125;use China\Shanghai\PuDong;getInfo(); //bbPuDong\getInfo(); //aa 引入类(use) 引入与当前控制器同名的类会报错 解决方法：给类取别名 使用as 关键字给命名空间取别名 123use China\Shanghai\PuDong\Person as ChinaPerson;$person = new ChinaPerson();echo $person-&gt;name; 引入命名空间和引入类都是用的use,他们的区分就看引入的是不是类，如果不是类就是命名空间 公共的命名空间如果一个PHP文件中没有namespace关键字声明，则文件中的元素默认存在于公共的空间下。 在一个页面中，包含另一个文件，不会影响当前页面的命名空间 命名空间的注意事项 命名空间中可以存放：函数、类、const常量，不能存放define常量。 第一个namespace之前不能有任何代码，header()也不行 包含文件不会改变当前的命名空间 ## namespace关键字和__NAMESPACE__常量(PHP 5 &gt;= 5.3.0, PHP 7)PHP支持两种抽象的访问当前命名空间内部元素的方法，__NAMESPACE__ 魔术常量和namespace关键字 常量__NAMESPACE__的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。 __NAMESPACE__ 示例, 在命名空间中的代码全局代码 常量 __NAMESPACE__ 在动态创建名称时很有用123456789&lt;?phpnamespace MyProject;function get($classname)&#123; $a = __NAMESPACE__ . &apos;\\&apos; . $classname; return new $a;&#125;?&gt; 允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。 所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。 在PHP中，别名是通过操作符 use 来实现的. 下面是一个使用所有可能的五种导入方式的例子： Example #1 使用use操作符导入/使用别名123456789101112131415161718192021222324252627&lt;?phpnamespace foo;use My\Full\Classname as Another;// 下面的例子与 use My\Full\NSname as NSname 相同use My\Full\NSname;// 导入一个全局类use ArrayObject;// importing a function (PHP 5.6+)use function My\Full\functionName;// aliasing a function (PHP 5.6+)use function My\Full\functionName as func;// importing a constant (PHP 5.6+)use const My\Full\CONSTANT;$obj = new namespace\Another; // 实例化 foo\Another 对象$obj = new Another; // 实例化 My\Full\Classname 对象NSname\subns\func(); // 调用函数 My\Full\NSname\subns\func$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象// 如果不使用 &quot;use \ArrayObject&quot; ，则实例化一个 foo\ArrayObject 对象func(); // calls function My\Full\functionNameecho CONSTANT; // echoes the value of My\Full\CONSTANT?&gt; 通过use操作符导入/使用别名，一行中包含多个use语句use My\Full\Classname as Another, My\Full\NSname; 名称解析示例1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace A;use B\D, C\E as F;// 函数调用foo(); // 首先尝试调用定义在命名空间&quot;A&quot;中的函数foo() // 再尝试调用全局函数 &quot;foo&quot;\foo(); // 调用全局空间函数 &quot;foo&quot; my\foo(); // 调用定义在命名空间&quot;A\my&quot;中函数 &quot;foo&quot; F(); // 首先尝试调用定义在命名空间&quot;A&quot;中的函数 &quot;F&quot; // 再尝试调用全局函数 &quot;F&quot;// 类引用new B(); // 创建命名空间 &quot;A&quot; 中定义的类 &quot;B&quot; 的一个对象 // 如果未找到，则尝试自动装载类 &quot;A\B&quot;new D(); // 使用导入规则，创建命名空间 &quot;B&quot; 中定义的类 &quot;D&quot; 的一个对象 // 如果未找到，则尝试自动装载类 &quot;B\D&quot;new F(); // 使用导入规则，创建命名空间 &quot;C&quot; 中定义的类 &quot;E&quot; 的一个对象 // 如果未找到，则尝试自动装载类 &quot;C\E&quot;new \B(); // 创建定义在全局空间中的类 &quot;B&quot; 的一个对象 // 如果未发现，则尝试自动装载类 &quot;B&quot;new \D(); // 创建定义在全局空间中的类 &quot;D&quot; 的一个对象 // 如果未发现，则尝试自动装载类 &quot;D&quot;new \F(); // 创建定义在全局空间中的类 &quot;F&quot; 的一个对象 // 如果未发现，则尝试自动装载类 &quot;F&quot;// 调用另一个命名空间中的静态方法或命名空间函数B\foo(); // 调用命名空间 &quot;A\B&quot; 中函数 &quot;foo&quot;B::foo(); // 调用命名空间 &quot;A&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法 // 如果未找到类 &quot;A\B&quot; ，则尝试自动装载类 &quot;A\B&quot;D::foo(); // 使用导入规则，调用命名空间 &quot;B&quot; 中定义的类 &quot;D&quot; 的 &quot;foo&quot; 方法 // 如果类 &quot;B\D&quot; 未找到，则尝试自动装载类 &quot;B\D&quot;\B\foo(); // 调用命名空间 &quot;B&quot; 中的函数 &quot;foo&quot; \B::foo(); // 调用全局空间中的类 &quot;B&quot; 的 &quot;foo&quot; 方法 // 如果类 &quot;B&quot; 未找到，则尝试自动装载类 &quot;B&quot;// 当前命名空间中的静态方法或函数A\B::foo(); // 调用命名空间 &quot;A\A&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法 // 如果类 &quot;A\A\B&quot; 未找到，则尝试自动装载类 &quot;A\A\B&quot;\A\B::foo(); // 调用命名空间 &quot;A\B&quot; 中定义的类 &quot;B&quot; 的 &quot;foo&quot; 方法 // 如果类 &quot;A\B&quot; 未找到，则尝试自动装载类 &quot;A\B&quot;?&gt;]]></content>
      <tags>
        <tag>命名空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射 | PDO]]></title>
    <url>%2F2015%2F20151018-1.html</url>
    <content type="text"><![CDATA[反射、PDO反射反射是指获取类、方法、属性、参数、注释等封闭信息的方法。主要用来了解类方法、等内部的代码，反射是通过一系列的类实现的。反射：Reflection ReflectionClass 报告类中的信息ReflectionFunction 报告函数的信息RefectionException 报告异常类RefectionMethod 报告方法中的信息 123456&lt;?phpecho '&lt;pre&gt;';ReflectionClass::export('Exception');ReflectionClass::export('stdClass'); //所有类的父类?&gt; 通过反射获取类中的属性、方法、常量123456789101112131415161718class Student&#123; const PI=3.14; private $name; public static $national=&apos;中国&apos;： public function show()&#123; echo &apos;aa&apos;; &#125; public static function test()&#123; echo &apos;bb&apos;; &#125;&#125;//通过反射获取类的信息//实例化反射对象$reflection new ReflectionClass(&apos;Student&apos;);//反射Student类的信息$consts = $reflection-&gt;getConstants();//获取所有常量$props = $reflection-&gt;getProperties();//获取所有属性$methods = $reflection-&gt;getMethods();//获取所有方法 自定义修改的类，方便修改 通过反射获取代理类的对象通过调用反射类的newInstance()对象，返回反射 $reflection = new ReflectionClass(&#39;Student&#39;);$str $reflection-&gt;newInstance(); //返回类的实例 反射可以通过反向代理来调用方法正向代理在运行过程中，如果感知到代理服务器存在就是正向代理。（比如：从局域网进入到外网） 反向代理在运行过程中，不能感受到代理服务器存在。（比如京东、淘宝，服务器的请求分发我们是不知道的） 通过ReflectionMethod的invoke()反向调用 如果反向调用的是静态方法，invoke()参数为null1234567891011121314151617181920&lt;?phpclass Student&#123; private $name; public __construct($name)&#123; $this-&gt;name = $name; &#125; public function show()&#123; echo $this-&gt;name,'&lt;br&gt;'; &#125; public static function test()&#123; echo 'i am a boy!&lt;br&gt;'; &#125;&#125;$reflection = new ReflectionClass('Student');//反射Student类的信息$stu = $reflection-&gt;new Instance('tom');//实例化Student对象，并传递参数$method = new ReflectionMethod('Student','show');//获取关于show()方法的信息$method-&gt;invoke($stu);//方向代理调用$method = new Reflection('Student','test');$method-&gt;invoke(NULL);?&gt; 反射是为了了解系统类或不知道内部结构的类而使用 PDO连接MySQL的方法方法一：mysql_*组 开启extension = php_mysql.dll扩展mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;aa&#39;); //链接方法二：mysqli_*组开启extension = php_mysqli.dll扩展$link = mysqli_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;aa&#39;,&#39;data&#39;); mysqli是mysql的升级版 PDO简介PDO（PHP data object） PHP数据对象,PDO也是PHP内置的一组类（有三个），在与PDO相关的三个类中提供了一组访问数据库的轻量级，一致性的接口，无论使用什么数据库，都可以通过一致性的接口。操作数据库。PDO是PHP5以上才支持的特性开启相应拓展extension = php_pdo_xxx.dll PDO的核心类：PDO、PDOStatement、PDOException PDO：表示PHP程序和数据库直接的一个连接 PDOStatement：表示一条SQL处理语句，在该语句执行完成时，会返回执行结果 PDOException：表示PDO产生的异常实例化PDO对象(dsn data source name) 数据源名称dsn 的组成结构：$dsn = 数据库类型:host=主机地址;port=端口号;dbname=数据库;charset=字符编码;语法：$pdo = new PDO($dsn,数据库用户名,数据库密码);123$dsn = &apos;mysql:host=127.0.0.1;port=3306;dbname=php6;charset=utf8&apos;;$pdo = new PDO($dsn,&apos;root&apos;,&apos;aa&apos;);var_dump($pdo); 本地主机可以省略，端口号是默认值时可以省略，dbname也是可以省略的，如果dbname省略，表示连接上服务器当时没有选择数据库。但是数据库类型(mysql:)不可以省略数据库类型必须小写 使用PDO对象$pdo-&gt;exec();执行数据操作语句，执行成功返回受影响的记录数，否则返回false；$pdo-&gt;query();//数据查询语句，返回PDOStatement对象 操作数据12345678910111213141516&lt;?php$dsn = "mysql:host=127.0.0.1;port=3306;dbname=php06;charset=utf8";$pdo = new PDO($dsn,'root','aa');$sql = "insert into admin values(2,'aa','aa',0,0)";$rs = $pdo-&gt;exec($sql);if($rs) echo '插入成功&lt;br&gt;生成的编号是：'.$pdo-&gt;lastInsertId();elseif($rs===0) echo '没有数据变化';elseif($rs===false)&#123; echo 'SQL语句执行失败'; $error = $pdo-&gt;errorInfo(); echo '错误码：'.$pdo-&gt;errorCode(),'&lt;br&gt;'; echo '错误信息：'.$error[2];&#125;?&gt; 查询数据1234567891011121314151617181920212223242526272829303132333435&lt;?php$dsn = 'mysqy:host=127.0.0.1;port=3306;dbname=php06;charset=utf8';$pdo = new PDO($dsn,'root','aa');$sql = "select * from admin";$stmt = $pdo-&gt;query($sql);//返回PDOStatement对象//数据输出,array();$rows = $stmt-&gt;fetch();$rows = $stmt-&gt;fetch(PDO::FETCH_BOTH);//同上$rows = $stmt-&gt;fetch(PDO::FETCH_ASSOC);//匹配成关联数组$rows = $stmt-&gt;fetch(PDO::FETCH_NUM);//匹配成索引数组$rows = $stmt-&gt;fetch(PDO::FETCH_OBJ);//匹配成对象/*************************************/$rs = $stmt-&gt;fetchALL();//匹配所有数据$rs = $stmt-&gt;fetchALL(PDO::FETCH_ASSOC);//匹配所有数据为关联数组/*************************************/echo $stmt-&gt;rowCount(),'&lt;br&gt;';//获取总行数echo $stmt-&gt;columnCount(),'&lt;br&gt;';//获取总列数/*************************************///获取一条数据，匹配成类的对象$obj = $stmt-&gt;fetchObject();var_dump($obj);//PHP顶级父类stdClass类class Person&#123;&#125;$obj = $stmt-&gt;fetchObject('Person');/*************************************/$col = $stmt-&gt;fetchColumn();//匹配某一行的第0列$col = $stmt-&gt;fetchCOlumn(1);//匹配某一行的第1列/*************************************///将列绑定到变量上，绑定列的时候，列的编号是从1开始$stmt-&gt;bindColumn(1,$id);//将第一列绑定到$id变量上$stmt-&gt;bindColumn(2,$admin);//bindColumn('admin',$admin);将admin列绑定到$admin变量上$stmt-&gt;fetch();echo $id,'-',$admin;$stmt-&gt;fetch();echo $id,'-',$admin;?&gt; 以上测试，均为单行或单模块测试。其它位注释状态 脚下留心 可以通过列的索引和列的名称来绑定到变量上绑定列和变量的时候，列的索引从1开始 取出全部数据12345678910&lt;?php//通过循环获取所以数据while($rows = $stmt-&gt;fetch(PDO::FETCH_ASSOC))&#123; echo $rows['id'],'-',$rows['admin'],'&lt;br&gt;';&#125;//通过内置迭代器遍历foreach($stmt as $rows)&#123; echo $rows['id'],'-',$rows['admin'],'&lt;br&gt;';&#125;?&gt; PDO事物处理1234567&lt;?php$pdo-&gt;beginTransaction();//开启事务模式echo $pdo-&gt;exec("insert into admin values(null,'11','11',0,0)");echo $pdo-&gt;lastInsertId();$pdo-&gt;rollBack(); //回滚事务$pdo-&gt;commit();//提交事务?&gt; 预处理语句1234567891011121314151617181920212223242526272829&lt;?php$sql = "insert into admin values(null,?,?,0,0)";//?是占位符$stmt = $pdo-&gt;prepare($sql);//返回PDOStatement对象//执行预处理语句$stu = array( array('aa','aa'), array('bb','bb'));/**********************************///绑定参数并执行（方法一）foreach($stu as $s)&#123; $stmt-&gt;bindValue(1,$s[0]); $stmt-&gt;bindValue(2,$s[1]); $stmt-&gt;execute();//返回bool值&#125;/**********************************///绑定参数并执行（方法二）foreach($stu as $s)&#123; $stmt-&gt;bindParam(1,$s[0]); $stmt-&gt;bindParam(2,$s[1]); $stmt-&gt;execute();//返回bool值 &#125;/**********************************///绑定参数并执行（方法三）foreach($stu as $s)&#123; $stmt-&gt;execute($s);//返回bool值&#125;?&gt; 词法分析—&gt;语法分析-&gt;编译-&gt;执行如果一个sql语句要被多次执行，词法分析、语法分析、编译会多次执行，这样效率低下。使用预处理语句，对预处理语句编译后传递不同的参数即可。 bindParam 与 bindValue 的区别 bindParam第二个参数是取地址，所以只能传递变量bindValue第二个参数可以传递值也可以传递变量 直接给预处理传递数组的时候要注意 数组中值的个数和顺序要和占位符的顺序一致 参数占位符1234567891011121314&lt;?php$sql = "insert into admin values(null,:p1,:p2,0,0)";//参数占位符$stmt-&gt;$pdo-&gt;prepare($sql)//预处理语句//执行预处理语句$stu = array( array('aa','aa'), array('bb','bb')8);foreach($stu as $s)&#123; $stmt-&gt;bindParam(':p1',$s[0]); $stmt-&gt;bindParam(':p2',$s[1]); $stmt-&gt;execute();&#125;?&gt; PDO 属性$pdo-&gt;setAttribute(键,值)；//设置PDO属性$pdo-&gt;getAttribute(键,值)；//获取PDO属性12345678910111213&lt;?php$dsn = 'mysql:dbname=php6';$pdo = new PDO($dsn,'root','aa');echo $pdo-&gt;getAttribute(PDO::ATTR_AUTOCOMMIT);//自动提交 $pdo-&gt;setAttribute(PDO::ATTR_CASE,PDO::CASE::UPPER);//强制将列明转换为大写$pdo-&gt;setAttribute(PDO::ATTR_ERRORMODE,PDO::ERRMODE_WARNING);//错误报告为警告模式$stmt = $pdo-&gt;query('select * from admin');$rows = $stmt-&gt;fetch(PDO::FETCH_ASSOC);echo '&lt;pre&gt;';var_dump($rows);?&gt; PDO异常抛出PDO 会自动抛出异常123456789101112131415&lt;?phptry&#123; $dsn = 'mysql:dbname=php6'; $pdo = new PDO($dsn,'root','aa');//PDO会自动抛出异常 $pdo -&gt; setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);//有错误就抛出异常 $stmt = $pdo-&gt;query('select * from admin'); var_dump($Stmt-fetch()); $age =60; if($age&gt;30) throw new PDOException('年龄不能超过30');&#125;catch(PDOException $e)&#123; echo '错误信息：'.$e-&gt;getmessage(),'&lt;br&gt;'; echo '错误行号：'.$e-&gt;getLine(),'&lt;br&gt;';&#125;?&gt; 单例模式实现MyPDO类的封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpclass MyPDO&#123; private $type;//数据库类型 private $host;//主机地址 private $port;//端口号 private $dbname;//数据库名 private $charset;//字符编码 private $user;//数据库用户名 private $pwd;//数据库密码 private $pdo;//PDO对象 private static $instance;//当前类的实例 //使用的构造函数用来阻止在类的外部实例化 private function __construct($param)&#123; $this-&gt;initParam($param); $this-&gt;initPDO(); &#125; //私有的__clone()用来阻止在类的外部克隆对象 private function __clone()&#123;&#125; //公有的静态方法用来获取当前类的实例 public static function getInstance($param=array())&#123; if(!self::$instance instanceof self) self::$instance = new self($param); return self::$instance; &#125; //初始化成员变量 private function initParam($param)&#123; $this-&gt;type = isset($param['type'])?$param['type']:'mysql'; $this-&gt;host = isset($param['host'])?$param['host']:'localhost'; $this-&gt;port = isset($param['port'])?$param['port']:'3306'; $this-&gt;dbname = isset($param['dbname'])?$param['dbname']:'uiste'; $this-&gt;charset = isset($param['charset'])?$param['charset']:'utf8'; $this-&gt;user = isset($param['user'])?$param['user']:'root'; $this-&gt;pwd = isset($param['pwd'])?$param['pwd']:'123456'; &#125; //创建PDO对象 private function initPDO()&#123; $dsn = "&#123;$this-&gt;type&#125;:host=&#123;$this-&gt;host&#125;;port=&#123;$this-&gt;port&#125;;dbname=&#123;$this-&gt;dbname&#125;;charset=&#123;$this-&gt;charset&#125;"; $this-&gt;pdo = new PDO($dsn,$this-&gt;user,$this-&gt;pwd); &#125; //执行sql语句,返回PDOStatement对象 private function getPDOStatement($sql)&#123; return $this-&gt;pdo-&gt;query($sql); &#125; //判断匹配的类型 private function getFetchType($type)&#123; $allow_type = array('assoc','num','both'); if(!in_array($type,$allow_type)) $type='assoc'; switch($type)&#123; case 'assoc': return PDO::FETCH_ASSOC; case 'num': return PDO::FETCH_NUM; case 'both': return PDO::FETCH_BOTH; &#125; &#125; //获取所有记录，返回二位数组 public function getAll($sql,$type='assoc')&#123; $stmt = $this-&gt;getPDOStatement($sql); $fetch_type = $this-&gt;getFetchType($type); return $stmt-&gt;fetchAll($fetch_type); &#125; public function getOne($sql,$type='assoc')&#123; $stmt = $this-&gt;getPDOStatement($sql); $fetch_type = $this-&gt;getFetchType($type); return $stmt-&gt;fetchAll($fetch_type); &#125; public function getColumn($sql)&#123; $stmt = $this-&gt;getPDOStatement($sql); return $stmt-&gt;fetColumn(); &#125; //数据库增、删、改,返回受影响的行数 public function exec($sql)&#123; $result = $this-&gt;pdo-&gt;exec($sql); if(false!==$result) return $result; else&#123; $errorinfo_arr = $this-&gt;pdo-&gt;errorInfo(); echo 'SQL 语句执行失败&lt;br&gt;'; echo 'Error SQL：'.$sql.'&lt;br&gt;'; echo 'SQLSTATE error code：'.$errorinfo_arr[0].'&lt;br&gt;'; echo 'Driver-specific error code：'.$errorinfo_arr[1].'&lt;br&gt;'; echo 'Driver-specific error message：'.$errorinfo_arr[2].'&lt;br&gt;'; &#125; &#125;&#125;?&gt; PDO的作用PHP数据对象，内置的一组类（有三个），在与PDO相关的三个类中提供了一组访问数据库的轻量级，一致性的接口，无论使用什么数据库，都可以通过一致性的接口，操作数据库。 PDO的加载PDO是PHP5以上才支持的特性需要开启相应拓展extension = php_pdo_xxx.dll PDO技术中的PDO对象dsn 的组成结构：$dsn = 数据库类型:host=主机地址;port=端口号;dbname=数据库;charset=字符编码;语法：$pdo = new PDO($dsn,数据库用户名,数据库密码); PDO技术中的PDOStatement对象代表一条预处理语句，并在该语句被执行后代表一个相关的结果集。PDOStatement::bindColumn — 绑定一列到一个 PHP 变量PDOStatement::bindParam — 绑定一个参数到指定的变量名PDOStatement::bindValue — 把一个值绑定到一个参数PDOStatement::closeCursor — 关闭游标，使语句能再次被执行。PDOStatement::columnCount — 返回结果集中的列数PDOStatement::debugDumpParams — 打印一条 SQL 预处理命令PDOStatement::errorCode — 获取跟上一次语句句柄操作相关的 SQLSTATEPDOStatement::errorInfo — 获取跟上一次语句句柄操作相关的扩展错误信息PDOStatement::execute — 执行一条预处理语句PDOStatement::fetch — 从结果集中获取下一行PDOStatement::fetchAll — 返回一个包含结果集中所有行的数组PDOStatement::fetchColumn — 从结果集中的下一行返回单独的一列。PDOStatement::fetchObject — 获取下一行并作为一个对象返回。PDOStatement::getAttribute — 检索一个语句属性PDOStatement::getColumnMeta — 返回结果集中一列的元数据PDOStatement::nextRowset — 在一个多行集语句句柄中推进到下一个行集PDOStatement::rowCount — 返回受上一个 SQL 语句影响的行数PDOStatement::setAttribute — 设置一个语句属性PDOStatement::setFetchMode — 为语句设置默认的获取模式。 PDO技术中的PDOException对象代表一个由 PDO 产生的错误。在自己的代码不应抛出一个 PDOException 异常 PDO的操作——插入操作$pdo-&gt;exec(); //执行数据操作语句，执行成功返回受影响的记录数，否则返回false。 掌握PDO的操作——写操作？？？ 掌握PDO的操作——查询操作$pdo-&gt;query(); //数据查询语句，返回PDOStatement对象 掌握PDO的事务操作$pdo-&gt;beginTransaction(); //开启事务$pdo-&gt;rollBack(); //回滚事务$pdo-&gt;commit();//提交事务 掌握PDO的预处理 1234567891011121314151617181920212223242526272829303132&lt;?php$dsn='mysql:host=localhost;port=3306;dbname=php6;charset=utf8';$pdo=new PDO($dsn,'root','aa');//预处理语句$sql="insert into admin values (null,?,?,0,0)"; //?是占位符$stmt=$pdo-&gt;prepare($sql); //返回PDOStatement对象//执行预处理语句$stu=array( array('aa','aa'), array('bb','bb'));//绑定参数并执行（方法一）/*foreach($stu as $s)&#123; $stmt-&gt;bindValue(1, $s[0]); $stmt-&gt;bindValue(2, $s[1]); $stmt-&gt;execute(); //返回bool值&#125; *///绑定参数并执行（方法二）/*foreach($stu as $s)&#123; $stmt-&gt;bindParam(1, $s[0]); $stmt-&gt;bindParam(2, $s[1]); $stmt-&gt;execute(); //返回bool值&#125; *///绑定参数并执行（方法三）,直接传递数组foreach($stu as $s)&#123; $stmt-&gt;execute($s); //返回bool值&#125;?&gt; 123456$sql="insert into admin values (null,:p1,:p2,0,0)"; //参数占位符foreach ($stu as $s)&#123; $stmt-&gt;bindParam(':p1', $s[0]); //绑定参数 $stmt-&gt;bindParam(':p2', $s[1]); $stmt-&gt;execute();&#125; PDO的属性操作$pdo-&gt;getAttribute(键)：获取PDO属性$pdo-&gt;getAttribute(键)：获取PDO属性 PDO的异常处理机制PDO会自动抛出异常，其他的地方不能自动抛出$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);设置为自动抛出异常 总反射：获取类中方法、属性、参数、注释等封闭信息的方法发射的父类（reflection）ReflectionClass:export()：反射出类的内部结构getMethods()：获取所有方法、getProterties()：获取所有属性getConstants()：获取常量通过反射类可以创建代理类的对象 newInstance()发射通过反向代理调用对象的方法PDO（PHP data object）提供了一组一致性的接口，用来访问不同的数据库。要使用pdo之前必须开启pdo扩展PDO核心类PDO：表示PHP和数据库的链接对象PDOStatement类，PDO执行sql语句返回的结果PDOException：PDO异常实例化PDO:$dsn=’mysql:host=主机;port=端口号;dbname=数据库名;charset=字符编码’PDO($dsn,用户名,密码)脚下留心：数据类型要小写使用PDO$pdo-&gt;exec()：执行数据操作语句，返回的受影响的记录数或false$pdo-&gt;query()：执行数据查询语句，返回的是PDOStatement对象$pdo-&gt;lastInsertId()：获取生成的id编号获取PDOStatement对象中的数据$pdo-&gt;fetch()：获取一条数据$pdo-&gt;fetchAll()：获取所有数据$pdo-&gt;fetchColumn()：获取列$pdo-&gt;fetchObject()：获取一行数据，并匹配成对象$pdo-&gt;rowCount()：总行数$pdo-&gt;columnCount()：总列数$pdo-&gt;bindColumn()：将列绑定到变量上匹配的类型：PDO::FETCH_BOTHPDO::FETCH_ASSOCPDO::FETCH_NUMPDO事务$pdo-&gt;beginTransaction()$pdo-&gt;rollback()$pdo-&gt;commit()预处理$pdo-&gt;prepare()位置占位符（？）参数占位符（:参数名）绑定参数bindValue()bindParam()操作数据$pdo-&gt;getAttribute()$pdo-&gt;setAttribute()异常处理默认情况下，如果有错误就报错，不会抛出异常，设置如下语句使得自动抛出异常：$pdo-&gt;setAttribute(PDO::ERRMODE,PDO::ERRMODE_EXCEPTION)]]></content>
      <tags>
        <tag>反射</tag>
        <tag>PDO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库设计-商城购物系统]]></title>
    <url>%2F2015%2F20151017-3.html</url>
    <content type="text"><![CDATA[数据库设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308/* Navicat Premium Data Transfer Source Server : uiste Source Server Type : MySQL Source Server Version : 50542 Source Host : localhost Source Database : ugo Target Server Type : MySQL Target Server Version : 50542 File Encoding : utf-8 Date: 10/16/2015 14:27:21 PM*/#创建数据库create database ugo charset utf8;#选择数据库use ugou;/*------------------------------------商品模块---------------------------------------*/#创建商品类别表DROP TABLE IF EXISTS `ugo_category`;create table ugo_category( cat_id smallint unsigned not null auto_increment primary key comment '商品类别ID', cat_name varchar(30) not null default '' comment '商品类别名称', cat_parent_id smallint unsigned not null default 0 comment '商品类别父ID', cat_desc varchar(255) not null default '' comment '商品类别描述', sort_order tinyint not null default 50 comment '排序依据', unit varchar(15) not null default '' comment '单位', is_show tinyint not null default 1 comment '是否显示，默认显示', index pid(cat_parent_id))engine=MyISAM charset=utf8;#创建商品国家表DROP TABLE IF EXISTS `ugo_country`;create table ugo_country( country_id smallint unsigned not null auto_increment primary key comment '国家ID', country_name varchar(30) not null default '' comment '国家名称', country_parent_name enum('亚洲','欧洲','北美洲','南美洲','非洲','大洋洲','南极洲') not null default '亚洲' comment '国家所属区域', sort_order tinyint not null default 50 comment '排序依据', is_show tinyint not null default 1 comment '是否显示，默认显示', index pid(country_parent_name))engine=MyISAM charset=utf8;#创建商品品牌表DROP TABLE IF EXISTS `ugo_brand`;create table ugo_brand( brand_id smallint unsigned not null auto_increment primary key comment '商品品牌ID', brand_name varchar(30) not null default '' comment '商品品牌名称', brand_desc varchar(255) not null default '' comment '商品品牌描述', url varchar(100) not null default '' comment '商品品牌网址', logo varchar(50) not null default '' comment '品牌logo', sort_order tinyint unsigned not null default 50 comment '商品品牌排序依据', is_show tinyint not null default 1 comment '是否显示，默认显示', country_id smallint unsigned not null comment '商品品牌所属国家ID')engine=MyISAM charset=utf8;#创建商品类型表DROP TABLE IF EXISTS `ugo_attrtype`;create table ugo_attrtype( type_id smallint unsigned not null auto_increment primary key comment '商品类型ID', type_name varchar(50) not null default '' comment '商品类型名称')engine=MyISAM charset=utf8;#创建商品属性表DROP TABLE IF EXISTS `ugo_attribute`;create table ugo_attribute( attr_id smallint unsigned not null auto_increment primary key comment '商品属性ID', attr_name varchar(50) not null default '' comment '商品属性名称', type_id smallint not null default 0 comment '商品属性所属类型ID', attr_input_type tinyint not null default 1 comment '属性录入方式 0为手工录入，1为从列表中选择，2为文本域', attr_input_value text comment '属性的值', index type_id(type_id))engine=MyISAM charset=utf8;#创建商品表DROP TABLE IF EXISTS `ugo_goods`;create table ugo_goods( goods_id int unsigned not null auto_increment primary key comment '商品ID', goods_sn varchar(30) not null default '' comment '商品货号', goods_name varchar(100) not null default '' comment '商品名称', goods_brief varchar(255) not null default '' comment '商品简单描述', goods_slogan varchar(50) not null default '' comment '商品宣传语', goods_desc text comment '商品详情', cat_id smallint unsigned not null default 0 comment '商品所属类别ID', brand_id smallint unsigned not null default 0 comment '商品所属品牌ID', market_price decimal(10,2) not null default 0 comment '市场价格', promote_price decimal(10,2) not null default 0 comment '促销价格', promote_start_time int unsigned not null default 0 comment '促销起始时间', promote_end_time int unsigned not null default 0 comment '促销截止时间', goods_img varchar(50) not null default '' comment '商品图片', goods_thumb varchar(50) not null default '' comment '商品缩略图', goods_number smallint unsigned not null default 0 comment '商品库存', click_count int unsigned not null default 0 comment '点击次数', type_id smallint unsigned not null default 0 comment '商品类型ID', is_promote tinyint unsigned not null default 0 comment '是否促销，默认为0不促销', is_best tinyint unsigned not null default 0 comment '是否精品,默认为0', is_new tinyint unsigned not null default 0 comment '是否新品，默认为0', is_hot tinyint unsigned not null default 0 comment '是否热卖,默认为0', is_onsale tinyint unsigned not null default 1 comment '是否上架,默认为1', add_time int unsigned not null default 0 comment '添加时间', index cat_id(cat_id), index brand_id(brand_id), index type_id(type_id))engine=MyISAM charset=utf8;#创建商品属性对应表DROP TABLE IF EXISTS `ugo_goods_attr`;create table ugo_goods_attr( goods_attr_id int unsigned not null auto_increment primary key comment '编号ID', goods_id int unsigned not null default 0 comment '商品ID', attr_id smallint unsigned not null default 0 comment '属性ID', attr_value varchar(255) not null default '' comment '属性值', attr_price decimal(10,2) not null default 0 comment '属性价格', index goods_id(goods_id), index attr_id(attr_id))engine=MyISAM charset=utf8;#创建商品相册表DROP TABLE IF EXISTS `ugo_gallery`;create table ugo_gallery( img_id int unsigned not null auto_increment primary key comment '图片编号', goods_id int unsigned not null default 0 comment '商品ID', img_url varchar(50) not null default '' comment '图片URL', thumb_url varchar(50) not null default '' comment '缩略图URL', img_desc varchar(50) not null default '' comment '图片描述', index goods_id(goods_id))engine=MyISAM charset=utf8;/*------------------------------------商品模块 end-----------------------------------*//*------------------------------------用户模块---------------------------------------*/#创建用户表DROP TABLE IF EXISTS `ugo_user`;create table ugo_user( user_id int unsigned not null auto_increment primary key comment '用户编号', user_name varchar(50) not null default '' comment '用户名', tel char(12) not null default '' comment '手机号码', email varchar(50) not null default '' comment '电子邮箱', password char(32) not null default '' comment '用户密码,md5加密', reg_time int unsigned not null default 0 comment '用户注册时间')engine=MyISAM charset=utf8;#创建用户收货地址表DROP TABLE IF EXISTS `ugo_address`;create table ugo_address( address_id int unsigned not null auto_increment primary key comment '地址编号', user_id int unsigned not null default 0 comment '地址所属用户ID', consignee varchar(60) not null default '' comment '收货人姓名', province smallint unsigned not null default 0 comment '省份，保存是ID', city smallint unsigned not null default 0 comment '市', district smallint unsigned not null default 0 comment '区', street varchar(100) not null default '' comment '街道地址', zipcode varchar(10) not null default '' comment '邮政编码', telephone varchar(20) not null default '' comment '电话', mobile varchar(20) not null default '' comment '移动电话', index user_id(user_id))engine=MyISAM charset=utf8;#创建地区表，包括省市区三级DROP TABLE IF EXISTS `ugo_region`;create table ugo_region( region_id smallint unsigned not null auto_increment primary key comment '地区ID', parent_id smallint unsigned not null default 0 comment '父ID', region_name varchar(30) not null default '' comment '地区名称', region_type tinyint unsigned not null default 1 comment '地区类型 1 省份 2 市 3 区(县)')engine=MyISAM charset=utf8;#创建购物车表DROP TABLE IF EXISTS `ugo_cart`;create table ugo_cart( cart_id int unsigned not null auto_increment primary key comment '购物车ID', user_id int unsigned not null default 0 comment '用户ID', goods_id int unsigned not null default 0 comment '商品ID', goods_name varchar(100) not null default '' comment '商品名称', goods_img varchar(50) not null default '' comment '商品图片', goods_attr varchar(255) not null default '' comment '商品属性', goods_number smallint unsigned not null default 1 comment '商品数量', market_price decimal(10,2) not null default 0 comment '市场价格', goods_price decimal(10,2) not null default 0 comment '成交价格', subtotal decimal(10,2) not null default 0 comment '小计')engine=MyISAM charset=utf8;/*------------------------------------用户模块 end-----------------------------------*//*------------------------------------订单模块---------------------------------------*/#创建送货方式表DROP TABLE IF EXISTS `ugo_shipping`;create table ugo_shipping( shipping_id tinyint unsigned not null auto_increment primary key comment '编号', shipping_name varchar(30) not null default '' comment '送货方式名称', shipping_desc varchar(255) not null default '' comment '送货方式描述', shipping_fee decimal(10,2) not null default 0 comment '送货费用', enabled tinyint unsigned not null default 1 comment '是否启用，默认启用')engine=MyISAM charset=utf8;#创建支付方式表DROP TABLE IF EXISTS `ugo_payment`;create table ugo_payment( pay_id tinyint unsigned not null auto_increment primary key comment '支付方式ID', pay_name varchar(30) not null default '' comment '支付方式名称', pay_desc varchar(255) not null default '' comment '支付方式描述', enabled tinyint unsigned not null default 1 comment '是否启用，默认启用')engine=MyISAM charset=utf8;#创建订单表DROP TABLE IF EXISTS `ugo_order`;create table ugo_order( order_id int unsigned not null auto_increment primary key comment '订单ID', order_sn varchar(30) not null default '' comment '订单号', user_id int unsigned not null default 0 comment '用户ID', address_id int unsigned not null default 0 comment '收货地址id', order_status tinyint unsigned not null default 0 comment '订单状态 1 待付款 2 待发货 3 已发货 4 已完成', postscripts varchar(255) not null default '' comment '订单附言', shipping_id tinyint not null default 0 comment '送货方式ID', pay_id tinyint not null default 0 comment '支付方式ID', goods_amount decimal(10,2) not null default 0 comment '商品总金额', order_amount decimal(10,2) not null default 0 comment '订单总金额', order_time int unsigned not null default 0 comment '下单时间', index user_id(user_id), index address_id(address_id), index pay_id(pay_id), index shipping_id(shipping_id))engine=MyISAM charset=utf8;#创建订单明细表,即商品订单关系表（多对多）DROP TABLE IF EXISTS `ugo_order_goods`;create table ugo_order_goods( rec_id int unsigned not null auto_increment primary key comment '编号', order_id int unsigned not null default 0 comment '订单ID', goods_id int unsigned not null default 0 comment '商品ID', goods_name varchar(100) not null default '' comment '商品名称', goods_img varchar(50) not null default '' comment '商品图片', shop_price decimal(10,2) not null default 0 comment '商品价格', goods_price decimal(10,2) not null default 0 comment '成交价格', goods_number smallint unsigned not null default 1 comment '购买数量', goods_attr varchar(255) not null default '' comment '商品属性', subtotal decimal(10,2) not null default 0 comment '商品小计')engine=MyISAM charset=utf8;/*------------------------------------订单模块 end-----------------------------------*/#创建后台管理员表DROP TABLE IF EXISTS ugo_admin;CREATE TABLE ugo_admin( admin_id TINYINT UNSIGNED auto_increment PRIMARY KEY COMMENT '管理员id' , admin_name VARCHAR(50) NOT NULL COMMENT '用户名' , admin_pwd VARCHAR(50) NOT NULL COMMENT '密码' , admin_role_id TINYINT UNSIGNED NOT NULL COMMENT '角色编号') ENGINE = INNODB charset = utf8 COMMENT '管理员表';# 超级管理员测试数据insert into ugo_admin values (null,'aa','aa',0);#创建后台权限表DROP TABLE IF EXISTS ugo_authority;CREATE TABLE ugo_authority( auth_id INT UNSIGNED auto_increment PRIMARY KEY COMMENT 'auth_id' , auth_name VARCHAR(50) NOT NULL COMMENT '权限名称' , auth_pid INT UNSIGNED NOT NULL COMMENT '权限父级id' , auth_c VARCHAR(50) NULL COMMENT '控制器名' , auth_a VARCHAR(50) NULL COMMENT '方法名' , auth_path VARCHAR(50) NULL COMMENT '全路径,格式:父级id-子级id' , is_show TINYINT NOT NULL DEFAULT 1 COMMENT '是否显示在导航栏上') ENGINE = INNODB charset = utf8 COMMENT '权限表';#创建后台角色表DROP TABLE IF EXISTS ugo_role;CREATE TABLE IF NOT EXISTS ugo_role( role_id TINYINT UNSIGNED auto_increment PRIMARY KEY COMMENT 'role_id' , role_name VARCHAR(50) NOT NULL COMMENT '角色名称' , role_auth_ids VARCHAR(255) NOT NULL COMMENT '角色具有权限id的集合，格式1,2,5' , role_auth_ac text NOT NULL COMMENT '控制器和方法的组合，格式：控制器-方法名') ENGINE = INNODB charset = utf8 COMMENT '角色表';# *********************************************************** #-- 插入测试数据insert into ugo_authority values (1,'商品管理',0,'','',1,1);insert into ugo_authority values (2,'会员管理',0,'','',2,1);insert into ugo_authority values (3,'权限管理',0,'','',3,1);insert into ugo_authority values (4,'商品列表',1,'Goods','show','1-4',1);insert into ugo_authority values (5,'添加商品',1,'Goods','add','1-5',1);insert into ugo_authority values (6,'修改商品',1,'Goods','edit','1-6',0);insert into ugo_authority values (7,'删除商品',1,'Goods','del','1-7',0);insert into ugo_authority values (8,'会员列表',2,'Role','show','2-12',1);insert into ugo_authority values (9,'添加会员',2,'Role','add','2-13',1);insert into ugo_authority values (10,'修改会员',2,'Role','edit','2-14',0);insert into ugo_authority values (11,'删除会员',2,'Role','del','2-15',0);insert into ugo_authority values (12,'权限列表',3,'Authority','show','3-8',1);insert into ugo_authority values (13,'添加权限',3,'Authority','add','3-9',1);insert into ugo_authority values (14,'修改权限',3,'Authority','edit','3-10',0);insert into ugo_authority values (15,'删除权限',3,'Authority','del','3-11',0);insert into ugo_role values (1,'经理','1,4,5','Goods-show,Goods-add');insert into ugo_role values (2,'主管','1,4','Goods-show');insert into ugo_admin values (null,'aa','aa',0)# *********************************************************** #]]></content>
      <tags>
        <tag>数据库设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板引擎]]></title>
    <url>%2F2015%2F20151017-2.html</url>
    <content type="text"><![CDATA[前台页面实现、Smartystatic 和 GLOBALS的区别相同点：生命周期是一样的，声明的时候产生，页面执行完毕销毁。不同点： 超全局变量在所有的地方都能使用静态变量只能在自己的作用域中访问如果一个函数内没有区别，两个函数只能GLOBALS作用域不同 前台显示实现方法：1、递归2、三重循环 在开发的时候能不用递归就不用递归，因为递归消耗资源比较多；如果确定就显示三级就用三重循环来实现 方法一：通过模糊查询select * from goods where `goods_status` like &#39;%hot%&#39;; 模糊查询，以%百分号开头的查询无法使用索引，只能是全表扫描。效率低下 方法二：使用find_in_set(值，集合)select * from goods where find_in_set(&#39;best&#39;,`goods_status`); 优化了方法一，效率提高了。但find_in_set()函数本身是个全表扫描的函数 方法三：使用位运算符查找best：select * from goods where goods_status &amp; 1;查找既有best又有hot同时存在：select * from goods where goods_status &amp; 1 and goods_status &amp; 4 集合和枚举一样，在计算机内部都是通过数值管理的。要想看有没有那个参数，就与上那个参数就可以了。&amp;best =&gt; 001new =&gt; 010hot =&gt; 100测试：select goods_status,goods_status+0 from goods;best,new 3best,new,hot 7new,hot 6 best+hot 101&amp;001 001 已知集合占用8个字节，一个字节8个位，8个直接64个位，所有集合最多可以保存64个选项 模板引擎引擎和框架是有区别的。我们现在开发的项目，前段代码和服务器端代码同在一个页面中。这样前端和服务器端看起来都不方便。为了让所有的项目开发人员。只关注自己的业务，我们将表现（HTML）和内容（PHP）相分离。 模板引擎 推导简而言之，界定符的优化。将输出变量更改一下形式光说不练假把式将替换的结果当成字符串输出了。 模板引擎的思想四步法：file_get_contents(); 获取表现内容str_replace(); 定义左右定界符file_put_contents(); 输出混编文件require(); 引入混编文件 1234567&lt;?php $str = file_get_contents('demo.html');$str = str_replace('&#123;','&lt;?php echo ',$str);$str = str_replace('&#125;',";?&gt;",$str);file_put_contents('./demo.html.php',$str);require './demo.html.php'; ?&gt; 模板引擎封装123456789101112131415161718192021222324&lt;?php class Smarty&#123; private $tpl_var=array(); public function assign($key,$value)&#123; $this-&gt;tpl_var[$Key]=$value; &#125; //@param string $tpl HTML页面的地址 pulic function compile($tpl)&#123; $com_file = $tpl.'.php';//混编文件名complicated if(file_exists($com_file) &amp;&amp; filemtime($tpl)&lt;filetime($com_file))&#123; require $com_file; &#125;else&#123; $str = file_get_contents('demo.html'); $str = str_replace('&#123;','&lt;?php echo $this-&gt;tpl_var[\'',$str); $str = str_replace('&#125;',"\'];?&gt;",$str); file_put_contents('./demo.html.php',$str); require $com_file; &#125; &#125;&#125;$smarty = new Smarty();$smarty-&gt;assign('title',$title);$smarty-&gt;compile(demo.html); ?&gt; 输出：&lt;?php echo $this-&gt;tpl_var[$key]?&gt; 外部调用1234require &apos;./Smarty.class.php&apos;; //加载类文件$smarty = new Smarty(); //实例化对象$smarty-&gt;assgin(&apos;title&apos;,$title); //赋值操作$smarty-&gt;compile(); //编译输出文件 如何判断混编文件不是最新的? 模板的创建时间在混编文件之前int filemtime ( string $filename ) 将模板文件和混编文件分开存储 templates templates_c 一般来说，关键性代码都是私有，通过公有的方法来调用它； 将complie() 方法用private来修饰，用一个公有的方法来调用display()调用]]></content>
      <tags>
        <tag>模板引擎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smarty2 模板引擎]]></title>
    <url>%2F2015%2F20151017-1.html</url>
    <content type="text"><![CDATA[Smarty 模板引擎Smarty作用Smarty 是一个成熟的引擎，用来实现表现和内容相分离。Smarty官网 文件目录 plugins 存放Smarty插件，即扩展类文件 sysplugins 存放系统系统函数的目录 Smarty.class.php Smarty 的入口文件，引入此文件即可 SmartyBC.class.php 兼容版 Smarty.class.php -构造函数 setTemplateDir(): 设置模板文件夹 setCompileDir(): 设置混编文件夹 setCacheDir(): 设置缓存文件夹 setConfigsDir(): 设置配置文件夹 使用步骤拷贝核心文件libs 到站点下。并更名为Smarty1234require &apos;./Smarty/Smarty.class.php&apos;;$smarty = new Smarty();$smarty-&gt;assign(&apos;name&apos;,&apos;uiste&apos;);$smarty-&gt;display(&apos;demo1.html&apos;); 界定符：$left_delimiter = &#39;{&#39;修改界定符：$smarty-&gt;left_delimiter = &#39;&lt;{&#39;;更改模板文件：$smarty-&gt;setTemplateDir(&#39;./views/&#39;);更改混编文件夹：$smarty-&gt;setCompileDir(&#39;./view_c/&#39;); 注释：{*这是Smarty的注释*}多学一招：Smarty和HTML注释内容的区别。Smarty注释在网页源代码中不显示。 如果Smarty的定界符是{* *}那么注释的语法是?答：{** 注释 **} 变量普通变量自定义变量。语法一：在PHP文件中，$smarty-&gt;assign(‘变量名’,’变量值’);在模板文件中，{$name}语法二：在模板文件中，使用{assign} 标签,定义变量{assign var=&#39;name&#39; value=&#39;berry&#39;}{$name} 保留变量Smarty 中有一个特殊的变量 $smarty ，不能作为自定义变量名，他是一个保留变量（内置变量）。该变量用来获取用户的请求、系统变量、常量。 例题 模板文件中：{$smarty.get.name} 获取GET、POST、REQUEST提交的值 模板文件中：{$smarty.const.PI} 获取define定义常量 PHP文件中：$_SESSION[&#39;name&#39;] = &#39;root&#39; ；模板文件中：$smarty.session.admin 获取会话的值，$smarty.cookies.admin 获取cookie的值 模板文件中：{$smarty.server.DOCUMENT_ROOT} 获取根目录 模板文件中：{$smarty.now} 获取时间戳 模板文件中：{$smarty.ldelim}，{$smarty.rdelim} 获取左右界定符 模板文件中：{$smarty.version} 获取版本号 配置变量将变量保存在配置文件，然后再Smarty模板中引入 新建configs文件夹 创建smarty.conf文件，参数设置如下：12345678&gt;HOST = 127.0.0.1&gt;USERNAME = ROOT&gt;PWD = aa&gt;[style1]&gt;COLOR = #FF0000&gt;[style2]&gt;COLOR = #00FF00&gt; 配置文件中节，用[]中括号来声明，通过config_load 的 section 属性来引入配置文件中的节，没有经过[]设置为节的为全局配置文件 模板文件中：{config_load file = &#39;smarty.conf&#39; section=&#39;&#39;} //只需要写配置文件名，不需要写路径 模板文件中，获取数据语法a) ：主机名 用户名 自定义不同情况下的颜色123*&#123; color:&#123;##COLOR&#125;&#125; 数组在Smarty中对数组的操作有两种方法方法一：{数组[下标]}方法二：{数组.下标} foreach 循环遍历数组语法12345&#123;foreach 数组 as 键=&gt;值&#125;//循环体&#123;foreachelse&#125;//没有数组输出，foreachelse可以省略&#123;/foreach&#125; 属性语法：{值变量@属性}{$value@iteration} 从1开始的编号{$value@index} 从0开始的索引{$value@first} 是否是第一个元素{$value@last} 是否是最后一个元素{$value@show} 数组中是否有元素显示{$value@total} 一共有多少个元素 section 循环遍历数组只能遍历索引数组，不能遍历关联数组 语法：{section name = 自定义变量(key) loop=数组($week)}{$week[key]}//循环体{sectionelse}//没有数组输出{/section} 属性{$smarty.section.自定义变量名.iteration} 从1增长的编号{$smarty.section.自定义变量名.index} 从0增长的索引{$smarty.section.自定义变量名.first} 是否是第一个元素{$smarty.section.自定义变量名.last} 是否是最后一个元素 判断语法：1234567&#123;if $score&gt;=90&#125;优秀&#123;elseif $score&gt;=80&#125;良好&#123;else $score&gt;=70&#125;满意&#123;/if&#125; 循环for循环123&#123;for 变量=初始值 to 结束值 [step 步长]&#125;//循环体&#123;/for&#125; 123&#123;for $i=1 to 10 step 2&#125; &#123;$i&#125;:锄禾日当午&#123;/for&#125; 步长默认是1，step 自定义步长 while循环123&#123;while 条件&#125; //循环体&#123;/while&#125; 1234&#123;assign var=&apos;n&apos; value=1&#125;&#123;while $n&lt;=10&#125; &#123;$n++&#125;:汗滴禾下土&#123;/while&#125; 自定义函数{html_checkboxes} 复选框模板文件中：方法一：{html_checkboxes output=$output values=$values selected=$selected}方法二：{html_checkboxes options=$options selected=$selected}PHP文件中：123$smarty-&gt;assign(&apos;output&apos;,array(&apos;ff&apos;,&apos;bb&apos;,&apos;cc&apos;,&apos;dd&apos;,&apos;ee&apos;));$smarty-&gt;assign(&apos;value&apos;,array(&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;));$smarty-&gt;assign(&apos;selected&apos;,array(&apos;1&apos;,&apos;4&apos;)); 模板文件中1234&#123;html_checkboxes output=$output values=$value selected=$selected&#125;&#123;html_options output=$output values=$value name=&apos;hobby&apos; selected=$selected2&#125;&#123;html_radios output=$output values=$value selected=$selected2&#125;&#123;html_select_date month_format=&apos;%m&apos; field_order=&apos;YMD&apos;&#125; {html_options} 下拉菜单模板文件中：{html_options options=$options name=&#39;hobby&#39; selected=$selected}PHP文件中： {html_radios}单选按钮模板文件中：{html_radios options=$options selected=$selected} {html_select_date}显示日期{html_select_date month_format=&#39;%m&#39; field_order=&#39;YMD&#39;} 变量修饰器要使用变量修饰器，我们需要管道运算符( | ) 在默认情况下，truncate是按字节截取的，但是中文属于多字节字符，在UTF-8下一个字符占用3个字节显示，这样会出现乱码；如果开启了多字节处理，truncate就会自动按多字符处理了。 extension=php_mbstring.dll 缓存Smarty 缓存就是生成静态页面开启：$smarty-&gt;caching = 1; 开启缓存更新缓存：方法一：删除对应的缓存，系统会更新方法二：更改对应的模板文件，包括配置文件，包含文件，布局文件缓存都会自动更新方法三：缓存文件的有效时间过期，会自动更新方法四：$smarty-&gt;force_cache = true; 强制更新缓存 缓存的生命周期默认情况下，缓存的生命周期是3600秒。$smarty-&gt;cache_lifetime = -1 | 0 | N; N：表示缓存文件生命周期是N秒 0：缓存文件立即失效 -1：永远不失效 单模板，多缓存【缓存分页】php文件：1234require &apos;./Smarty/Smarty.class.php&apos;;$smarty = new Smarty();$smarty-&gt;caching = 1; //开启缓存$smarty-&gt;display(&apos;demo17.html&apos;,$_GET[&apos;pageno&apos;]) 模板文件：1当前是第&#123;$smarty.get.pageno&#125;页 缓存集合PHP代码：123456require &apos;./Smarty/Smarty.class.php&apos;;$smarty = new Smarty();$smarty-&gt;caching = 1; //开启缓存$color = $_GET[&apos;color&apos;];$size = $_GET[&apos;size&apos;]$smarty-&gt;display(&apos;demo18.html&apos;,&quot;$color|$size&quot;); 模板文件：12颜色：&#123;$smarty.get.color&#125;大小：&#123;$samrty.get.size&#125; 邓东旭语：厉害了我的哥 清除缓存$smarty-&gt;clearCache(模板，识别id)$smarty-&gt;clearAllCache(); //清楚所有缓存 $smarty-&gt;clearCache(&#39;demo18.html&#39;,&#39;red|4&#39;);清除有demeo18.html 模板生成的red 和 4组合的缓存2、$smarty-&gt;clearCache(‘demo18.html’,’red’) : 清除demo18.html 模板生成的带有red的缓存3、$smarty-&gt;clearCache(null,’red’); //清楚所有模板中带有red 的缓存 局部缓存 方法一：如果只有一个变量不缓存使用nocache属性模板文件{$smarty.now nocache} 方法二：如果有很多内容不缓存，使用{nocache}标签123&#123;nocache&#125;一大堆什么鬼东西，是会被动态加载的&#123;/nocache&#125; moneyPHP文件：1234require &apos;./Smarty/Smarty.class.php&apos;;$smarty = new Smarty();$smarty-&gt;caching = 1; //开启缓存$smarty-&gt;display(&apos;demo17.html&apos;,$_GET[&apos;pageno&apos;]) 模板文件：123456&lt;style type=&apos;text/css&apos;&gt;.aa&#123; color:red;&#125;&lt;/style&gt;&lt;div class=&apos;aa&apos;&gt;锄禾日当午&lt;/div&gt; 报错问题：源于大括号{}，Smarty将CSS中大括号当成了Smarty的定界符 解决方法：方法一：更改定界符方法二：在CSS和JS的大括号后面加上一个空格方法三：使用{literal}标签，在literal标签内的大括号不会被解析 Smarty的优点与缺点 因为可以生产缓存，所有速度快 如果要实时更新的内容很多的情况，不适合使用Smarty（比如，股票），如果一个小项目，不适合用]]></content>
      <tags>
        <tag>Smarty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP字符串函数大汇总]]></title>
    <url>%2F2015%2F20151012-Library-php-str-fun.html</url>
    <content type="text"><![CDATA[查找字符位置函数 strpos($str,search,[int]): 查找search在$str中的第一次位置从int开始 stripos($str,search,[int]): 函数返回字符串在另一个字符串中第一次出现的位置 strrpos($str,search,[int]): 查找search在$str中的最后一次出现的位置从int 提取子字符函数（双字节） submit($str,int start[,int length]): 从$str中strat位置开始提取[length长度的字符串]。 strstr($str1,$str2): 从$str1(第一个的位置)搜索$str2并从它开始截取到结束字符串;若没有则返回FALSE。 stristr() 功能同strstr，只是不区分大小写。 strrchr() 从最后一次搜索到的字符处返回；用处：取路径中文件名 替换字符串的PHP字符串函数 str_replace(search,replace,$str): 从$str中查找search用replace来替换 str_irreplace(search,replace,$str): strtr($str,search,replace): 这个函数中replace不能为””; substr_replace($Str,$rep,$start[,length]) $str原始字符串,$rep替换后的新字符串,$start起始位置,$length替换的长度，该项可选 字符长度 int strlen($str) 比较字符函数 int strcmp($str1,$str2): $str1&gt;=&lt;$str2分别为正1,0,-1（字符串比较） strcasecmp() 同上（不分大小写） strnatcmp(“4″,”14″) 按自然排序比较字符串 strnatcasecmp() 同上，（区分大小写） 分割成数组的PHP字符串函数 str_split($str,len): 把$str按len长度进行分割返回数组 split(search,$str[,int]): 把$str按search字符进行分割返回数组int是分割几次，后面的将不分割 expload(search,$str[,int]) 去除空格 ltrim、rtrim、trim HTML代码有关函数 nl2br()： 使n转换为。strip_tags($str[,’’])： 去除HTML和PHP标记.在$str中所有HTML和PHP代码将被去除，可选参数为html和PHP代码作用是将保留 如：echo strip_tags($text, ”); htmlspecialchars($str[,参数]):页面正常输出HTML代码参数是转换方式 字符大小写转换的PHP字符串函数 strtolower($str): 字符串转换为小写 strtoupper($str): 字符串转换为大写 ucfirst($str): 将函数的第一个字符转换为大写 ucwords($str): 将每个单词的首字母转换为大写 附： PHP字符串函数库，收集了51个PHP处理字符串的函数。包括计算字符串长度、分割字符串、查找字符串等等各个方面。 AddSlashes: 字符串加入斜线。bin2hex: 二进位转成十六进位。Chop: 去除连续空白。Chr: 返回序数值的字符。chunk_split: 将字符串分成小段。convert_cyr_string: 转换成其它字符串。crypt: 将字符串用 DES 编码加密。echo: 输出字符串。explode: 切开字符串。flush: 清出输出缓冲区。get_meta_tags: 抽出文件所有 meta 标记的资料。htmlspecialchars: 将特殊字符转成 HTML 格式。htmlentities: 将所有的字符都转成 HTML 字符串。implode: 将数组变成字符串。join: 将数组变成字符串。ltrim: 去除连续空白。md5: 计算字符串的 MD5 哈稀。nl2br: 将换行字符转成。Ord: 返回字符的序数值。parse_str: 解析 query 字符串成变量。print: 输出字符串。printf: 输出格式化字符串。quoted_printable_decode 将 qp 编码字符串转成 8 位字符串。QuoteMeta: 加入引用符号。rawurldecode: 从 URL 专用格式字符串还原成普通字符串。rawurlencode: 将字符串编码成 URL 专用格式。setlocale: 配置地域化信息。similar_text: 计算字符串相似度。soundex: 计算字符串的读音值sprintf: 将字符串格式化。strchr: 寻找第一个出现的字符。strcmp: 字符串比较。strcspn: 不同字符串的长度。strip_tags: 去掉 HTML 及 PHP 的标记。StripSlashes: 去掉反斜线字符。strlen: 取得字符串长度。strrpos: 寻找字符串中某字符最后出现处。strpos: 寻找字符串中某字符最先出现处。strrchr: 取得某字符最后出现处起的字符串。strrev: 颠倒字符串。strspn: 找出某字符串落在另一字符串遮罩的数目。strstr: 返回字符串中某字符串开始处至结束的字符串。strtok: 切开字符串。strtolower: 字符串全转为小写。strtoupper: 字符串全转为大写。str_replace: 字符串取代。strtr: 转换某些字符。substr: 取部份字符串。trim: 截去字符串首尾的空格。ucfirst: 将字符串第一个字符改大写。ucwords: 将字符串每个字第一个字母改大写。]]></content>
      <tags>
        <tag>PHP函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - 速度提升小技巧]]></title>
    <url>%2F2015%2F20151011-Library-php-skill.html</url>
    <content type="text"><![CDATA[MySQL数据库建表由于session没有长久保存的必要，所以建议sess表使用memory引擎，此引擎执行效率高。 数据insert数据delete数据update数据selectPHPC-S-R-F 保护C-S-R-F (跨网站请求伪造) 攻击，跨网站请求伪造是一种恶意的攻击，借以代表经过身份验证的用户执行未经授权的命令。 Laravel解决方案： Laravel 会自动在每一位用户的 session 中放置随机的 token ，这个 token 将被用来确保经过验证的用户是实际发出请求至应用程序的用户 插入 C-S-R-F Token 到表单type123当然也可以在Blade模板引擎使用：```&lt;input type=&quot;hidden&quot; name=&quot;_token&quot; value=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; Composer安装laravel框架方法一通过 composer Create-Project命令安装Laravelcomposer create-project laravel/laravel --prefer-dist[别名] 方法二laravel安装器12composer global require &quot;laravel/installer&quot;laravel new blog 检查安装状态12uiste:test uiste$ laravelLaravel Installer version 1.3.3 下载laravel12uiste:test uiste$ laravel new blogCrafting application...]]></content>
      <tags>
        <tag>PHP小技巧</tag>
        <tag>PHP加载速度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP常见错误提示]]></title>
    <url>%2F2015%2F20151011-1.html</url>
    <content type="text"><![CDATA[Fatal error: Call to undefined function……函数不存在，可能的原因：1、系统不存在这个函数且你也没自定义2、因为环境不同，这个函数在本环境配置文件没开，百度函数名字，就能查到函数属于哪个dll，在php.ini里开启 syntax error, unexpected T_STRING, expecting……严重语法错误，例如syntax error, unexpected T_STRING, expecting &#39;,&#39; or &#39;;&#39; in F:\phpnow\htdocs\index.php on line 4后边标着行号，去检查那一行的标点就行如果是 第三行 echo 1 后边没加;，报错会报 on line 4 Parse error: syntax error, unexpected T_VARIABLE in XXX.php on line XXX这条语句是PHP常见的报错，一般是在XXX行的上一行，或者是XXX行，缺少分号。或者在双引号中使用双引号，且没有转义等等。解决方法：找到XXX.php的XXX行，按照上面的分析，找到自己的错误，改正即可。 Parse error: syntax error, unexpected ‘X’ in XXX.php on line XXX这条语句依然是PHP常见的报错，报错原因是在XXX.php的XXX行，出现了PHP无法识别的字符。常常是因为function，if等需要‘{’、‘}’的地方没有闭合，或者在编程的时候，不小心在‘;’的后面误打了几个字符。解决方法：找到XXX.php的XXX行，删除多出的字符，添加缺少的字符即可。 syntax error, unexpected $end逻辑忘了闭合 这个报错还有个特征，他会提示你最后一行代码报错，譬如你一共30行，他就告诉你 on line 30，这时候你别检查第三十行，你要把30行挨个，检查一遍，看看哪个标签没闭合。一共3000行，他就告诉你 on line 3000，这时候你别检查这3000行了，如果你程序排版很乱，在3000行里找哪个括号是个很麻烦的事……我教你一招：ctrl+a ctrl+d alt+f4好了，你现在可以重写了。 Notice:Undefined varialbe:……这是一个比较常见的警告性提示，解决方法：error_reporting调整错误级别，不会调整，那就百度下]]></content>
      <tags>
        <tag>PHP错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - MySQL 两表联查 | 显示不同类型]]></title>
    <url>%2F2015%2F20151009-1.html</url>
    <content type="text"><![CDATA[两表联查需求不同商品的属性扩展如： 音乐：中文片名、英文片名、商品别名、介质/格式、国家地区、导演/指挥、主唱、长度、歌词书：作者、出版社、图书书号、出版日期、图书页数、字数、所属分类等… 思想通过对产品类型划分，使用属性类别(attr_type)表作为中间表，对属性(attribute)扩展连接。 代码12345//获取attr_type表数据 public function getAttrTypeList()&#123; $sql='select attr_type_name,count(attr_name) as `count` from attr_type natural left join attribute group by attr_type_id'; return $this-&gt;db-&gt;fetchAll($sql); &#125; 显示不同类型controller1234//显示属性$attr_type_id=isset($_GET['attr_type_id'])?(int)$_GET['attr_type_id']:0;$attr_model=new AttributeModel();$attr_list=$attr_model-&gt;getAttrByTypeId($attr_type_id); model12345678//通过属性类别id获取属性 public function getAttrByTypeId($attr_type_id)&#123; $sql="select * from attribute natural join attr_type where 1"; if($attr_type_id&gt;0) $sql.=" and attr_type_id=$attr_type_id"; $sql.=' order by attr_type_id'; return $this-&gt;db-&gt;fetchAll($sql); &#125; view1234567891011&lt;div class="form-div"&gt; &lt;form action="" name="searchForm"&gt; &lt;img src="/Application/View/Admin/images/icon_search.gif" width="26" height="22" border="0" alt="SEARCH"&gt; 按商品类型显示：&lt;select name="goods_type" onchange="location.href='index.php?p=Admin&amp;c=Attribute&amp;a=list&amp;attr_type_id='+this.value"&gt; &lt;option value="0"&gt;所有商品类型&lt;/option&gt; &lt;?php foreach($attr_type_list as $rows):?&gt; &lt;option value="&lt;?php echo $rows['attr_type_id']?&gt;" &lt;?php echo $rows['attr_type_id']==$attr_type_id?'selected':''?&gt;&gt;&lt;?php echo $rows['attr_type_name']?&gt;&lt;/option&gt; &lt;?php endforeach;?&gt; &lt;/select&gt; &lt;/form&gt;&lt;/div&gt; 切换选项禁用状态12345678910111213141516171819202122&lt;form action="" method="post" name="theForm" &gt;&lt;table width="100%" id="general-table"&gt; &lt;tr&gt; &lt;td class="label"&gt;该属性值的录入方式：&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="attr_input_type" value="0" checked="true" onclick="radioClicked(0)"&gt; 手工录入 &lt;input type="radio" name="attr_input_type" value="1" onclick="radioClicked(1)" &lt;?php echo $info['attr_input_type']==1?'checked':''?&gt;&gt;从下面的列表中选择（一行代表一个可选值） &lt;input type="radio" name="attr_input_type" value="2" onclick="radioClicked(0)" &lt;?php echo $info['attr_input_type']==2?'checked':''?&gt;&gt;多行文本框 &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt;/** * 点击类型按钮时切换选项的禁用状态 */function radioClicked(n)&#123; document.forms['theForm'].elements["attr_input_value"].disabled = n &gt; 0 ? false : true;&#125;&lt;/script&gt;]]></content>
      <tags>
        <tag>MySQL多表联查</tag>
        <tag>显示不同类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - 错误处理 | 异常处理]]></title>
    <url>%2F2015%2F20151008-2.html</url>
    <content type="text"><![CDATA[错误处理简介PHP独有的处理默认情况下，当错误发生的时候在浏览器上显示错误报告。可以使用操作符（@）来屏蔽语句生成的错误报告，注意@符号只对函数有用，对echo语句不起作用 错误级别按照错误的严重程度将错误划分为3种Notice：提示性错误Warning：警告性错误Fatal error：致命性错误 notice和warning级别错误后继续执行，error级别错误后终止执行 处理方式显示错误报告【默认】记录错误日志错误发生后交个自定义脚本去完成【比如，错误发生后发一个电子邮件】 错误触发PHP程序触发：PHP在运行的过程中，发现并触发错误。比如include、require等等。由用户触发，通过trigger_error()来触发错误。eg:定义年龄不能超过30，超过30即报错123$age = 30;if($age&gt;30) trigger_error(&quot;age cannot over 30&quot;,E_USER_ERROR); 用户错误的级别，他们是常量,默认触发notice错误。123;E_USER_ERROR - user-generated error message;E_USER_WARNING - user-generated warning message;E_USER_NOTICE - user-generated notice message 实现错误处理更改php配置有3种方法在php.ini中更改所有的虚拟目录中有效 .htaccess分布式部署文件.htaccess通过php_flag和php_value 在某个虚拟目录，或某个目录有效. ini_set()：某一个页面有效ini_set(&#39;display_errors&#39;:&#39;on&#39;) 开启错误显示ini_set(&#39;display_errors&#39;:&#39;off&#39;) 关闭错误显示 在浏览器上显示错误报告display_errors = On 在日志中显示错误报告log_errors = On错误日志保存的地址error_log = php_errors.log 用户自定义错误处理默认情况下，一旦定义了错误处理函数，则错误报告和错误日志不再执行 1234567&lt;?phpfunction error()&#123; echo '这是自定义错误';&#125;//注册错误处理函数set_error_handler('error');?&gt; 在自定义错误处理函数中添加return false，则自定义错误处理后再交个PHP处理。 应用：不同的级别使用不同错误处理12345678910111213141516171819202122232425262728293031&lt;?php/***@param $level 错误级别*@param $msg 错误信息*@param $file 错误文件*@param $line 错误行号*/function error($level,$msg,$file,$line) &#123; switch($level) &#123; case E_NOTICE: case E_USER_NOTICE: echo '将错误信息屏蔽掉&lt;br&gt;'; break; case E_WARNING : case E_USER_WARNING: echo '将错误信息记录到日志中&lt;br&gt;'; break; case E_ERROR: case E_USER_ERROR: echo '给管理员发邮件&lt;br&gt;'; break; &#125; echo "错误信息：&#123;$msg&#125;&lt;br&gt;"; echo "错误文件：&#123;$file&#125;&lt;br&gt;"; echo "错误行号：&#123;$line&#125;";&#125;set_error_handler('error'); //注册错误处理函数header('content-type:text/html;charset=utf-8');echo $aa,'&lt;hr&gt;';include './aa.php';?&gt; 指定显示错误级别;Error Level Constants:error_reporting = E_ALL | E_STRICT思考：为什么在php5.3中显示所有错误是E_ALL | E_STRICT？答：在php5.3中，E_ALL不是表示所有错误，E_ALL | E_STRICT也表示所有错误。在php5.4以上版本，E_ALL的错误都会报的。 E_ALL: 111011111111111E_STRICT:000100000000000 例题：只有PHP的notice才报错ini_set(&#39;error_reporting&#39;,E_NOTICE);只报PHP的notice和用户的noticeini_set(&#39;error_reporting&#39;,E_NOTICE | E_USER_NOTICE);系统的notice不报，其他全报ini_set(&#39;error_reporting&#39;,(E_ALL | E_STRICT) &amp; ~E_NOTICE); ~是按位取非，0变成1,1变成0。 123456789101112131415161718192021222324252627282930313233&lt;?php /** * 自定义错误处理函数 * @param int $level 错误级别 * @param string $msg 错误信息 * @param string $file 错误文件名 * @param int $line 错误行号 * @return Bool 错误处理情况 */function error($level,$msg,$file,$line)&#123; switch ($level) &#123; case E_NOTICE: case E_USER_NOTICE: echo '将错误屏蔽'; break; case E_WARNING: case E_USER_WARNING: echo '将错误记录在日志中&lt;br&gt;'; break; // case E_ERROR: //一般不设置，若报了该错误，程序将终止运行 case E_USER_ERROR: echo '将错误发送给管理员&lt;br&gt;'; break; &#125; echo '错误信息：'.$msg,"&lt;br&gt;"; echo '错误文件：'.$file."&lt;br&gt;"; echo '错误行号：'.$line,'&lt;br&gt;'; // return false 自定义错误处理完毕后，交给计算机继续处理 return false;&#125;// 注册错误函数set_error_handler('error');?&gt; 项目中的错误处理项目开发的时候错误显示在浏览器上，不用记录在日志中项目运行的时候错误记录在日志中，不显示在浏览器上 php.ini log_errors = on 开启错误日志 php.ini error_log = $log_path.$error_log; 将项目的运行模式分为“开发模式（调试模式）”和“运行模式” 在配置文件中，添加一个配置用来保存开发的模式 在Application文件夹下新建Log文件夹，用来保存日志 在Framework类中添加定义Log文件夹的路径常量 在Framework类中定义错误处理的方法1234567891011121314&lt;?php private static function initError()&#123; ini_set('error_reporting', E_ALL | E_STRICT); //报所有错误 if($GLOBALS['config']['app']['app_dubeg'])&#123;//开发模式 ini_set('display_errors','on'); //浏览器显示错误 ini_set('log_errors','off'); //不记录日志 &#125;else&#123; ini_set('display_errors','off'); //浏览器不显示错误 ini_set('log_errors','on'); //记录日志 $error_log = date('Y-m-d').'.log'; ini_set('error_log',LOG_PATH.$error_log); &#125;&#125; ?&gt; 异常处理异常处理使用关键字：try、catch、throw try:用来监测代码 thr ow：用来抛出异常 catch：用来捕获异常 Exception：PHP内置的异常类,是所有异常类的父类 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if(isset($_POST['button']))&#123; try&#123; $age = $_POST['age']; if ($age&lt;20 || $age&gt;30) &#123; throw new Exception('年龄必须在20到30之间');//抛出异常类 echo '错误抛出后这里不会再执行了'; &#125;else&#123; echo '青春年少，用行动做一辈子不能被注定的事！'; &#125; &#125;catch(Exception $e)&#123; //数据类型约束，只能是Exception //catch 用来捕获错误 echo '错误信息：'.$e-&gt;getMessage().'&lt;br&gt;'; echo '异常码：'.$e-&gt;getCode().'&lt;br&gt;'; echo '当前文件：'.$e-&gt;getFile().'&lt;br&gt;'; echo '异常行号：'.$e-&gt;getLine().'&lt;br&gt;'; &#125; &#125; ?&gt; &lt;form action="" method="post"&gt; 请输入年龄：&lt;input type="text" name="age"&gt;&lt;br&gt; &lt;input type="submit" name="button" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>PHP错误</tag>
        <tag>PHP异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - 文件上传 | 缩略图]]></title>
    <url>%2F2015%2F20151008-1.html</url>
    <content type="text"><![CDATA[文件上传 表单的enctype属性： application/x-www-fomr-urlencoded ：表示表单先服务器传输的文件数据。这是默认格式。(将表单的数据转成XML格式向服务器传输) multipart/form-data ：符合数据，告知浏览器表单中是符合数据（字符串，二进制文件） text/plain：用于向服务器传输大量文本，效率高，但时安全性低，用于发送邮件表示表单传输的数据类型 表单文件域 1234&lt;form method="post" action="" enctype="multipart/form-data"&gt; &lt;input type="file" name=""&gt; &lt;input type="submit" name="button" value="上传"&gt; &lt;/form&gt; 超全局变量$_FILES$_FILES[][&#39;name&#39;] ：上传文件名$_FILES[][&#39;size&#39;] ：文件上传的大小 $_FILES[][&#39;error&#39;] ：文件上传的错误号 0，1，2，3，4，6，7 UPLOAD_ERR_OK：值为 0，没有错误发生，文件上传成功。UPLOAD_ERR_INI_SIZE ： 值为 1，上传的文件超过了 php.ini 中 upload_max_filesize 选项限制的值。UPLOAD_ERR_FORM_SIZE：值为 2，上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。&lt;input type=&#39;hidden&#39; name=&#39;MAX_FILE_SIZE&#39; value=&#39;2&#39;&gt;,隐藏域必须在文件域前面才起作用。UPLOAD_ERR_PARTIAL：值为 3，文件只有部分被上传。UPLOAD_ERR_NO_FILE：值为 4，没有文件被上传。UPLOAD_ERR_NO_TMP_DIR：值为 6，找不到临时文件夹。PHP 4.3.10 和 PHP 5.0.3 引进。UPLOAD_ERR_CANT_WRITE：值为 7，文件写入失败。PHP 5.1.0 引进。 补充： 表单允许POST传输的最大值：post_max_size = 8M $_FILES[][&#39;type&#39;] ：上传文件格式，返回MIMIE格式 语法：类型/格式$_FILES[][&#39;tmp&#39;] ：文件上传的临时目录 upload_tmp_dir=&#39;F:\wamp\tmp&#39; 临时目录地址 php.ini 配置文件file_uploads = On 是否允许文件上传max_file_uploads = 20 同时最多允许上传20个文件 move_uploaded_file()移动上传文件bool move_uploaded_file ( string $filename , string $destination )$filename：上传的文件的文件名。$destination：移动文件到这个位置。 常用函数bool is_uploaded_file ( string $filename ) — 判断文件是否是通过 HTTP POST 上传的is_uploaded_file($_FILES[&#39;userfile&#39;][&#39;tmp_name&#39;])：用来确保恶意的用户无法欺骗脚本去访问本不能访问的文件，例如 /etc/passwd 文件名截取方法一：strrchr($filename,&#39;.&#39;); 从最后出现的点截取到末尾方法二：pathinfo($filename); 通过文件路径返回文件信息 123456789101112&lt;?php$path_parts = pathinfo('/www/htdocs/inc/lib.inc.php');echo $path_parts['dirname'], "\n";echo $path_parts['basename'], "\n";echo $path_parts['extension'], "\n";echo $path_parts['filename'], "\n"; // since PHP 5.2.0?&gt;/www/htdocs/inclib.inc.phpphplib.inc 以上两种方法方法可以被伪装（强制修改文件扩展名） 方法三：开启fileinfo扩展extension_fileinfo.dll 123$finfo = finfo_open(FILEINFO_MIME); //创建finfo对象，用来匹配文件$info = finfo_file($finfo,&apos;F:/image.jpg&apos;);//通过对象匹配文件var_dump($info);//显示文件信息 文件上传注意事项： 上传文件的大小限制（文件上传upload_max_filesize、post大小post_max_size、表单隐藏域&lt;input type=&#39;hidden&#39; name=&#39;MAX_FILE_SIZE&#39; value=&#39;2&#39;&gt;,文件域之前）文件格式验证的三种方法：路径截取、pathinfo、fileinfo 生成唯一文件名time().rand(100,999).strrchr($path,’.’); uniqid().strrchar($path,’.’); string uniqid ([ string $prefix = &quot;&quot; [, bool $more_entropy = false ]] ),可选前缀prefix、基于当前时间微秒数的唯一ID。设置第二个参数more_entropy为TRUE，返回唯一ID更具唯一性。 优化文件上传123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?php/*** +-------------------------------------------** | Author: uiste [ JUST DO IT ]** +-------------------------------------------** | Date: 2015/10/8 Time: 19:50 ** +-------------------------------------------** | Connection: &lt;blog.uiste.com&gt;** +-------------------------------------------*//** * Class UploadLib 文件上传类 */class UploadLib&#123; //保存操作获取的错误信息 private $error; //外部调用文件上传的错误信息 public function getError()&#123; return $this-&gt;error; &#125; /** * 文件上传优化类 * @param array $file 文件上传获取的数组信息 * @return string 上传文件的路径 */ public function upload($file)&#123; /** * 验证错误信息，保存到私有属性中 */ if ($file['error']!==0) &#123; switch ($file['error']) &#123; case 1: $this-&gt;error = "上传文件超过了配置文件中允许的最大值"; break; case 2: $this-&gt;error = "上传文件超过了表单允许的最大值"; break; case 3: $this-&gt;error = "只有部分文件上传，没有完全上传"; break; case 4: $this-&gt;error = "没有文件被上传"; break; case 6: $this-&gt;error = "找不到临时文件"; break; case 7: $this-&gt;error = "文件写入失败"; break; default: $this-&gt;error = "其它未知错误"; break; &#125; return false; &#125; /** * 验证文件类型 * @param array $allow_types 允许上传的文件类型 * @param resource $finfo MIME资源，用于finfo_file匹配需求 * @param string $info 文件类型与编码信息的字符串 * @param array $type_mime 截取mime文件类型 */ $allow_types = array("image/jpeg","image/png","image/gif"); $finfo = finfo_open(FILEINFO_MIME); $info = finfo_file($finfo, $file['tmp_name']); $info_array = explode(';',$info); $type_mime = $info_array[0]; if (!in_array($type_mime,$allow_types)) &#123; $this-&gt;error = "文件类型错误，不能上传".$type_mime."类型的文件"; return false; &#125; /** * 验证文件类型 * @param byte $file['size'] 上传文件的大小 * @param byte $GLOBALS['config']['file']['allow_size'] 网站允许上传的文件大小 */ if ($file['size']&gt;$GLOBALS['config']['file']['allow_size']) &#123; $this-&gt;error = "上传文件大小是:".number_format($file['size']/1024/1024,2)."M;超过了网站允许的最大值:".number_format($GLOBALS['config']['file']['allow_size']/1024/1024,2)."M"; return false; &#125; /** * 验证文件是否通过HTTP POST上传 */ if (!is_uploaded_file($file['tmp_name'])) &#123; $this-&gt;error = "非法上传文件，必须通过HTTP上传"; return false; &#125; /** * 创建上传文件夹 * @param array $type 拆分MIME类型文件类型与文件格式 * @param string $folder_set 定义级联文件夹 * @param string $folder_path 网站配置上传文件路径与级联路径后的全路径 * @param string $file_name 上传文件重新生成的唯一文件名 * @param string $file_path 文件全路径，包含文件名 */ $type = explode('/', $type_mime);//获取的文件类型与文件格式两个值 $folder_set = $type[0].DS.$type[1].DS.date('Ym').DS; $folder_path = $GLOBALS['config']['file']['upload_path'].DS.$folder_set; $file_name = uniqid('',true).'.'.$type[1]; $file_path = $folder_path.$file_name; if (!file_exists($folder_path)) &#123; if (!mkdir($folder_path,0777,true)) &#123; $this-&gt;error = "上传文件夹创建失败"; return false; &#125; &#125; //上传文件 if (move_uploaded_file($file['tmp_name'], $file_path)) &#123; return $folder_set.$file_name; &#125;else&#123; $this-&gt;error = "文件上传失败"; &#125; &#125;&#125;?&gt; 多文件上传表单命名以数组的形式，接收到的数据，按相同的属性组成一个索引数组 缩略图 bool imagecopyresampled ( resource $dst_image , resource $src_image , int $dst_x , int $dst_y , int $src_x , int $src_y , int $dst_w , int $dst_h , int $src_w , int $src_h )重采样拷贝部分图像并调整大小 dst_image：目标图象连接资源。src_image：源图象连接资源。dst_x：目标 X 坐标点。dst_y：目标 Y 坐标点。src_x：源的 X 坐标点。src_y：源的 Y 坐标点。dst_w：目标宽度。dst_h：目标高度。src_w：源图象的宽度。src_h：源图象的高度 等比缩略图 思想：按图的长宽比例进行比较，源图的比例大的为标准，短边进行等比压缩。 压缩目标图边的长度=源图缩放边的长度*目标图标准边长度/源图标准边的长度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?php/*** +-------------------------------------------** | Author: uiste [ JUST DO IT ]** +-------------------------------------------** | Date: 2015/10/8 Time: 19:50 ** +-------------------------------------------** | Connection: &lt;blog.uiste.com&gt;** +-------------------------------------------*//** * Class ThumbLib 生成缩略图 */class ThumbLib&#123; //保存操作获取的错误信息 private $error; //外部调用文件上传的错误信息 public function getError()&#123; return $this-&gt;error; &#125; /** * 生成缩略图 * @param string $src_path 源图路径资源 * @param int $max_w 缩略图的最大宽度，若调用时不传递就直接使用配置文件的大小 * @param int $max_h 缩略图的最大高度，同上 * @param bool $is_ration 是否等比缩放 * @param string $prefix 缩略图文件名前缀 * @return string 返回缩略图路径 */ public function thumb($src_path,$max_w='',$max_h='',$is_ratio=true,$prefix='small_')&#123; $max_w = $max_w!='' ? $max_w : $GLOBALS['config']['file']['thumb_w'] ; $max_h = $max_h!='' ? $max_h : $GLOBALS['config']['file']['thumb_h'] ; $ext = strtolower(strrchr($src_path,'.'));//获取文件的后缀 $type = ''; switch ($ext) &#123; case '.jpg': $type = 'jpeg'; break; case '.jpeg': $type = 'jpeg'; break; case '.png': $type = 'png'; break; case '.gif': $type = 'gif'; break; default: $this-&gt;error = "不支持该文件类型".$ext; return false; &#125; $open_fn = 'imagecreatefrom'.$type; //拼接函数名 // 创建缩略图画布 $dst_img = imagecreatetruecolor($max_w, $max_h); // 打开源图片资源 $src_path_all = $GLOBALS['config']['file']['upload_path'].DS.$src_path; if(!$src_img = $open_fn($src_path_all))&#123; $this-&gt;error = "源图路径错误或者不全"; return false; &#125; $src_w = imagesx($src_img); $src_h = imagesy($src_img); if ($is_ratio) &#123; if ($src_w/$src_h&gt;$max_w/$max_h) &#123; #若源图的宽度较长，则等比缩放高度 $dst_w = $max_w; $dst_h = $dst_w*$src_h/$src_w; &#125;else&#123; #如源图的高度较长，则等比缩放宽度 $dst_h = $max_h; $dst_w = $dst_h*$src_w/$src_h; &#125; &#125; // 求目标图的坐标 $dst_x = (int)(($max_w-$dst_w)/2); $dst_y = (int)(($max_h-$dst_h)/2); // 生成缩略图 imagecopyresampled($dst_img, $src_img, $dst_x, $dst_y, 0, 0, $dst_w, $dst_h, $src_w, $src_h); // 保存缩略图 $folderpath = dirname($src_path);//获取目录地址 $filename = basename($src_path); //获取文件名 $small_path = $GLOBALS['config']['file']['upload_path'].DS.$folderpath.DS.$prefix.$filename; //缩略图的全路径 $save_fn = 'image'.$type; $save_fn($dst_img,$small_path); // 关闭资源 imagedestroy($src_img); imagedestroy($dst_img); // 返回缩略图保存路径 return $folderpath.DS.$prefix.$filename; &#125;&#125;?&gt;]]></content>
      <tags>
        <tag>PHP思想养成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - 递归实现无限极联动]]></title>
    <url>%2F2015%2F20151007-1.html</url>
    <content type="text"><![CDATA[递归实现无限极联动123456789101112131415161718192021222324252627282930313233343536&lt;?phpmysql_connect('localhost','root','aa');mysql_select_db('php6');mysql_query('set names utf8');//获取所有类别$sql='select * from category';$rs=mysql_query($sql);//将资源转成二维数组$list=array();while($rows=mysql_fetch_assoc($rs)) &#123; $list[]=$rows;&#125;/***将二维数组按树形结构显示【递归】*@param $list array 存放所有类别的二维数组*@param $parentid int 在数组中查找属于某个父类的子级*@param $deep int 元素的缩进深度*/function createTree($list,$parentid=0,$deep=0) &#123; static $tree=array(); //声明一个静态数组，这样在整个递归过程中一直存在 foreach($list as $rows) &#123; if($rows['parentid']==$parentid)&#123; $rows['deep']=$deep; $tree[]=$rows; createTree($list,$rows['cat_id'],$deep+1); &#125; &#125; return $tree;;&#125;//测试$array=createTree($list);foreach($array as $rows) &#123; //str_repeat()：字符串重复 echo str_repeat('&amp;nbsp;',$rows['deep']*20),$rows['cat_name'],'&lt;br&gt;';&#125;?&gt; 二级联动12345678910111213141516171819202122232425262728&lt;?php//连接数据库mysql_connect('localhost','root','aa');mysql_select_db('php6');mysql_query('set names utf8');//获取第一级$sql="select * from category where parentid=0";$rs1=mysql_query($sql);?&gt;&lt;select name=""&gt; &lt;?php while($rows1=mysql_fetch_assoc($rs1)): ?&gt; &lt;optgroup label="&lt;?php echo $rows1['cat_name']?&gt;"&gt; &lt;?php $sql="select * from category where parentid=".$rows1['cat_id']; $rs2=mysql_query($sql); while($rows2=mysql_fetch_assoc($rs2)): ?&gt; &lt;option value="&lt;?php echo $rows2['cat_id']?&gt;"&gt;&lt;?php echo $rows2['cat_name']?&gt;&lt;/option&gt; &lt;?php endwhile; ?&gt; &lt;/optgroup&gt; &lt;?php endwhile; ?&gt;&lt;/select&gt; 三级联动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script type="text/javascript"&gt;/**@param cat1 int 一级的id*@param cat2 int 二级的id*/function jump(cat1,cat2) &#123; location.href='?cat1='+cat1+'&amp;cat2='+cat2;&#125;&lt;/script&gt;&lt;?php mysql_connect('localhost','root','aa'); mysql_select_db('php6'); mysql_query('set names utf8'); //获取一级和二级的编号 $cat1=isset($_GET['cat1'])?(int)$_GET['cat1']:''; //获取传递的一级编号 $cat2=isset($_GET['cat2'])?(int)$_GET['cat2']:''; //获取传递的二级编号?&gt;&lt;!--一级--&gt;&lt;select id="cat1" onchange='jump(this.value,"")'&gt;&lt;option value=""&gt;---请选择---&lt;/option&gt;&lt;?php $sql="select * from category where parentid=0"; $rs=mysql_query($sql); while($rows=mysql_fetch_assoc($rs)):?&gt; &lt;option value="&lt;?php echo $rows['cat_id']?&gt;" &lt;?php echo $cat1==$rows['cat_id']?'selected':''?&gt;&gt;&lt;?php echo $rows['cat_name']?&gt;&lt;/option&gt;&lt;?php endwhile;?&gt; &lt;/select&gt;&lt;!--二级--&gt;&lt;select id="cat2" onchange='jump(document.getElementById("cat1").value,this.value)'&gt;&lt;option value=""&gt;---请选择---&lt;/option&gt;&lt;?php if(isset($_GET['cat1'])): $sql="select * from category where parentid=$cat1"; $rs=mysql_query($sql); while($rows=mysql_fetch_assoc($rs)):?&gt; &lt;option value="&lt;?php echo $rows['cat_id']?&gt;" &lt;?php echo $cat2==$rows['cat_id']?'selected':''?&gt;&gt;&lt;?php echo $rows['cat_name']?&gt;&lt;/option&gt;&lt;?php endwhile; endif;?&gt;&lt;/select&gt;&lt;select id="cat3"&gt;&lt;option value=""&gt;---请选择---&lt;/option&gt;&lt;?php if(!empty($_GET['cat2'])): $sql="select * from category where parentid=$cat2"; $rs=mysql_query($sql); while($rows=mysql_fetch_assoc($rs)):?&gt; &lt;option value="&lt;?php echo $rows['cat_id']?&gt;" &gt;&lt;?php echo $rows['cat_name']?&gt;&lt;/option&gt;&lt;?php endwhile; endif;?&gt;&lt;/select&gt;]]></content>
      <tags>
        <tag>PHP思想养成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步的JavaScript和XML]]></title>
    <url>%2F2015%2F20151005-1.html</url>
    <content type="text"><![CDATA[概念介绍AJAX的全称Asynchronous JavaScript and XML异步的JavaScript和XML 作用：在无需重新加载整个网页的情况下，能够更新部分网页的技术通过少量数据交换，实现异部局部更新 应用：社交软件，地图 操作步骤：1、利用html+css来实现页面，表达信息；2、用XMLHttpRequest和web服务器进行数据的异步交换3、运营js操作DOM，实现动态局部刷新； XMLHttpRequest对象的出现分割了同步和异步。XMLHttpRequest出现之前是同步的，出现之后是异步的。同步：页面请求实时传给服务器，导致必填数据没有填的时候，要回到页面上重新从头填写，耗时长、客户体验差。异步：在页面必填项写上必填选项，不用通过传给服务器判断必填内容是否已经填写完整，耗时短、用户体验强。 HTTP请求一个完整地HTTP请求过程，通常有7个步骤1.建立TCP连接2.Web浏览器向Web服务器发送请求命令3.Web浏览器发送请求头信息4.Web服务器应答5.Web服务器发送应答头信息6.Web服务器向浏览器发送数据7.Web服务器关闭TCP连接 一个HTTP请求一般由四部分组成1.HTTP请求的方法或动作，比如是GET还是POST请求2.正在请求的URL，总得知道请求的地址是什么吧3.请求头，包含一些客户端环境信息，身份验证信息等4.请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等 一个HTTP响应一般由三部分组成1.一个数字和文字组成的状态码，用来显示请求是成功还是失败2.响应头，响应头也和请求头一样包含许多有用的信息，例如服务器类型、日期时间、内容类型和长度等3.响应体，也就是响应正文 GET： 一般用于信息获取 使用URL传递参数 对所发送信息的数量也有限制，一般在2000个字符 POST： 一般用于修改服务器上的资源 对所发送信息的数量无限制 HTTP状态码HTTP状态码由3位数字构成，其中首位数字定义了状态码的类型：1XX：信息类，表示收到Web浏览器请求，正在进一步的处理中。2XX：成功，表示用户请求被正确接收，理解和处理，例如：200 OK3XX：重定向，表示请求没有成功，客户必须采取进一步的动作4XX：客户端错误，表示客户端提交的请求有错误，例如：400 NOT FOUND 意味着请求中所引起的文档不存在5XX：服务器错误，表示服务器不能完成对请求的处理：如500 XMLHttpRequest发送请求var request = new XMLHttpRequset();open(method,url,async)send(string) GET 发送请求 12request.open(&apos;GET&apos;,&apos;get.php?id=55&apos;,true);request.send(); POST 发送请求 123request.open(&quot;POST&quot;,&quot;create.php&quot;,true);request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);request.send(&quot;name=uiste&amp;sex=man&quot;); XMLHttpRequset取得响应responseText：获得字符串形式的响应数据responseXML： 获得XML形式的响应数据status和statusText：以数字和文本形式返回HTTP状态码getAllResponseHeader()：获取所有的响应报头getResponseHeader()：查询响应中的某个字段的值 readyState属性0：请求未初始化，open还没有调用1：服务器连接已建立，open已经调用了2：请求已接收，也就是接收到头信息了3：请求处理中，也就是接收到响应主体了4：请求已完成，且响应已就绪，也就是响应完成了 源码案例 json12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt;document.getElementById("search").onclick = function() &#123; var request = new XMLHttpRequest(); request.open("GET", "serverjson.php?number=" + document.getElementById("keyword").value); request.send(); request.onreadystatechange = function() &#123; if (request.readyState===4) &#123; if (request.status===200) &#123; var data = JSON.parse(request.responseText); if (data.success) &#123; document.getElementById("searchResult").innerHTML = data.msg; &#125; else &#123; document.getElementById("searchResult").innerHTML = "出现错误：" + data.msg; &#125; &#125; else &#123; alert("发生错误：" + request.status); &#125; &#125; &#125;&#125;document.getElementById("save").onclick = function() &#123; var request = new XMLHttpRequest(); request.open("POST", "serverjson.php"); var data = "name=" + document.getElementById("staffName").value + "&amp;number=" + document.getElementById("staffNumber").value + "&amp;sex=" + document.getElementById("staffSex").value + "&amp;job=" + document.getElementById("staffJob").value; request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); request.send(data); request.onreadystatechange = function() &#123; if (request.readyState===4) &#123; if (request.status===200) &#123; var data = JSON.parse(request.responseText); if (data.success) &#123; document.getElementById("createResult").innerHTML = data.msg; &#125; else &#123; document.getElementById("createResult").innerHTML = "出现错误：" + data.msg; &#125; &#125; else &#123; alert("发生错误：" + request.status); &#125; &#125; &#125;&#125;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php//设置页面内容是html编码格式是utf-8header("Content-Type: text/plain;charset=utf-8"); //header("Content-Type: application/json;charset=utf-8"); //header("Content-Type: text/xml;charset=utf-8"); //header("Content-Type: text/html;charset=utf-8"); //header("Content-Type: application/javascript;charset=utf-8"); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array("name" =&gt; "洪七", "number" =&gt; "101", "sex" =&gt; "男", "job" =&gt; "总经理"), array("name" =&gt; "郭靖", "number" =&gt; "102", "sex" =&gt; "男", "job" =&gt; "开发工程师"), array("name" =&gt; "黄蓉", "number" =&gt; "103", "sex" =&gt; "女", "job" =&gt; "产品经理") );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER["REQUEST_METHOD"]返回访问页面使用的请求方法if ($_SERVER["REQUEST_METHOD"] == "GET") &#123; search();&#125; elseif ($_SERVER["REQUEST_METHOD"] == "POST")&#123; create();&#125;//通过员工编号搜索员工function search()&#123; //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET["number"]) || empty($_GET["number"])) &#123; echo '&#123;"success":false,"msg":"参数错误"&#125;'; return; &#125; //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET["number"]; $result = '&#123;"success":false,"msg":"没有找到员工。"&#125;'; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) &#123; if ($value["number"] == $number) &#123; $result = '&#123;"success":true,"msg":"找到员工：员工编号：' . $value["number"] . '，员工姓名：' . $value["name"] . '，员工性别：' . $value["sex"] . '，员工职位：' . $value["job"] . '"&#125;'; break; &#125; &#125; echo $result;&#125;//创建员工function create()&#123; //判断信息是否填写完全 if (!isset($_POST["name"]) || empty($_POST["name"]) || !isset($_POST["number"]) || empty($_POST["number"]) || !isset($_POST["sex"]) || empty($_POST["sex"]) || !isset($_POST["job"]) || empty($_POST["job"])) &#123; echo '&#123;"success":false,"msg":"参数错误，员工信息填写不全"&#125;'; return; &#125; //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo '&#123;"success":true,"msg":"员工：' . $_POST["name"] . ' 信息保存成功！"&#125;';&#125;?&gt; jQuery1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt;$(document).ready(function()&#123; $("#search").click(function()&#123; $.ajax(&#123; type: "GET", url: "http://127.0.0.1:8080/ajaxdemo/serverjson2.php?number=" + $("#keyword").val(), dataType: "json", success: function(data) &#123; if (data.success) &#123; $("#searchResult").html(data.msg); &#125; else &#123; $("#searchResult").html("出现错误：" + data.msg); &#125; &#125;, error: function(jqXHR)&#123; alert("发生错误：" + jqXHR.status); &#125;, &#125;); &#125;); $("#save").click(function()&#123; $.ajax(&#123; type: "POST", url: "serverjson.php", data: &#123; name: $("#staffName").val(), number: $("#staffNumber").val(), sex: $("#staffSex").val(), job: $("#staffJob").val() &#125;, dataType: "json", success: function(data)&#123; if (data.success) &#123; $("#createResult").html(data.msg); &#125; else &#123; $("#createResult").html("出现错误：" + data.msg); &#125; &#125;, error: function(jqXHR)&#123; alert("发生错误：" + jqXHR.status); &#125;, &#125;); &#125;);&#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php//设置页面内容是html编码格式是utf-8//header(&quot;Content-Type: text/plain;charset=utf-8&quot;); header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:POST,GET&apos;);header(&apos;Access-Control-Allow-Credentials:true&apos;); header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) &#123; search();&#125; elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)&#123; create();&#125;//通过员工编号搜索员工function search()&#123; //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) &#123; echo &apos;&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;&#125;&apos;; return; &#125; //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = &apos;&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;&#125;&apos;; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) &#123; if ($value[&quot;number&quot;] == $number) &#123; $result = &apos;&#123;&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：&apos; . $value[&quot;number&quot;] . &apos;，员工姓名：&apos; . $value[&quot;name&quot;] . &apos;，员工性别：&apos; . $value[&quot;sex&quot;] . &apos;，员工职位：&apos; . $value[&quot;job&quot;] . &apos;&quot;&#125;&apos;; break; &#125; &#125; echo $result;&#125;//创建员工function create()&#123; //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) &#123; echo &apos;&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;&#125;&apos;; return; &#125; //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo &apos;&#123;&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：&apos; . $_POST[&quot;name&quot;] . &apos; 信息保存成功！&quot;&#125;&apos;;&#125;?&gt; jQuery-json12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script&gt;$(document).ready(function()&#123; $(&quot;#search&quot;).click(function()&#123; $.ajax(&#123; type: &quot;GET&quot;, url: &quot;http://127.0.0.1:8000/ajaxdemo/serverjsonp.php?number=&quot; + $(&quot;#keyword&quot;).val(), dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;, success: function(data) &#123; if (data.success) &#123; $(&quot;#searchResult&quot;).html(data.msg); &#125; else &#123; $(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg); &#125; &#125;, error: function(jqXHR)&#123; alert(&quot;发生错误：&quot; + jqXHR.status); &#125;, &#125;); &#125;); $(&quot;#save&quot;).click(function()&#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;http://127.0.0.1:8000/ajaxdemo/serverjsonp.php&quot;, data: &#123; name: $(&quot;#staffName&quot;).val(), number: $(&quot;#staffNumber&quot;).val(), sex: $(&quot;#staffSex&quot;).val(), job: $(&quot;#staffJob&quot;).val() &#125;, dataType: &quot;json&quot;, success: function(data)&#123; if (data.success) &#123; $(&quot;#createResult&quot;).html(data.msg); &#125; else &#123; $(&quot;#createResult&quot;).html(&quot;出现错误：&quot; + data.msg); &#125; &#125;, error: function(jqXHR)&#123; alert(&quot;发生错误：&quot; + jqXHR.status); &#125;, &#125;); &#125;);&#125;);&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php//设置页面内容是html编码格式是utf-8//header(&quot;Content-Type: text/plain;charset=utf-8&quot;); header(&quot;Content-Type: application/json;charset=utf-8&quot;); //header(&quot;Content-Type: text/xml;charset=utf-8&quot;); //header(&quot;Content-Type: text/html;charset=utf-8&quot;); //header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); //定义一个多维数组，包含员工的信息，每条员工信息为一个数组$staff = array ( array(&quot;name&quot; =&gt; &quot;洪七&quot;, &quot;number&quot; =&gt; &quot;101&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;总经理&quot;), array(&quot;name&quot; =&gt; &quot;郭靖&quot;, &quot;number&quot; =&gt; &quot;102&quot;, &quot;sex&quot; =&gt; &quot;男&quot;, &quot;job&quot; =&gt; &quot;开发工程师&quot;), array(&quot;name&quot; =&gt; &quot;黄蓉&quot;, &quot;number&quot; =&gt; &quot;103&quot;, &quot;sex&quot; =&gt; &quot;女&quot;, &quot;job&quot; =&gt; &quot;产品经理&quot;) );//判断如果是get请求，则进行搜索；如果是POST请求，则进行新建//$_SERVER是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字//$_SERVER[&quot;REQUEST_METHOD&quot;]返回访问页面使用的请求方法if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) &#123; search();&#125; elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)&#123; create();&#125;//通过员工编号搜索员工function search()&#123; $jsonp = $_GET[&quot;callback&quot;]; //检查是否有员工编号的参数 //isset检测变量是否设置；empty判断值为否为空 //超全局变量 $_GET 和 $_POST 用于收集表单数据 if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) &#123; echo $jsonp . &apos;(&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;&#125;)&apos;; return; &#125; //函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。 //global 关键词用于访问函数内的全局变量 global $staff; //获取number参数 $number = $_GET[&quot;number&quot;]; $result = $jsonp . &apos;(&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;&#125;)&apos;; //遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果 foreach ($staff as $value) &#123; if ($value[&quot;number&quot;] == $number) &#123; $result = $jsonp . &apos;(&#123;&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：&apos; . $value[&quot;number&quot;] . &apos;，员工姓名：&apos; . $value[&quot;name&quot;] . &apos;，员工性别：&apos; . $value[&quot;sex&quot;] . &apos;，员工职位：&apos; . $value[&quot;job&quot;] . &apos;&quot;&#125;)&apos;; break; &#125; &#125; echo $result;&#125;//创建员工function create()&#123; //判断信息是否填写完全 if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;]) || !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;]) || !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;]) || !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) &#123; echo &apos;&#123;&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;&#125;&apos;; return; &#125; //TODO: 获取POST表单数据并保存到数据库 //提示保存成功 echo &apos;&#123;&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：&apos; . $_POST[&quot;name&quot;] . &apos; 信息保存成功！&quot;&#125;&apos;;&#125;?&gt;]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel - 表单操作]]></title>
    <url>%2F2015%2F20151001-1.html</url>
    <content type="text"><![CDATA[静态资源管理及模板布局表单列表及分页实现通过表单实现新增及操作状态提示功能设置成功之后有提示？使用session的暂存数据，也就是flash，跟上一个with即可？？？ 表单验证及数据保持详解控制器验证Validator数据保持 123456789101112131415161718192021222324//添加学生信息 //接收表单提交数据-create方法 public function create(Request $request)&#123; if($request-&gt;isMethod(&apos;POST&apos;))&#123; //表单验证必填项，最小2个字符，最大20字符 $this-&gt;validate($request,[ &apos;student.name&apos; =&gt; &apos;required|min:2|max:20&apos;, &apos;student.age&apos; =&gt; &apos;required|integer&apos;, &apos;student.sex&apos; =&gt; &apos;required|integer&apos; ]); $data = $request-&gt;input(&apos;student&apos;);// 保存提交数据方法一// $student = new Student();// $student-&gt;name = $data[&apos;name&apos;];// $student-&gt;age = $data[&apos;age&apos;];// $student-&gt;sex = $data[&apos;sex&apos;];// if($student-&gt;save()) if(Student::create($data)) retur n redirect(&apos;student/index&apos;)-&gt;with(&apos;success&apos;,&apos;添加成功&apos;);// return redirect(&apos;student/index&apos;); return redirect()-&gt;back(); &#125; return view(&apos;student.create&apos;); &#125; 通过模型处理性别通过表单实现修改表单中查看详情及删除]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel - 控制器基础]]></title>
    <url>%2F2015%2F20150930-4.html</url>
    <content type="text"><![CDATA[路径：app/Http/Controllers 基础控制器12345678910111213141516171819&lt;?php namespace App\Http\Controllers;use App\Http\Controllers\Controller;class UserController extends Controller &#123; /** * 显示所给定的用户个人数据。 * * @param int $id * @return Response */ public function showProfile($id) &#123; return view('user.profile', ['user' =&gt; User::findOrFail($id)]); &#125;&#125;?&gt; 可以通过如下方式引导路由至对应的控制器动作：Route::any(&#39;test1&#39;,[&#39;uses&#39;=&gt;&#39;StudentController@test1&#39;]); Controller之RequestController之SessionController之ResponseController之Middlewarelaravel中间件提供一个方便的机制来过滤进入应用程序的HTTP请求 第一步新建中间件Middleware=&gt;Activity.php 12345678910111213141516&lt;?php namespace App\Http\Middleware;use closure;class Activity&#123; //新建一个固定的方法handle($request,$next); //next 是一个全局的包 //请求执行前操作，前置操作 //$next($request)响应 public function handle($request,$next)&#123; if (time()&lt;strtotime(&apos;2015-10-2&apos;)) &#123; return redirect(&apos;activity0&apos;); &#125; return $next($request); &#125;&#125;?&gt; 第二步注册中间件Kernel.php=&gt;protected $routeMiddleware &#39;activity&#39; =&gt; \App\Http\Middleware\Activity::class 第三步使用中间件routes.php 123456 Route::any(&apos;activity0&apos;,[&apos;uses&apos;=&gt;&apos;StudentController@activity0&apos;]); //使用中间件 Route::group([&apos;middleware&apos;=&gt;&apos;activity&apos;],function()&#123; Route::any(&apos;activity1&apos;,[&apos;uses&apos;=&gt;&apos;StudentController@activity1&apos;]); Route::any(&apos;activity2&apos;,[&apos;uses&apos;=&gt;&apos;StudentController@activity2&apos;]);&#125;); 补充StudentController： 123456789public function activity0()&#123; return &apos;活动快要开始了，敬请期待&apos;; &#125; public function activity1()&#123; return &apos;活动进行中，谢谢您的参与&apos;; &#125; public function activity2()&#123; return &apos;活动仍在进行中，谢谢参与&apos;; &#125;]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel - 路由基础]]></title>
    <url>%2F2015%2F20150930-3.html</url>
    <content type="text"><![CDATA[laravel框架与传统框架的不同：laravel框架不同于传统的MVC，传统的MVC请求一般直接对应的是控制器，laravel中的请求对应的是路由laravel中的路由简单来说就是将用户的请求转发给相应的程序进行处理作用就是建立URL和程序之间的映射请求类型：get、post、put、patch、delete 基本路由路径：app/Http/routes.php中定义应用中的大多数路由该文件加载了App\Providers\RouteServiceProvider类 GET路由1234Route::get(&apos;/&apos;, function()&#123; return &apos;Hello World&apos;;&#125;); 其它路由1234567891011121314Route::post(&apos;foo/bar&apos;, function()&#123; return &apos;Hello World&apos;;&#125;);Route::put(&apos;foo/bar&apos;, function()&#123; //&#125;);Route::delete(&apos;foo/bar&apos;, function()&#123; //&#125;); match请求注册多路由1234Route::match([&apos;get&apos;, &apos;post&apos;], &apos;/&apos;, function()&#123; return &apos;Hello World&apos;;&#125;); any注册路由所有http请求1234Route::any(&apos;foo&apos;, function()&#123; return &apos;Hello World&apos;;&#125;); 路由产生 URL，可以使用 url 辅助函数来操作：$url = url(‘foo’); 路由参数基本路由参数1234Route::get(&apos;user/&#123;id&#125;&apos;, function($id)&#123; return &apos;User &apos;.$id;&#125;); 路由参数不能包含 - 字符。使用下划线替代 (_)。 可选择路由参数/带默认值参数1234Route::get(&apos;user/&#123;name?&#125;&apos;, function($name = &apos;John&apos;)&#123; return $name;&#125;); 使用正则表达式限制参数12345Route::get(&apos;user/&#123;id&#125;/&#123;name&#125;&apos;, function($id, $name)&#123; //&#125;)-&gt;where([&apos;id&apos; =&gt; &apos;[0-9]+&apos;, &apos;name&apos; =&gt; &apos;[a-z]+&apos;]); 命名路由使用as方便产生URL1234Route::get(&apos;user/profile&apos;, [&apos;as&apos; =&gt; &apos;profile&apos;, function()&#123; return route(&apos;profile&apos;);&#125;]); 为控制器方法指定路由名称123Route::get(&apos;user/profile&apos;, [ &apos;as&apos; =&gt; &apos;profile&apos;, &apos;uses&apos; =&gt; &apos;UserController@showProfile&apos;]); 路由群组Middleware在群组共享属性数组的 middleware 参数定义中间件列表，这些中间件就会应用到群组内的所有路由上。中间件将会按在列表内指定的顺序执行： 12345678910111213Route::group([&apos;middleware&apos; =&gt; [&apos;foo&apos;, &apos;bar&apos;]], function()&#123; Route::get(&apos;/&apos;, function() &#123; // Has Foo And Bar Middleware &#125;); Route::get(&apos;user/profile&apos;, function() &#123; // Has Foo And Bar Middleware &#125;);&#125;); Namespaces可以在 group 属性数组中使用 namespace 参数，指定在这群组中控制器的命名空间： 123456789Route::group([&apos;namespace&apos; =&gt; &apos;Admin&apos;], function()&#123; // Controllers Within The &quot;App\Http\Controllers\Admin&quot; Namespace Route::group([&apos;namespace&apos; =&gt; &apos;User&apos;], function() &#123; // Controllers Within The &quot;App\Http\Controllers\Admin\User&quot; Namespace &#125;);&#125;); 在默认情况下，RouteServiceProvider 包含内置您命名空间群组的 routes.php 文件，让您不须使用完整的 App\Http\Controllers 命名空间前缀就可以注册控制器路由。]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel - 安装laravel框架]]></title>
    <url>%2F2015%2F20150930-2.html</url>
    <content type="text"><![CDATA[Composer 安装 Laravel 有两种方式： 第一种是通过 Composer 的 create-project 命令安装 Laravel 框架，第二种是先通过 Composer 安装 Laravel 安装器，然后通过安装器安装 Laravel 框架。 为什么 Composer 可以安装 Laravel 框架呢？ 其实 Laravel框架也是一个 Composer包，我们可以通过如下命令查看： 12345678910111213141516171819202122232425262728uiste:~ uiste$ composer show --all laravel/laravelNo composer.json found in the current directory, showing available packages from packagistname : laravel/laraveldescrip. : The Laravel Framework.keywords : framework, laravelversions : dev-master, v5.3.10, v5.3.0, 5.2.x-dev, v5.2.31, v5.2.29, v5.2.27, v5.2.24, v5.2.23, v5.2.15, v5.2.0, 5.1.x-dev, v5.1.33, v5.1.11, v5.1.4, v5.1.3, v5.1.1, v5.1.0, 5.0.x-dev, v5.0.22, v5.0.16, v5.0.1, v5.0.0, v4.2.11, v4.2.0, v4.1.27, v4.1.18, v4.1.0, v4.0.9, v4.0.8, v4.0.7, v4.0.6, v4.0.5, v4.0.4, v4.0.0, v4.0.0-BETA4, v4.0.0-BETA3, dev-developtype : projectlicense : MIT License (MIT) (OSI approved) https://spdx.org/licenses/MIT.html#licenseTextsource : [git] https://github.com/laravel/laravel.git f4606d2bb94dc9579488df61fa3744b17e91be62dist : [zip] https://packagist.phpcomposer.com/files/laravel/laravel/f4606d2bb94dc9579488df61fa3744b17e91be62.zip f4606d2bb94dc9579488df61fa3744b17e91be62names : laravel/laravelautoloadclassmapdatabasepsr-4App\ =&gt; app/requiresphp &gt;=5.6.4laravel/framework 5.3.*requires (dev)fzaninotto/faker ~1.4mockery/mockery 0.9.*phpunit/phpunit ~5.0symfony/css-selector 3.1.*symfony/dom-crawler 3.1.* create-project第一种通过 Composer的 create-project 命令安装 Laravel 框架， $ composer create-project laravel/laravel --prefer-dist [别名] Laravel 安装器第二种是先通过 Composer 安装 Laravel 安装器，然后通过安装器安装 Laravel 框架。 使用 composer 全局安装 Laravel 安装器 $ composer global require &quot;laravel/installer&quot; 12345678910111213141516171819202122232425262728293031323334uiste:~ uiste$ composer global require &quot;laravel/installer&quot;Changed current directory to /Users/uiste/.composerUsing version ^1.3 for laravel/installer./composer.json has been updatedLoading composer repositories with package informationUpdating dependencies (including require-dev) - Installing symfony/process (v3.1.4) Downloading: 100% - Installing symfony/polyfill-mbstring (v1.2.0) Downloading: 100% - Installing symfony/console (v3.1.4) Downloading: 100% - Installing guzzlehttp/promises (1.2.0) Downloading: 100% - Installing psr/http-message (1.0.1) Downloading: 100% - Installing guzzlehttp/psr7 (1.3.1) Downloading: 100% - Installing guzzlehttp/guzzle (6.2.1) Downloading: 100% - Installing laravel/installer (v1.3.4) Downloading: 100% symfony/console suggests installing symfony/event-dispatcher ()symfony/console suggests installing psr/log (For using the console logger)Writing lock fileGenerating autoload files 配置PATH环境变量 将 ~/.composer/vendor/bin 添加到 PATH 环境变量中，这样可执行文件 laravel 就能被你的系统检测到了。 编辑 ~/.bash_profile 文件， vim ~/.bash_profile 加入如下代码： export PATH=&quot;~/.composer/vendor/bin:$PATH&quot; 检测是否配置成功 新打开一个终端，输入如下命令： 12uiste:~ uiste$ laravel --versionLaravel Installer version 1.3.3 如果出现该信息，说明安装器已安装成功。 安装Laravel 打开终端，输入如下命令即可安装： $ laravel new blog 12345678uiste:~ uiste$ laravel new blog [RuntimeException] Application already exists! new [--dev] [--5.2] [--] [&lt;name&gt;] 安装最新的开发版本 如果童鞋们对最新的开发版本比较感兴趣，可以下载进行测试，加上 –dev 参数即可： $ laravel new demo –dev 报错如下： 12345678910111213141516171819202122232425262728293031323334uiste:~ uiste$ laravel new blogCrafting application...Loading composer repositories with package informationInstalling dependencies (including require-dev) from lock fileYour requirements could not be resolved to an installable set of packages. Problem 1 - This package requires php &gt;=5.6.4 but your PHP version (5.5.36) does not satisfy that requirement. Problem 2 - Installation request for laravel/framework v5.3.15 -&gt; satisfiable by laravel/framework[v5.3.15]. - laravel/framework v5.3.15 requires php &gt;=5.6.4 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 3 - Installation request for phpunit/php-code-coverage 4.0.1 -&gt; satisfiable by phpunit/php-code-coverage[4.0.1]. - phpunit/php-code-coverage 4.0.1 requires php ^5.6 || ^7.0 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 4 - Installation request for phpunit/phpunit 5.5.5 -&gt; satisfiable by phpunit/phpunit[5.5.5]. - phpunit/phpunit 5.5.5 requires php ^5.6 || ^7.0 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 5 - Installation request for phpunit/phpunit-mock-objects 3.2.7 -&gt; satisfiable by phpunit/phpunit-mock-objects[3.2.7]. - phpunit/phpunit-mock-objects 3.2.7 requires php ^5.6 || ^7.0 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 6 - Installation request for sebastian/code-unit-reverse-lookup 1.0.0 -&gt; satisfiable by sebastian/code-unit-reverse-lookup[1.0.0]. - sebastian/code-unit-reverse-lookup 1.0.0 requires php &gt;=5.6 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 7 - Installation request for sebastian/object-enumerator 1.0.0 -&gt; satisfiable by sebastian/object-enumerator[1.0.0]. - sebastian/object-enumerator 1.0.0 requires php &gt;=5.6 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 8 - Installation request for sebastian/resource-operations 1.0.0 -&gt; satisfiable by sebastian/resource-operations[1.0.0]. - sebastian/resource-operations 1.0.0 requires php &gt;=5.6.0 -&gt; your PHP version (5.5.36) does not satisfy that requirement. Problem 9 - Installation request for sebastian/version 2.0.0 -&gt; satisfiable by sebastian/version[2.0.0]. - sebastian/version 2.0.0 requires php &gt;=5.6 -&gt; your PHP version (5.5.36) does not satisfy that requirement.Application ready! Build something amazing. Mac OS X 升级PHP版本方法一： 查询本机PHP版本 1234uiste:~ uiste$ php -vPHP 5.5.36 (cli) (built: May 29 2015 01:07:06) Copyright (c) 1997-2015 The PHP GroupZend Engine v2.5.0, Copyright (c) 1998-2015 Zend Technologies 然后我们根据实际需求去升级 curl -s http://php-osx.liip.ch/install.sh | bash -s 5.6.4 123456789101112131415161718192021uiste:~ uiste$ curl -s http://php-osx.liip.ch/install.sh | bash -s 5.6.4Detected OS X El Capitan 10.11. All ok.Get packager.tgzUnpack packager.tgzPlease type in your password, as we want to install this into /usr/localWARNING: Improper use of the sudo command could lead to data lossor the deletion of important system files. Please double-check yourtyping when using sudo. Type &quot;man sudo&quot; for more information.To proceed, enter your password, or type Ctrl-C to abort.Password:Start packager (may take some time)downloading https://s3-eu-west-1.amazonaws.com/php-osx.liip.ch/install/5.6.4-frontenddev-latest.datdownloading https://s3-eu-west-1.amazonaws.com/php-osx.liip.ch/&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;downloading https://s3-eu-west-1.amazonaws.com/php-osx.liip.ch/5.6.4-frontenddev.tar.bz2downloading https://s3-eu-west-1.amazonaws.com/php-osx.liip.ch/5.6.4-frontenddev.tar.gzdownloading https://s3-eu-west-1.amazonaws.com/php-osx.liip.ch/5.6.4-frontenddev.tgzDid or could not download package: 5.6.4-frontenddev 中途会提示你输入密码，下载的 PHP 会放置到 /usr/local 下，但不会覆盖原系统 PHP如上所升级的 5.5，PHP 会位于 /usr/local/php5 中，并自动链接到 /etc/apache2/ 下的配置文件然后再新建一个 PHP 文件，写上 phpinfo(); 浏览器访问看看，版本已经升级。]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel - Composer 安装]]></title>
    <url>%2F2015%2F20150930-1.html</url>
    <content type="text"><![CDATA[Composer 安装（一）一、简介Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 二、为什么要使用Composer你有一个项目依赖于若干个库。其中一些库依赖于其他库。你声明你所依赖的东西。Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。 三、安装方式通用安装方式（Win、Linux、Mac都能用），使用composer.phar文件（其实就是下载composer.phar文件，不需要翻墙） 直接下载composer.phar文件composer下载 打开命令行并执行下列命令安装最新版本的 Composer 123456uiste:~ uiste$ php -r &quot;readfile(&apos;https://getcomposer.org/installer&apos;);&quot; | phpAll settings correct for using ComposerDownloading 1.2.1...Composer successfully installed to: /Users/uiste/composer.pharUse it: php composer.phar 这将检查一些PHP的设置，然后下载composer.phar到当前工作目录中。这是Composer的二进制文件。这是一个PHAR 包（PHP 的归档），这是PHP的归档格式可以帮助用户在命令行中执行一些操作。 检测是否安装成功输入如下命令，如果成功则出现以下信息： 123456789101112uiste:~ uiste$ php composer.phar ______ / ____/___ ____ ___ ____ ____ ________ _____ / / / __ \/ __ `__ \/ __ \/ __ \/ ___/ _ \/ ___// /___/ /_/ / / / / / / /_/ / /_/ (__ ) __/ /\____/\____/_/ /_/ /_/ .___/\____/____/\___/_/ /_/Composer version 1.2.1 2015-09-12 11:27:19...___ 局部安装和全局安装四、局部安装 上述下载Composer的过程正确执行完毕后，可以将composer.phar文件复制到任意目录（比如项目根目录下），然后通过 php composer.phar 指令即可使用Composer了！ 五、全局安装 全局安装是将Composer安装到系统环境变量PATH所包含的路径下面，然后就能够在命令行窗口中直接执行composer命令了。 Mac或Linux系统 打开命令行窗口并执行如下命令将前面下载的composer.phar文件移动到 /usr/local/bin/ 目录下面： sudo mv composer.phar /usr/local/bin/composer 123456789uiste:~ uiste$ sudo mv composer.phar /usr/local/bin/composerWARNING: Improper use of the sudo command could lead to data lossor the deletion of important system files. Please double-check yourtyping when using sudo. Type &quot;man sudo&quot; for more information.To proceed, enter your password, or type Ctrl-C to abort.Password: Win系统 找到并进入PHP的安装目录（和你在命令行中执行的php指令应该是同一套PHP）。将 composer.phar 复制到PHP的安装目录下面，也就是和 php.exe 在同一级目录。在 PHP 安装目录下新建一个 composer.bat 文件，并将下列代码保存到此文件中。@php “%~dp0composer.phar” %* 检测全局安装是否成功 12uiste:~ uiste$ composer --versionComposer version 1.2.1 2015-09-12 11:27:19 Composer 中国全量镜像（二）为什么要使用Composer中国全量镜像？ 一般情况下，安装包的数据（主要是 zip 文件）是从 github.com 上下载的，安装包的元数据是从 packagist.org 上下载的。 然而，由于众所周知的原因，国外的网站连接速度很慢，并且随时可能被“墙”。 “Composer 中国全量镜像”所做的就是缓存所有安装包和元数据到国内的机房并通过国内的 CDN 进行加速，这样就不必再去向国外的网站发起请求，这样我们使用Composer时就会更加快速、稳定。 查看当前镜像地址在命令行输入如下命令，即可查看镜像地址：composer config -l -g 查看所有全局配置 1234uiste:~ uiste$ composer config -l -g[repositories.packagist.type] composer[repositories.packagist.url] https?://packagist.org[repositories.packagist.allow_ssl_downgrade] true 启用中国全量镜像服务启用中国全量镜像服务有两种方式，具体配置方法如下： 系统全局配置：即将配置信息添加到 Composer 的全局配置文件 config.json 中。修改composer的全局配置文件（推荐方式），打开命令行并执行如下命令：uiste:~ uiste$ composer config -g repo.packagist composer https://packagist.phpcomposer.com 单个项目配置：即将将配置信息添加到某个项目的 composer.json 文件中。修改当前项目的composer.json配置文件有两种方式，最后都是向文件中添加如下配置信息： 123456&quot;repositories&quot;: &#123; &quot;packagist&quot;: &#123; &quot;type&quot;: &quot;composer&quot;, &quot;url&quot;: &quot;https://packagist.phpcomposer.com&quot; &#125;&#125; 2.1 打开命令行并进入项目的根目录（也就是 composer.json 文件所在目录），执行如下命令：composer config repo.packagist composer https://packagist.phpcomposer.com该命令将会在当前项目中的 composer.json 文件的末尾自动添加镜像的配置信息2.2 手动向composer.json文件中添加以上信息 Composer 常用命令总结（三）init（初始化）该命令用于创建 composer.json 文件，并进行基础信息配置：uiste:~ uiste$ composer init 12345678910uiste:~ uiste$ composer init Welcome to the Composer config generator This command will guide you through creating your composer.json config.Package name (&lt;vendor&gt;/&lt;name&gt;) [uiste/uiste]: 可以配置Package name、Description、Author、Minimum、Package Type、License、dependencies 及 dev dependencies 信息。 完成后配置文件内容如下： 12345678910111213&#123; &quot;name&quot;: &quot;test/test&quot;, &quot;description&quot;: &quot;test init&quot;, &quot;type&quot;: &quot;library&quot;, &quot;license&quot;: &quot;License Description&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;mayanlong&quot;, &quot;email&quot;: &quot;json_vip@163.com&quot; &#125; ], &quot;require&quot;: &#123;&#125;&#125; search（搜索）根据名称搜索相关的包，成功后会列出符合的相关包的信息，本处以搜索 monolog 为例： 123$ composer search monolog monolog/monolog Sends your logs to files, sockets, inboxes, databases and various web serviceskdyby/monolog Integration of Monolog into Nette Framework show（详情）根据包的名称，列出包的相关信息，本处以查看 monolog/monolog 为例： 12345$ composer show -all monolog/monologname : monolog/monologdescrip. : Sends your logs to files, sockets, inboxes, databases and various web serviceskeywords : log, logging, psr-3versions : dev-master, 2.0.x-dev, 1.x-dev, 1.21.0, 1.20.0, 1.19.0, 1.18.2, 1.18.1, 1.18.0, 1.17.2, 1.17.1, 1.17.0, 1.16.0, 1.15.0, 1.14.0, 1.13.1, 1.13.0, 1.12.0, 1.11.0, 1.10.0, 1.9.1, 1.9.0, 1.8.0, 1.7.0, 1.6.0, 1.5.0, 1.4.1, 1.4.0, 1.3.1, 1.3.0, 1.2.1, 1.2.0, 1.1.0, 1.0.2, 1.0.1, 1.0.0, 1.0.0-RC1 想查看更多信息，就亲自将该命令复制到命令行执行吧。 install (安装)先在 composer.json 配置中添加一个 monolog/monolog 依赖库，如下： 123456789101112131415&#123; &quot;name&quot;: &quot;test/test&quot;, &quot;description&quot;: &quot;test init&quot;, &quot;type&quot;: &quot;library&quot;, &quot;license&quot;: &quot;License Description&quot;, &quot;authors&quot;: [ &#123; &quot;name&quot;: &quot;mayanlong&quot;, &quot;email&quot;: &quot;json_vip@163.com&quot; &#125; ], &quot;require&quot;: &#123; &quot;monolog/monolog&quot;: &quot;1.21.*&quot;, &#125;&#125; 然后通过如下命令进行安装依赖 $ composer install update （更新）如果我们新增或者删除了某个依赖，可以通过如下命令进行更新 $ composer update require （申明依赖）我们也可以用命令直接添加依赖，执行该命令后将自动下载，命令如下： $ composer require symfony/http-foundation composer中文网]]></content>
      <tags>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-验证码图片排错]]></title>
    <url>%2F2015%2F20150927-1.html</url>
    <content type="text"><![CDATA[第一步：如果看到不显示验证码，直接输入验证码的地址来排错 第二步：将header()函数注释掉就可能会显示错误 第三步：查看图片源码在图片二进制代码前不能出现任何字符，包括空白字符 第四步：在header()前面添加ob_clean()]]></content>
      <tags>
        <tag>PHP错误处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COOKIE 和 SESSION]]></title>
    <url>%2F2015%2F20150926-1.html</url>
    <content type="text"><![CDATA[思考：A页面中如何访问B页面中的变量包含文件get传递或post传递cookie：cookie是小的信息包。 Cookiecookie的原理浏览器—-http请求（无值）——–&gt;服务器浏览器&lt;—响应头中传递cookie——-服务器浏览器—-再次发送http请求（有值）–&gt;服务器 请求头：客户端请求服务器的时候，告知服务器客户端的信息 响应头：服务器响应客户端的时候，告知客户端服务器的信息 长连接在多个http请求之间，TCP连接不断开称为长连接，默认是5秒。长连接过程中，可以建立多次http请求与http响应 cookie保存在客户端设置cookie语法：setcookie(名字,值,过期时间,有效目录,子域名) bool setcookie ( string $name [, string $value = &quot;&quot; [, int $expire = 0 [, string $path = &quot;&quot; [, string $domain = &quot;&quot; [, bool $secure = false [, bool $httponly = false ]]]]]] ) 临时性cookie关闭浏览器cookie就消失 永久性cookie [ ] 下次自动登录 （案例） 在临时性cookie的基础上加上一个过期时间就成了永久性cookie，过期时间是一个时间戳永久性cookie保存在浏览器上，换个浏览器就不行了 cookie保存的数据类型cookie不能存放bool型数据，true=&gt;1 false=&gt;deletecookie不能存放数组和对象cookie中只能存放字符串 删除cookie1234567Set-Cookie:name=uiste; expires=Mon, 26-Sep-2015 12:07:11 GMT; Max-Age=100sex=man; expires=Mon, 26-Sep-2015 12:07:11 GMT; Max-Age=100age=24; expires=Mon, 26-Sep-2015 12:07:11 GMT; Max-Age=100name=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0sex=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0age= cookie支持下标cookie在浏览器上没有数组的概念，只是浏览器请求到服务器，PHP将同名的变量转成数组 123456&lt;?php//cookie不支持数组，但是支持下标setcookie(&apos;stu[0]&apos;,&apos;tom&apos;);setcookie(&apos;stu[1]&apos;,&apos;berry&apos;);setcookie(&apos;stu[2]&apos;,&apos;ketty&apos;);?&gt; cookie有效目录默认情况下，cookie只能在当前目录和子级目录中有效如果要在整个网站中有效，就要设置有效目录，‘/’表示整站有效setcookie(&#39;name&#39;,&#39;tom&#39;,0,&#39;/&#39;) cookie支持子域名默认情况下，cookie是区分子域名的。一个子域名就代替一个独立的服务器 cookie的缺点 信息保存在本地，安全性低 只能保存字符串，不能保存数组和对象，可控性差 数据保存在头信息中，增加请求时的数据负载 一般浏览器对cookie的要求是不能高于4K session(会话)将数据存储到服务器端，每个客户一个空间，通过编号访问自己的数据 第一次访问服务器，服务器给客户端分配一个编号 通过编号来访问服务器保存的数据 每个客户只能访问自己的数据session是基于cookie的技术 session的操作 要使用会话必须显示的开启会话，session_start()。默认情况下，会话不会自动开启。 要自动开启会话，在php.ini文件中session.auto_start=1，把0改为1就自动开启了 session_id():会话编号 session_name():会话名称 session可以保存除了资源以外的所有类型的数据 重复开启会话会报错，可以通过@来屏蔽会话 session执行过程 使用session_start()从session仓库中加载已经存在的session变量 第一次请求服务器，一个唯一的会话id存储到cookie响应头中 在后面的请求中，会话id保存请求头中，服务器获取请求头的会话id，通过id获取会话的值 页面执行完毕返回到客户端之前，将会话自动保存到服务器的session库中。下次浏览网页可以加载再次使用 session的配置 session.save_path：指定session库的路径 session.save_path = “N;/path”, N表示通过N级目录来保存会话，N等于1，就是通过会话的第一个字母创建文件夹；N等于2表示通过两级目录创建文件夹，第一级是第一个字母，第二级是第二个字母。 12345; 用于保存/取回数据的控制方式session.save_handler=files; session.save_path = &quot;N;/path&quot;; 在 save_handler 设为文件时传给控制器的参数， 这是数据文件将保存的路径session.save_path=&quot;/Applications/XAMPP/xamppfiles/temp/&quot; session.name：设置会话名称 123; Name of the session (used as cookie name).; http://php.net/session.namesession.name=PHPSESSID session.cookie_lifetime：保存会话编号的cookie有效时间 123; Lifetime in seconds of cookie or, if 0, until browser is restarted.; http://php.net/session.cookie-lifetimesession.cookie_lifetime=0 session.cookie_path：保存会话的cookie整站有效 123; The path for which the cookie is valid.; http://php.net/session.cookie-pathsession.cookie_path=/ session.cookie_domain：当前域名有效 123; The domain for which the cookie is valid.; http://php.net/session.cookie-domainsession.cookie_domain= session.save_handler = files：会话按文件格式保存 123; Handler used to store/retrieve data.; http://php.net/session.save-handlersession.save_handler=files session.hash_function = 0：设置session会话的算法 123456; Select a hash function for use in generating session ids.; Possible Values ; 0 (MD5 128 bits); 1 (SHA-1 160 bits); http://php.net/session.hash-functionsession.hash_function=0 session.hash_bits_per_character = 5：每个字符占用的位数 1234567891011; Define how many bits are stored in each character when converting; the binary hash data to something readable.; Possible values:; 4 (4 bits: 0-9, a-f); 5 (5 bits: 0-9, a-v); 6 (6 bits: 0-9, a-z, A-Z, &quot;-&quot;, &quot;,&quot;); Default Value: 4; Development Value: 5; Production Value: 5; http://php.net/session.hash-bits-per-charactersession.hash_bits_per_character=5 session.gc_maxlifetime = 1440：会话过期时间 1234; After this number of seconds, stored data will be seen as &apos;garbage&apos; and; cleaned up by the garbage collection process.; http://php.net/session.gc-maxlifetimesession.gc_maxlifetime=1440 session_destroy()：销毁会话 删除储存介质中的文件 执行此行，就不会执行会话写入操作了 session入库新建数据库123456drop table if exists sess;create table sess( sess_id varchar(32) primary key comment &apos;会话编号&apos;, sess_value text comment &apos;会话的值&apos;, sess_expires int not null comment &apos;会话产生时间&apos;)engine=innodb charset=utf8; session_set_save_handler()设置用户自定义会话存储函数bool session_set_save_handler ( callable $open , callable $close , callable $read , callable $write , callable $destroy , callable $gc [, callable $create_sid ] ) open:开启会话 close:关闭会话 read:读取会话 write:写入会话 destroy:销毁会话 gc:销毁会话 执行session_destroy()的时候才调用destroy()函数 为什么gc不执行? 12345678910111213141516171819202122232425; Defines the probability that the &apos;garbage collection&apos; process is started; on every session initialization. The probability is calculated by using; gc_probability/gc_divisor. Where session.gc_probability is the numerator; and gc_divisor is the denominator in the equation. Setting this value to 1; when the session.gc_divisor value is 100 will give you approximately a 1% chance; the gc will run on any give request.; Default Value: 1; Development Value: 1; Production Value: 1; http://php.net/session.gc-probabilitysession.gc_probability=1; Defines the probability that the &apos;garbage collection&apos; process is started on every; session initialization. The probability is calculated by using the following equation: ; gc_probability/gc_divisor. Where session.gc_probability is the numerator and; session.gc_divisor is the denominator in the equation. Setting this value to 1; when the session.gc_divisor value is 100 will give you approximately a 1% chance; the gc will run on any give request. Increasing this value to 1000 will give you; a 0.1% chance the gc will run on any give request. For high volume production servers,; this is a more efficient approach.; Default Value: 100; Development Value: 1000; Production Value: 1000; http://php.net/session.gc-divisorsession.gc_divisor=1000 session.gc_probability=1 概率session.gc_divisor=1000 除数执行垃圾回收的概率是：1/1000 session入库1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpheader(&apos;content-type:text/html;charset=utf-8&apos;);//开启会话function open() &#123; mysql_connect(&apos;localhost&apos;,&apos;root&apos;,&apos;aa&apos;); mysql_query(&apos;set names utf8&apos;); mysql_query(&apos;use php5&apos;);&#125;//关闭会话function close() &#123;&#125;/***读取会话*@param $sess_id string 会话编号*/function read($sess_id) &#123; $sql=&quot;select sess_value from sess where sess_id=&apos;$sess_id&apos;&quot;; $rs=mysql_query($sql); if($rows=mysql_fetch_row($rs)) return $rows[0]; return &apos;&apos;;&#125;/***写入会话*@param $sess_id string 会话编号*@param $sess_value string 会话值*/function write($sess_id,$sess_value) &#123; $expires=time(); $sql=&quot;insert into sess values (&apos;$sess_id&apos;,&apos;$sess_value&apos;,$expires) on duplicate key update sess_value=&apos;$sess_value&apos;,sess_expires=$expires&quot;; return mysql_query($sql);&#125;/***销毁会话*/function destroy($sess_id) &#123; $sql=&quot;delete from sess where sess_id=&apos;$sess_id&apos;&quot;; return mysql_query($sql);&#125;/***垃圾回收*超过生命周期的会话都是垃圾*/function gc($maxlifetime) &#123; $time=time()-$maxlifetime; $sql=&quot;delete from sess where sess_expires&lt;$time&quot;; return mysql_query($sql);&#125;//更改会话的存储session_set_save_handler(&apos;open&apos;,&apos;close&apos;,&apos;read&apos;,&apos;write&apos;,&apos;destroy&apos;,&apos;gc&apos;);session_start();$_SESSION[&apos;sex&apos;]=100;echo $_SESSION[&apos;sex&apos;];session_destroy();?&gt; session_set_save_handler()必须放在session_start()前面才能起作用 COOKIE 与 SESSION的区别cookie将键值存储在浏览器上session将键存储在浏览器上，值存储在服务器上。 cookie的可以被禁用的，禁用cookie，基于cookie的所有技术都无法使用。 默认情况下，session是基于的cookie的，可以通过配置更改。 session.use_trans_sid=1session.use_only_cookies=0 重启Apache会发现，会话编号不保存到cookie中，而是保存到get提交的URL中或表单的隐藏域中。 已知session_set_save_handler()必须在session_start()前面开启，如果在php.ini中设置了session.auto_start = 1后，则session_set_save_handler()无效。如何处理？在分布式部署文件中有两个指令来更改php.ini中的配置php_flag：用来更改开关性质的配置php_value：用来更改值性质的配置php_flag session.auto_start 0php_value session.gc_maxlifetime 10将以上命令添置在.htaccess文件中]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F2015%2F20150924-2.html</url>
    <content type="text"><![CDATA[Linux目录结构bin 和 sbin ：存放命令的/dev ：存放外设文件/etc ：存放配置文件/home ：普通用户的家目录(主目录)/root ：超级管理员的家目录/mnt ：挂载点/usr ：安装程序/var ：相当于D、E盘，用来存储一些文件站点 Linux常用命令passwd 更改密码ls 、ls -al *.png 查看目录中的内容cd 进入目录exit 退出当前工作环境pwd 获取当前工作目录su或su - 获取管理员权限su - uiste 获取普通用户的权限runlevel 获取运行级别init N 改变运行等级startx 和init5 启动图形化界面clear 清空终端 Linux命令格式语法：名利 [-选项] 参数Linux 命令是区分大小写的 查看文件的详细信息(ls -al)-a 显示所有文件-l 显示详细信息pwd 显示当前目录ls 显示当前目录的文件ls -l 列出文件的详细信息ls -a 列出所有文件，包括隐藏文件ls -al 后面是查询选择，查询选项是没有先后顺序的 常用指令dir 显示当前目录的所有文件who am i 显示登录的用户名whoami 显示当前使用谁的权限exit 、q 退出权限系统halt 关闭计算机power off 关闭计算机reboot 重启计算机man 查看帮助文档 manual–help、-help 调用命令的注释帮助 显示目录所占磁盘容量(du)du file/dir 显示文件或文件夹的容量，单位是KB，如果是文件夹显示文件夹中每个文件额大小和总大小du -s dir 显示文件夹的总大小，不显示文件夹中文件大小du -h file/dir 用友好的方式显示容量 改变工作目录(cd)语法：cd 目录 cd dir 进入dir文件夹下 cd .. ..表示上一级 cd ../dir 进入上一级目录中的dir文件夹下 cd /dir 通过绝对路径进入到dir文件夹下 cd ~ 进入个人主目录 cd cd后面不跟参数就进入到个人主目录，和cd ~一样 目录操作创建目录(mkdir) mkdir dir1 在当前目录下创建dir1文件夹 mkdir dir1/dir2 在dir1目录下创建dir2目录（dir1必须存在) mkdir -p dir1/dir2 如果没有dir1，先创建dir1再创建dir2. -p 可以写在后面 mk dir1 dir2 . 同时创建dir1、dir2、dir3… 删除目录(rmdir) rmdir dir 删除目录，如果目标不为空这报错，不能删除 rmdir dir1 dir2 同时删除多个目录 既能删除文件也能删除目录(rm) -r recursieve 递归-f force 强制 rm file 删除文件 rm -rf file/dir 删除文件和文件夹 复制文件和目录(cp)语法：cp [-r/-R] 源地址 目标地址 cp file dir 将file文件拷贝到dir文件夹下 cp file1 dir/file2 将file1拷贝到dir文件夹下并改名为file2 cp file1 file2 将file1复制一份，重命名为file2 cp -R/-r dir1 dir2 将dir1文件夹递归复制到dir2文件夹下 移动文件或目录(mv) mv file dir 将file文件移动到dir文件夹下 mv dir1 dir2 dir2不存在就是该文件夹名字 dir2存在就是将dir1移动到dir2文件夹下 mv file1 file2 将file1的名字改为file2 mv dir1 dir2/dir3 将dir1拷贝到dir2文件夹下，并改名为dir3 文件查看 cat 文件名 一次性查看全部内容 more 文件名 分屏显示，按回车向下翻，一旦下翻就不能上翻 less 文件名 允许上翻和下翻，按向上和向下的键 head -n 文件名 显示前n条记录 tail -n 文件名 显示后几条 wc 文件名 用来计算文件行数、句数、字符数 新建文件和添加内容新建文件(touch) touch 文件名 新建一个文件 touch file1 file2 … 一次新建多个文件 touch dir/file 在dir文件夹下新建file文件 添加内容(echo、cat) echo 内容&gt;文件 将内容写入到文件（清空写），如果文件不存在则创建新文件 echo 内容&gt;&gt;文件 和上面一样，（追加内容） cat file1&gt;file2 将file1的内容写到file2中（清空写）（文件不存在则创建） cat file1&gt;&gt;file2 和上面一样，（追加内容） cat file1 file2 &gt; file3 将file1和file2的内容合并成file3 >是清空写>&gt;追加写写入&gt;字符时，使用引号，或者\ 反斜杠，进行转义 组(group)的操作 groupadd 组名 添加组 grouped -n 新组名 旧组名 修改组 grouped 组名 删除组 查看组：cat ../etc/group 用户（user）的操作 用户信息都保存在/etc/passwd 文件中 cat ../etc/passwduiste:x:500:500::/home/uiste:/bin/bash用户名：口令：用户id号：组的id号：注释性描述：家目录：登录shell 添加用户（useradd） 命令 描述 useradd 用户名 创建用户，在创建的时候自动创建组 useradd 用户名 -g 组编号 在相应的组下创建用户 useradd 用户名 -u 用户编号 给创建的用户指定用户编号 useradd 用户名 -d 家目录 给用户指定家目录 修改用户（usermod） 命令 描述 usermod -l 新用户名 旧用户名 修改用户名 usermod -u 用户编号 用户名 修改用户编号 usermod -g 组的编号 用户名 修改用户的组 usermod -d 家目录 用户名 修改家目录 删除用户（userdel） 命令 描述 userdel 用户名 删除用户，家目录还存在 userdel -r 用户名 删除用户同时删除家目录 常用指令 命令 描述 grep string [file] 在字符串中查找 ps -A （process）查询所有进程 kill —9 pid 杀死指定进程 df -lh 参看系统分区 date 命令 描述 date 显示系统时间 date -s ‘2015-11-6 11:11:11’ 更改系统时间 管道(|)查找文件（find） 命令 描述 find / -name passwd 查找根下所有passwd的文件[区分大小写] find / -iname passwd 查找根下所有passwd的文件[不区分大小写] find / -mindepth 3 -name passwd 在最低3层目录下查找passwd文件 find / -maxdepth 2 -name passwd 在最高2层目录下查找passwd文件 find . -iname *.c 在当前目录下查找以.c结尾的文件，不区分大小写 find / -size +50k 搜索大于50K的文件 find / -size -40c 搜索小鱼40字节的文件char find . -type f 查找当前目录下的所有文件 find . -type d 查找当前目录下所有的文件夹 软连接和硬连接软连接软连接就是快捷方式语法：ln -s 源文件 连接文件 硬连接语法：ln 源文件 连接文件查看：ls -li 查看文件的索引编号 在Linux中删除文件并不是件文件本身删除，而是删除文件的索引，文件是垃圾回收机制来删除只有文件才能做硬连接 权限（rwx-）Linux的权限有3种：读权限（read）、写权限（write）、可执行权限（execute）文件属性部分有10个字符组成，第一个字符是表示文件的类型，后面还剩下9个字符，每3个一组（每组由读、写、可执行组成），分成3组，第一组是文件所有者（user）的权限，第二组是和文件所有者同组（group）的权限，第三组其他用户（other）的权限 常用便是文件的字符 b 系统设备文件，使用i/o与外界交互的设备，通常是磁盘 d 表示文件夹 - 表示文件 l 连接文件 c 系统设备文件，利用串口设备和声音 更新权限语法：chmod 权限 file/dir 案例 说明 chmod u+x,o+rx dir 用户添加可执行权限，其他用户添加读、可执行权限 chmod u+rwx,o-r file 用户添加读、写、可执行，其他用户去掉读权限 chmod go -rwx file 组和其他用户去掉读、写、可执行权限 chmod 750 file 通过数字来设置权限 更改文件所有者和组更改所有者（chown） chown user file 将file改成user用户 chown -R user dir 将dir文件中的所有文件所有者改为user 更改组（chgrp）语法一：chgrp [-R] 新组名 file/dir将file 或 dir 更改新组名语法二：chown 用户名.组名 文件 123chown user passwd 将passwd更改为user所有chown .php passwd 将passwd更改为php组所有chown user.php passwd 将passwd更改为php组的user所有]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim（VI）]]></title>
    <url>%2F2015%2F20150924-1.html</url>
    <content type="text"><![CDATA[Vim(VI)介绍Vim（vi）是Linux提供的一个更改文件的工具。 Vi有3种模式：命令模式、尾行模式、编辑模式 尾行模式 : 进入尾行模式 :w 保存 :w! 强制保存 :q 退出 :q! 强制退出 :wq 保存并退出 :wq! 强制保存并退出 set number 或 set nu 设置行号 set nonumber 或 set nonu 取消行号 u 撤销上一条命令 . 重复最后一条命令 J 连接上下两行 r+w 将当前的字母替换成w :n 跳转到第n行 :/str 或 /str 从上往下搜索str n 下一个 N 上一个 ?str 从下往上搜索str :s/str/aa 将str替换成aa :s/str/aa/g 将一行的所有str替换成aa :%s/str/aa/g 将整个页面的str替换成aa 编辑模式 i 在当前位置上插入，原来位置上字符后移 a 光标先后移动一位插入 o 新起一个空白行插入 s 删除光标所在字符再插入 命令模式移动光标 ⬆️ ⬇️ ⬅️ ➡️ k j h l 单词级别 e 本单词的末尾，如果当前光标就在本单词末尾就跳转到下个单词的末尾 b 本单词的首字母，如果当前光标就在本单词的首字母上就跳到上一个单词的首字母 w 跳转到下一个单词的首字母 行级 $ 调到行尾 0 调到行首 段级 { 段首 } 段尾 屏幕级 H 屏幕的首部 L 屏幕的尾部 文档级 nG 跳转到第n行 G 移动到文档尾部 删除操作 x 删除当前的字符 dd 删除当前行 3dd 删除3行 d+e 表示从光标开始删除，删除到单词末尾或下一个单词末尾 d+$ 删除从光标开始到这行结束 复制操作 yy 复制当前行 p 粘贴 3yy 复制3行 y+e 从光标开始复制，复制到单词结束或下一个单词结束]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>VI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面向对象3]]></title>
    <url>%2F2015%2F20150917-1.html</url>
    <content type="text"><![CDATA[clone与__clone()123456789101112131415161718192021222324252627&lt;?phpclass Person&#123; protected $name; public function __construnt($name)&#123; $this-&gt;name=$name; &#125; public function show()&#123; echo $this-&gt;name; &#125; public function __clone()&#123; echo &quot;对象被克隆了&lt;br&gt;&quot;; &#125;&#125;$per1 = new Person(&apos;胡浩&apos;);var_dump($per1);echo &apos;&lt;br&gt;&apos;;$per2 = $per1;var_dump($per2);echo &apos;&lt;br&gt;&apos;;$per3 = clone $per1;var_dump($per3);?&gt;object(Person)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; NULL &#125; object(Person)#1 (1) &#123; [&quot;name&quot;:protected]=&gt; NULL &#125; 对象被克隆了object(Person)#2 (1) &#123; [&quot;name&quot;:protected]=&gt; NULL &#125; 创建新对象的方法有两个：1、 实例化2、 clone当执行clone命令的时候，会自动调用__clone()函数 单例模式一个类只能有一个对象 12345678910111213141516171819202122232425262728&lt;?php//三私一公class Student&#123; // 私有的静态属性保存当前实例 private static $instance; // 私有的构造函数阻止在类的外部实例化 private function __construnct()&#123;&#125; // 私有的__clone() 用来阻止在类外部clone对象 private function __clone()&#123;&#125; // 公有的静态方法用来获取实例 public static function getInstance()&#123; if (!self::$instance instanceof self) &#123; self::$instance = new self; &#125; return self::$instance; &#125;&#125;//单例模式$stu1 = Student::getInstance();$stu2 = Student::getInstance();var_dump($stu1);echo &quot;&lt;br&gt;&quot;;var_dump($stu2);?&gt;object(Student)#1 (0) &#123; &#125; object(Student)#1 (0) &#123; &#125; instanceof用来判断变量是否属于某种数据类型 项目层面的单例模式（一个项目中有一组单例模式）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass DB1 &#123; private static $instance; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if(!self::$instance instanceof self) //实例的数据类型不是Student类型的 self::$instance=new self; return self::$instance; &#125; &#125;class DB2 &#123; private static $instance; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if(!self::$instance instanceof self) //实例的数据类型不是Student类型的 self::$instance=new self; return self::$instance; &#125;&#125;class DB3 &#123; private static $instance; private function __construct() &#123; &#125; private function __clone() &#123; &#125; public static function getInstance() &#123; if(!self::$instance instanceof self) //实例的数据类型不是Student类型的 self::$instance=new self; return self::$instance; &#125;&#125;//项目层面的单例模式function getInstance($db_name) &#123; static $array=array(); if(!isset($array[$db_name])) $array[$db_name]=$db_name::getInstance($db_name); return $array[$db_name];&#125;//测试$db1=getInstance(&apos;DB1&apos;);$db2=DB1::getInstance();var_dump($db1,$db2);?&gt; object(DB1)#1 (0) { } object(DB1)#1 (0) { } 工厂模式传递不同的参数获取不同的对象 123456789101112131415161718192021222324252627282930&lt;?php class ProductA &#123; public function getProduct() &#123; echo &apos;这是A商品&lt;br&gt;&apos;; &#125;&#125;class ProductB&#123; public function getProduct() &#123; echo &apos;这是B商品&lt;br&gt;&apos;; &#125;&#125;//工厂模式class ProductFactory &#123; public static function create($num) &#123; switch($num) &#123; case 1: return new ProductA(); case 2: return new ProductB; &#125; return null; &#125;&#125;$objA=ProductFactory::create(1);$objB=ProductFactory::create(2);$objA-&gt;getProduct();$objB-&gt;getProduct(); ?&gt;这是A商品这是B商品 策略模式传递不同的参数，调用不同的方法 1234567891011121314151617181920212223242526272829303132333435&lt;?php //策略模式interface IStrategy &#123; function ontheway();&#125;class Walk implements IStrategy &#123; public function ontheway() &#123; echo &apos;走着去&lt;br&gt;&apos;; &#125;&#125;class Bike implements IStrategy&#123; public function ontheway() &#123; echo &apos;骑车去&lt;br&gt;&apos;; &#125;&#125;class Bus implements IStrategy &#123; public function ontheway() &#123; echo &apos;坐巴士去&lt;br&gt;&apos;; &#125;&#125;//传递不同的参数，调用不同方法class Strategy &#123; public function getWay(IStrategy $obj) &#123; $obj-&gt;ontheway(); &#125;&#125;$obj=new Strategy();$obj-&gt;getWay(new Walk);$obj-&gt;getWay(new Bike);$obj-&gt;getWay(new Bus); ?&gt;走着去骑车去坐巴士去 魔术方法__tostring()当把对象当成字符串调用时自动执行 123456789101112&lt;?php class Student&#123; //当把对象当成字符串调用时自动执行 public function __toString()&#123; return &quot;这是一个学生对象&quot;; &#125;&#125;$stu=new Student;echo $stu; ?&gt;这是一个学生对象 __invoke()当把对象当成函数调用的时候自动执行 1234567891011&lt;?php class Student&#123; //当把对象当成函数调用的时候自动执行 public function __invoke($args)&#123; echo &quot;这是一个学生对象，你传递的参数是：&quot;.$args; &#125;&#125;$stu = new Student();$stu(&apos;tom&apos;) ?&gt;这是一个学生对象，你传递的参数是：tom __set()、__get()set()：当给无法访问的属性赋值的时候自动调用 get()：当获取无法访问的属性值的时候自动调用 123456789101112131415161718&lt;?php class Student&#123; private $name; // 当给无法访问的属性赋值时自动调用 public function __set($key,$value)&#123; $this-&gt;$key=$value; &#125; //当获取无法访问的属性值的时候自动调用 public function __get($key)&#123; return $this-&gt;$key; &#125;&#125;$stu = new Student();$stu-&gt;name=&apos;tom&apos;;echo $stu-&gt;name; ?&gt;tom __unset()、__isset()unset():当销毁无法访问的属性的时候自动调用 isset():当判断无法访问的属性是否存在时自动调用 12345678910111213141516171819202122&lt;?php class Student&#123; private $name; private $sex; private $array=array(&apos;name&apos;,&apos;sex&apos;); // 当销毁无法访问的属性的时候自动调用 public function __unset($key)&#123; unset($this-&gt;$key); &#125; // 当判断无法访问的属性时自动调用 public function __isset($key)&#123; return in_array($key,$this-&gt;array); &#125;&#125;$stu=new Student();echo isset($stu-&gt;name)?&apos;yes&apos;:&apos;no&apos;;echo &quot;&lt;br&gt;&quot;;echo isset($stu-&gt;sss)?&apos;yes&apos;:&apos;no&apos;; ?&gt;yesno __call()、__callstatic()call():当调用无法访问的普通方法时候自动调用 callstatic():当调用无法访问的静态方法时候自动调用 12345678910111213141516171819202122232425&lt;?php class Student&#123; /** * 当调用无法访问的方法时自动调用 * @param $fn_name string 传递方法名 * @param $fn_args array 传递参数数组 */ public function __call($fn_name,$fn_args)&#123; echo &quot;不能调用&quot;.$fn_name.&quot;方法&lt;br&gt;&quot;; var_dump($fn_args); //echo implode(&apos;,&apos;,$fn_args); &#125; // 当输出静态方法调用一个无法访问的方式时自动调用 public static function __callStatic($fn_name,$fn_args)&#123; echo &quot;&lt;br&gt;不能调用静态&quot;.$fn_name.&apos;方法&lt;br&gt;&apos;; &#125;&#125;$stu = new Student();$stu-&gt;show(10,20);Student::test(); ?&gt;不能调用show方法array(2) &#123; [0]=&gt; int(10) [1]=&gt; int(20) &#125; 不能调用静态test方法 Iterator（迭代器）Iterator是迭代器，是PHP内置的接口，用来遍历类中的某个属性。迭代器中有5个抽象方法 Iterator::current -返回当前元素 Iterator::key -返回当前元素的键 Iterator::next -向前移动到下一个元素 Iterator::rewind -返回到迭代器的第一个元素 Iterator::valid -检查当前位置是否有效 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php //学生类class Student &#123;private $name;public function __construct($name) &#123; $this-&gt;name=$name;&#125;public function __get($key) &#123; return $this-&gt;$key; &#125;&#125;//班级类class MyClass implements Iterator &#123; private $stu_list=array(); //学生数组 public function addStu(Student $stu) &#123; $this-&gt;stu_list[]=$stu; &#125; //指针复位到数组的第一个元素 public function rewind() &#123; reset($this-&gt;stu_list); &#125; //检查当前指针的位置是否合法 public function valid() &#123; return key($this-&gt;stu_list)!==null; &#125; //返回当前值 public function current() &#123; return current($this-&gt;stu_list); &#125; //返回当前键 public function key() &#123; return key($this-&gt;stu_list); &#125; //指针下移一位 public function next() &#123; next($this-&gt;stu_list); &#125;&#125;//创建班级$class=new MyClass;$class-&gt;addStu(new Student(&apos;tom&apos;));$class-&gt;addStu(new Student(&apos;berry&apos;));$class-&gt;addStu(new Student(&apos;Ketty&apos;));//遍历班级，就是遍历学生数组foreach($class as $stu) &#123; echo $stu-&gt;name,&apos;&lt;br&gt;&apos;;&#125; ?&gt;tomberryKetty 数组的序列化（serialize）和反序列化（unserialize）对象的序列化和反序列化]]></content>
      <tags>
        <tag>PHP面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面向对象2]]></title>
    <url>%2F2015%2F20150916-1.html</url>
    <content type="text"><![CDATA[多态多态就是多种形态多态分为：方法重载和方法重写，但是PHP不支持方法重载。 方法重写子类方法和父类的方法必须同名 123456789101112131415161718192021&lt;?phpclass animal&#123; public $name='动物'; public function jiao()&#123; echo $this-&gt;name."会叫&lt;br&gt;"; &#125;&#125;class dog extends animal&#123; public $name='狗'; public function jiao()&#123; echo $this-&gt;name."会叫&lt;br&gt;"; &#125;&#125;$dog = new dog();$dog-&gt;jiao(); ?&gt;var_dump($obj);object(dog)#1 (1) &#123; ["name"]=&gt; string(3) "狗" &#125; 1.子类重写的方法不能比父类的方法更加严格(封装)public、protected、private2.子类可以拥有和父类不同个数的参数，[严格标准是不允许的] 私有属性的继承和重写私有属性可以被继承但不能被重写 12345678910111213141516171819&lt;?php class animal&#123; private $name=&apos;动物&apos;; public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;class dog extends animal&#123; private $name=&apos;狗&apos;; public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;$dog = new dog();var_dump($dog);?&gt;object(dog)#1 (2) &#123; [&quot;name&quot;:&quot;dog&quot;:private]=&gt; string(3) &quot;狗&quot; [&quot;name&quot;:&quot;animal&quot;:private]=&gt; string(6) &quot;动物&quot; &#125; 访问修饰符static 静态的final 最终的abstract 抽象的 static【静态的】1、 static修饰属性叫静态属性，static修饰方法叫静态方法2、 当类加载的时候就分配内存空间，在内存中就一份。不用实例化可以直接访问。为所有的对象共享。3、 销毁对象不会销毁静态成员，因为静态成员属于类，而不属于对象。4、 当页面执行完毕的时候才销毁静态成员。5、 父类的static属性子类中可以继承并重写，但不能重新定义同名普通属性。6、 静态方法中不能直接访问普通属性7、 被self调用的普通方法会转成静态方法，【严格标准不允许】 123456789101112&lt;?php class Person&#123; public static $name = &apos;人类&apos;; public static function show()&#123; // echo &apos;这个星球的主宰者是：&apos;.$this-&gt;name;(报错：Fatal error: Using $this when not in object context in) echo &apos;这个星球的主宰者是：&apos;.Person::$name;//(正确) &#125;&#125;echo Person::$name,&quot;&lt;br&gt;&quot;;Person::show(); ?&gt; 静态成员可以被继承 12345678910111213141516171819&lt;?php class Person&#123; public static $name = &apos;人类&apos;; public static function show()&#123; // echo &apos;这个星球的主宰者是：&apos;.$this-&gt;name;(报错：Fatal error: Using $this when not in object context in) echo &apos;这个星球的主宰者是：&apos;.Person::$name;//(正确) &#125;&#125;class Student extends Person&#123;&#125;echo Person::$name,&quot;&lt;br&gt;&quot;;Person::show();echo &quot;&lt;br&gt;&quot;;echo Student::$name,&apos;&lt;br&gt;&apos;;Student::show();echo &apos;&lt;br&gt;&apos;; ?&gt; 调用静态成员：类名::静态成员 self 表示当前类名非静态方法被self调用，自动将非静态方法转成静态方法【严格标准是不允许的】 1234567891011121314&lt;?php class Teacher&#123; public function show()&#123; echo &quot;stay hungry&quot;; &#125; public function test()&#123; $obj = new self(); $obj-&gt;show(); &#125;&#125;Teacher::test(); ?&gt; 确定当前对象1、$this表示当前对象的引用2、self表示当前方法所在的类的类名3、static表示当前对象所属的类的类名【静态延时绑定】 最后一次执行类的属性 12345678910111213141516171819202122&lt;?phpclass Person &#123; public static $type=&apos;人类&apos;; public function showPerson() &#123; //var_dump($this); //object(Student)#1 (0) &#123; &#125; //echo self::$type; //人类 echo static::$type; //学生 静态延时绑定,表示Student &#125;&#125;class Student extends Person &#123; public static $type=&apos;学生&apos;; public function showStu() &#123; //var_dump($this); //object(Student)#1 (0) &#123; &#125; //echo self::$type; //学生 echo static::$type; //学生 &#125;&#125;//测试header(&apos;content-type:text/html;charset=utf-8&apos;);$obj=new Student;$obj-&gt;showPerson();$obj-&gt;showStu(); final[最终的]1、 final修饰的类不能被继承2、 final修饰的方法不能被重写3、 final不能修饰属性 123456789101112131415161718192021&lt;?php final class animal&#123; public $name=&apos;动物&apos;; public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;class dog extends animal&#123; public $name=&apos;狗&apos;; public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;$dog = new dog();echo $dog-&gt;name,&quot;&lt;br&gt;&quot;;$dog-&gt;jiao(); ?&gt;Fatal error: Class dog may not inherit from final class (animal) in 1234567891011121314151617181920&lt;?php class animal&#123; public $name=&apos;动物&apos;; final public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;class dog extends animal&#123; public $name=&apos;狗&apos;; public function jiao()&#123; echo $this-&gt;name.&quot;会叫&lt;br&gt;&quot;; &#125;&#125;$dog = new dog();echo $dog-&gt;name,&quot;&lt;br&gt;&quot;;$dog-&gt;jiao(); ?&gt;Fatal error: Cannot override final method animal::jiao() in abstract[抽象的]1、 abstract修饰的类成为抽象类，abstract修饰的方法叫抽象方法2、 抽象方法：只有方法的声明，没有方法的实现3、 抽象类：类中只要有一个方法是抽象方法，这个类就是抽象类。4、 抽象类不可以被实例化，必须在子类中重新实现。 抽象类的作用：定义方法的命名规范 接口（interface）1、 如果一个类中所有的方法都是抽象方法，这个类就声明成接口。2、 接口是一个特殊的抽象类3、 接口中的方法只能是public的，默认是public的4、 接口中的方法不能用abstract、final来修饰。5、 定义过程用interface实现接口用的implements关键字 类不能多重继承，但是接口可以多重实现 继承类的同时实现接口必须先继承类，再实现接口 class Myclass extends Class implements IPict1,IPict2 类常量【const】类中可以放属性、方法、常量调用类常量 类名::常量名类常量属于类自身，不属于对象实例，不能通过对象实例访问子类可以重写父类中的常量，可以通过(parent::)来调用父类中的常量 1234567891011&lt;?php class Student &#123; const type=&apos;学生&apos;; //类常量 public function show() &#123; echo self::type,&apos;&lt;br&gt;&apos;; &#125;&#125;//测试$stu=new Student;$stu-&gt;show(); //学生 ?&gt; 类常量也可以放在接口中 123456&lt;?php interface Person&#123; const type=&apos;人类&apos;;&#125;echo Person::type; ?&gt; 参数约束1、 在PHP5.3以后才支持参数约束2、 只能约束对象，不能约束基本数据类型 123456789101112131415161718192021&lt;?php class Student&#123;&#125;function show(Student $obj)&#123; var_dump($obj);&#125;show(10);?&gt;Catchable fatal error: Argument 1 passed to show() must be an instance of Student, integer given, called in /Users/uiste/www/test.php on line 95 and defined in /Users/uiste/www/test.php on line 92只能传递Student类型的数据&lt;?php class Student&#123;&#125;function show(Student $obj)&#123; var_dump($obj);&#125;show(new Student); ?&gt;object(Student)#1 (0) &#123; &#125; 父类可以指向子类的引用父类对象可以保存子类的地址 面向对象的三大特性：封装、继承、多态 类的自动加载1、 一个文件中只能有一个类2、 类文件名以.class.php结尾3、 类名和文件名同名 Goods.class.php123456789101112&lt;?php/***商品类*/abstract class Goods &#123; protected $name; //设置商品名称 public function setName($name) &#123; $this-&gt;name=$name; &#125; //获取商品名称 abstract function getName();&#125;?&gt; Books.class.php1234567&lt;?phpclass Books extends Goods &#123; public function getName() &#123; echo &quot;《&#123;$this-&gt;name&#125;》&quot;; &#125;&#125;?&gt; Phone.class.php1234567&lt;?phpclass Phone extends Goods &#123; public function getName() &#123; echo $this-&gt;name; &#125;&#125;?&gt; loadClass.php12345678910&lt;?phpheader(&apos;content-type:text/html;charset=utf-8&apos;);require &apos;./Goods.class.php&apos;;require &apos;./Books.class.php&apos;;require &apos;./Phone.class.php&apos;;$book=new 45Books();$phone=new Phone();$book-&gt;setName(&apos;PHP高级&apos;);$book-&gt;getName();?&gt; 手动引入类比较麻烦，不健壮。最好能实现需要什么类就自动加载什么类。 #### __autoload($class_name)当页面执行的时候，PHP核心程序（Zend Engine）判断当前需要哪个类，如果没有找到该类，就自动的调用__autoload()函数，并且将缺少的类名作为参数传递到__autoload()函数中。 通过缺少类名来加载需要的类123456789&lt;?php $book = new Books();$book-&gt;setname(&quot;PHP高级&quot;);$book-&gt;getname();function __autoload($class_name)&#123; require &quot;./$class_name.class.php&quot;;&#125; ?&gt; 将类映射到数组中有的时候类存放的位置不规则，将不规则的地址映射到类名，形成一个数组再加载。 123456789101112&lt;?php function __autoload($class_name)&#123; $map = array( &apos;Goods&apos; =&gt; &apos;./aa/Goods.class.php&apos;, &apos;Books&apos; =&gt; &apos;./bb/Books.class.php&apos;, &apos;Phone&apos; =&gt; &apos;./cc/Phone.class.php&apos; ); if (isset($map[$class_name])) &#123; require $map[$class_name]; &#125;&#125; ?&gt; 利用命名规则加载类同一类别的类放在同一个文件夹下，这样便于分组管理 将所有的类文件放到Lib文件夹下。将类名名字改为：类名+文件夹名 1234567891011121314151617181920212223242526271.常规引入方法 require &apos;Goods.class.php&apos;; require &apos;Book.class.php&apos;;2.通过调用autoload自动加载类名，加载缺少类名的类 function __autoload($class_name)&#123; require &quot;./&#123;$class_name&#125;.class.php&quot;; &#125; 3.将类名与地址映射到关联数组中去加载 function __autoload($class_name)&#123; $arr = array( &apos;Book&apos;=&gt;&apos;Book.class.php&apos;, &apos;Phone&apos;=&gt;&apos;Phone.class.php&apos;, &apos;Goods&apos;=&gt;&apos;Goods.class.php&apos; ); if (isset($arr[$class_name])) require &quot;./&#123;$arr[$class_name]&#125;&quot;; &#125; 4.利用命名规则加载类一个项目中会有很多类，我们会将类分类存放，类的命令规则：在Lib文件夹下的类以Lib结尾，在Model文件夹的类以Model结尾。 function __autoload($class_name)&#123; if (substr($class_name,-3)==&apos;Lib&apos;) require &quot;./Lib/&#123;$class_name&#125;.class.php&quot;; elseif (substr($class_name,-3)==&apos;Control&apos;) require &quot;./Control/&#123;$class_name&#125;.class.php&quot;; elseif (substr($class_name,-3)==&apos;Model&apos;) require &quot;./Model/&#123;$class_name&#125;.class.php&quot;;&#125; Final 和 abstract 不能修饰接口中的方法参数约束只能约束对象]]></content>
      <tags>
        <tag>PHP面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面向对象1]]></title>
    <url>%2F2015%2F20150914-1.html</url>
    <content type="text"><![CDATA[概念1、 OOP：Object Oriented Programming 面向对象编程2、 OOA：Object-Oriented Analysis 面向对象分析3、 OOD：Object-Oriented Design 面向对象设计4、 对象只能有属性、方法、和常量 类-数据类型对象-复杂的变量属性-变量function-方法、函数 类类名不区分大小写 通过new关键字类实例化对象，实例化的过程就是分配内存的过程$stu = new Student();//实例化对象就是把对象的地址传递给$stu1变量 封装a) public：公有的 可以在类的内部和外部访问b) protected：受保护的 在整个继承链上访问c) private：私有的 只能在类的内部访问 属性一般是私有的，通过公有的方法对私有的属性进行赋值和取值。这样做为了保证数据完整性$this在类的内部使用，表示调用当前方法的对象 类、对象、属性、方法在内存中的表现内存区域静态区和常量区代码区 &lt;===&gt; 类堆区 &lt;===&gt; 对象栈区 &lt;===&gt; 对象的变量，变量指向的是对象的地址 调用属性直接调用对象中的对应属性即可。调用方法先获取对象所在的类，然后调用类中的方法。 类的本质是一个复杂的数据类型；对象的本质是内存中的空间，是一个复杂的变量 构造函数__construct()构造函数：在对象产生的时候自动调用a) 可以传递不同的参数b) 用来初始化成员变量（属性） 跟类名同名的方法也是构造方法;PHP中推荐使用__construct()做构造函数,且优先级较高 123456789101112131415&lt;?php class Student &#123; //构造函数语法二 public function Student() &#123; echo &apos;i am a boy!&lt;br&gt;&apos;; &#125; //构造函数语法一(优先级高) public function __construct() &#123; echo &apos;i am a student&lt;br&gt;&apos;; &#125;&#125;//测试new Student; //i am a studentnew Student; //i am a student ?&gt; 析构函数__destruct()析构函数：在对象销毁的时候自动调用a) 析构函数不能有参数 继承（extends）语法： 123Class 子类 extends 父类&#123; //类成员&#125; 私有的属性也是可以被继承的12345678910111213141516&lt;?phpclass Person&#123; private $name = &apos;uiste&apos;; public function show()&#123; echo &quot;好学生就是：&quot;.$this-&gt;name; &#125;&#125;class Student extends Person&#123;&#125;$stu1 = new Student();$stu1-&gt;show();?&gt;好学生就是：uiste 如果父类private私有属性重写的时候，无论子类属性是：public、protected、private都会生成性的属性;如果父类是protected受把偶的属性时，子类不可以是private私有的。只能是protected、public，且属性会被重写；如果父类是public公有的属性时，子类也只能是public公有的； 总之：父类属性不是私有状态，子类的属性就不能比父类属性的权限严格。父类属性时私有状态是，子类的属性可以任何状态，重写则会被重新建立。 子类中调用父类的属性和方法调用父类的属性和方法用$this关键字 调用父类的构造方法通过parent和父类的类名来调用父类的构造函数语法：parent::__construct()父类类名::__construct() 如果子类有构造函数就调用子类的构造函数，如果子类没有就调用父类的构造函数 1、 继承：extends关键字2、 $this：当前对象的引用3、 parent：父类的类名4、 私有属性也是可以被继承的 给父类的构造函数传递参数12345678910111213141516171819202122232425262728&lt;?php class Person&#123; private $name; private $sex; public function __construct($name,$sex)&#123; $this-&gt;name = $name; $this-&gt;sex = $sex; &#125;&#125;class Student extends Person&#123; private $score; public function __construct($name,$sex,$score)&#123; parent::__construct($name,$sex); $this-&gt;score = $score; &#125; public function show()&#123; echo $this-&gt;name.&apos;是&apos;.$this-&gt;sex.&apos;生，考了：&apos;.$this-&gt;score.&apos;分数&apos;; &#125;&#125;$stu1 = new Student(&apos;小明&apos;,&apos;男&apos;,98);$stu1-&gt;show(); ?&gt;Notice: Undefined property: Student::$name in /Users/uiste/www/test.php on line 135Notice: Undefined property: Student::$sex in /Users/uiste/www/test.php on line 135是生，考了：98分数父类是private私有的不能被继承下来； 12345678910111213141516171819202122232425&lt;?phpclass Person&#123; protected $name; protected $sex; public function __construct($name,$sex)&#123; $this-&gt;name = $name; $this-&gt;sex = $sex; &#125;&#125;class Student extends Person&#123; private $score; public function __construct($name,$sex,$score)&#123; parent::__construct($name,$sex); $this-&gt;score = $score; &#125; public function show()&#123; echo $this-&gt;name.&apos;是&apos;.$this-&gt;sex.&apos;生，考了：&apos;.$this-&gt;score.&apos;分数&apos;; &#125;&#125;$stu1 = new Student(&apos;小明&apos;,&apos;男&apos;,98);$stu1-&gt;show();?&gt;小明是男生，考了：98分数 protected 修饰的成员在整个继承连上访问$this 表示当前对象的引用(地址) A类 B类private 不可访问protected 不可访问public 可以访问 父类 子类]]></content>
  </entry>
  <entry>
    <title><![CDATA[会话控制、cookie、sessions]]></title>
    <url>%2F2015%2F20150911-1.html</url>
    <content type="text"><![CDATA[HTTP协议HTTP是无状态的协议HTTP协议没有内建机制来维持两个事务间的状态，无法判断在请求一个页面后再请求另外一个页面时是来自同一用户。 会话控制的思想是指能够在网站中根据一个会话跟踪用户。 作用：用户登录的支持根据授权级别和个人喜好显示相应的内容。实现购物车功能 实现原理：通过一个唯一会话ID来驱动的。会话ID是一个加密的随机数字。由PHP生成，在会话的生命周期中都会保存在客户端。保存在用户机器里的cookie中，通过URL在网络上传递。 经典方案上次登录时间上次浏览信息规定时间内，不用反复登录 cookie如果没有设置时间，cookie不会保存到客户端，浏览器的会话结束，我们的cookie就失效了cookie只能保存字符串 《在此电脑记住用户名》对于中文，cookie会进行urlencode编码，我们可以使用urldecode解码cookie保存的时间可以不一样，虽然是在一个文件内cookie信息是通过http协议传递的 如果需要保存密码，最好使用md5加密 增加、更新、删除setcookie(&#39;username&#39;,&#39;uiste&#39;,time()+60); 12345678910if (isset($_COOKIE[&quot;user&quot;])) &#123; echo &quot;当前COOKIE是：&quot;.$_COOKIE[&quot;user&quot;]; echo &quot;正在清楚cookie&lt;br&gt;&quot;; setcookie(&quot;user&quot;,&quot;uiste&quot;,time()-3600);&#125;else&#123; echo &quot;您设置的COOKIE时间已超时&lt;br&gt;&quot;; echo &quot;正在创建COOKIE&lt;br&gt;&quot;; setcookie(&quot;user&quot;,&quot;uiste&quot;,time()+5); echo &quot;cookie 创建成功有效时间为5秒&lt;br&gt;&quot;;&#125; 12345678date_default_timezone_set(&quot;Asia/Shanghai&quot;);if (isset($_COOKIE[&apos;time&apos;])) &#123; echo &quot;您上次登录的时间是&quot;.$_COOKIE[&apos;time&apos;]; setcookie(&apos;time&apos;,Date(&quot;Y-m-d H:i:s&quot;,time()));&#125;else&#123; echo &quot;您是第一次登录，登录时间：&quot;.Date(&apos;Y-m-d H:i:s&apos;,time()); setcookie(&apos;time&apos;,Date(&quot;Y-m-d H:i:s&quot;,time()));&#125; session实现简单的会话 开始一个会话注册会话变量使用会话变量注销变量并销毁会话 作用： 购物车用户信息一个数据供同一用户不同页面使用防止用户非法登录到某个页面 session可以保存的数据类型整形、浮点型、字符串、布尔、数组、对象 注意要使用session都需要初始化key不能重复如果要取出对象，需要事先声明类的定义session文件创建是在session_start()执行后立即创建； 配置文件《手册-附录-配置选项》php.ini配置文件中有一组会话配置选项，可以对其进行设置。如下：session.auto_start = 0 ; 在请求启动时初始化sessionsession.cache_expire = 180 ; 设置缓存中的会话文档在 n 分钟后过时session.cookie_lifetime = 0 ; 设置按秒记的cookie的保存时间， 相当于设置Session的过期时间，为0时表示直到浏览器被重启session.cookie_path = / ; cookie的有效路径session.cookie_domain = ; cookie的有效域session.name = PHPSESSID； 用在cookie里的session的名字session.save_handler = files ; 用于保存/取回数据的控制方式session.save_path = /tmp ; 在 save_handler 设为文件时传给控制器的参数， 这是数据文件将保存的路径.session.use_cookies = 1 ; 是否使用cookies 需要重启Apache 这些步骤不一定都要发生在同一个脚本中，其中 123456789101112131415161718192021222324&lt;form action="" method="post"&gt; 用户名：&lt;input type="text" name="username"&gt;&lt;br&gt; 密 码: &lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt; &lt;?php if ($_POST) &#123; $username = $_POST['username']; $password = mysql_real_escape_string($_POST['password']); require '../inc/conn.php'; $sql = "select * from cookie where username='$username' and password='$password'"; $res = mysql_query($sql); if (mysql_fetch_assoc($res)) &#123; echo "登录成功"; //登录成功就设置session session_start(); $_SESSION['username']=$username; $_SESSION['password']=$password; echo $_SESSION['username']; &#125;else&#123; echo '用户名或密码错误，请重新登录'; &#125; &#125; ?&gt; 123456789101112131415&lt;?php header("content-type:text/html;charset=utf8");session_start();if (empty($_SESSION['username'])) &#123; echo "你没有登录请重新登录&lt;br&gt;"; echo "&lt;a href='hw1_form.php'&gt;登录&lt;/a&gt;";&#125;else&#123; echo "可以购物"; echo "&lt;hr&gt;以下内容是退出功能的实现"; echo "&lt;hr&gt;兄弟不好意思，既然成功了我就要给你清除session了&lt;br&gt;"; echo '清除session一共两步&lt;br&gt;第一步：注销变量&lt;br&gt;第二步：销毁会话&lt;br&gt;'; unset($_SESSION['username']); session_destroy();&#125; ?&gt; session与cookie的区别cookie是把用户的信息写给用户的浏览器session是把用户的数据写到用户都占的$_SESSION中，存在服务器的某个路径文件中，只用session时要先初始化session_start();php.ini-&gt;session.auto_start=1 自动开启session不推荐 如果客户端禁用cookie怎样实现session多页面共享在每个超链接上添加一个PHPSESSID=sessionid；同时在每个页面加入：if(isset($_GET[‘PHPSESSID’])){ //设置session_id; session_id($_GET[‘PHPSESSID’]);} session_start(); 使用系统内置常量：SID; echo ““ 以上解决方案为URL重写 解决非法登录问题if($name!=’’){ session_start(); $_SESSION[‘username’]=$name; header(“Location:登录成功页?name=$name”);} if(empty($_SESSION[‘username’])){ header(‘Location:login.php?error=1’);} 垃圾回收机制cookie默认关闭浏览器即失效 cookie的生命周期是固定的session的生命周期是访问即重新计算]]></content>
      <tags>
        <tag>cookie</tag>
        <tag>sessions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP - MySQL SQL注入]]></title>
    <url>%2F2015%2F20150910-Library-php-note.html</url>
    <content type="text"><![CDATA[SQL 注入用户名注入：select * from admin where name=&#39;&#39; or 1=1 or &#39;&#39; and pwd = &#39;&#39;;select * from admin where name=&#39;&#39; or 1=1 # &#39;&#39; and pwd = &#39;&#39;;select * from admin where name=&#39;&#39; or 1=1 -- &#39;&#39; and pwd = &#39;&#39;; ‘ or 1=1 or ‘’‘ or 1=1 # ‘’‘ or 1=1 – ‘’ 密码注入：select * from admin where name=&#39;&#39; and pwd = &#39;&#39; OR &#39;&#39;=&#39;&#39;; ‘ OR ‘’=’ 解决方法一：mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。下列字符受影响：\x00\n\r\&#39;&quot;\x1a如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。语法mysql_real_escape_string(string,connection)| 参数 | 描述 || — | — || string | 必需。规定要转义的字符串。 || connection | 可选。规定 MySQL 连接。如果未规定，则使用上一个连接。 | 解决方法二：string mysql_escape_string ( string $unescaped_string ) mysql_escape_string() 并不转义 % 和 _。 本函数和 mysql_real_escape_string() 完全一样，除了 mysql_real_escape_string() 接受的是一个连接句柄并根据当前字符集转移字符串之外。mysql_escape_string() 并不接受连接参数，也不管当前字符集设定。 解决方法三：string addslashes ( string $str )返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（’）、双引号（”）、反斜线（\）与 NUL（NULL 字符）。 解决方法四：面向对象风格string mysqli::escape_string ( string $escapestr )string mysqli::real_escape_string ( string $escapestr ) 过程化风格string mysqli_real_escape_string ( mysqli $link , string $escapestr )]]></content>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-http协议请求、防盗链]]></title>
    <url>%2F2015%2F20150909-1.html</url>
    <content type="text"><![CDATA[HyperText Transfer Protocol 超文本传输协议（文本、图片、视频等）http 是建立在 TCP/IP协议的一个应用层协议 内容一样浏览器只发出1次http请求！ 123456789请求行：GET /js.php HTTP/1.1 【请求资源-协议版本】消息头：Host: www.test.com 【主机】User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0 【告诉服务器浏览器的内核、操作系统】Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 【客户端可以接受的文件类型】Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 【网页语言】Accept-Encoding: gzip, deflate 【接收什么样的数据压缩格式】Referer: http://www.test.com/ 【代表页面是从哪儿来的】Connection: keep-alive 【表示不要立即断掉】 123456789响应头信息HTTP/1.1 200 OK 【200 OK 表示客户端请求成功】Date: Fri, 09 Sep 2015 08:52:49 GMT 【告诉浏览器请求页面的时间】Server: Apache/2.4.7 (Unix) PHP/5.5.9 OpenSSL/1.0.1f mod_perl/2.0.8-dev Perl/v5.16.3 【告诉浏览器服务的情况】X-Powered-By: PHP/5.5.9 Content-Length: 1331 【表示或送的数据有多少字节】Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html 【文档类型】 Date：告诉浏览器，请求页面的时间！（用于判断页面相应时间，根据时间反应是否可以调用缓存信息） 一个空行：消息体（实体内容）xxx $_SERVER 服务器和执行环境信息12345678910111213141516171819202122232425262728293031323334Array( [UNIQUE_ID] =&gt; V9J4YX8AAAEAAPozd4EAAAAC [HTTP_HOST] =&gt; www.test.com [HTTP_USER_AGENT] =&gt; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:47.0) Gecko/20100101 Firefox/47.0 [HTTP_ACCEPT] =&gt; text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 [HTTP_ACCEPT_LANGUAGE] =&gt; zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 [HTTP_ACCEPT_ENCODING] =&gt; gzip, deflate [HTTP_CONNECTION] =&gt; keep-alive [PATH] =&gt; /usr/bin:/bin:/usr/sbin:/sbin [DYLD_LIBRARY_PATH] =&gt; /Applications/XAMPP/xamppfiles/lib [SERVER_SIGNATURE] =&gt; [SERVER_SOFTWARE] =&gt; Apache/2.4.7 (Unix) PHP/5.5.9 OpenSSL/1.0.1f mod_perl/2.0.8-dev Perl/v5.16.3 [SERVER_NAME] =&gt; www.test.com [SERVER_ADDR] =&gt; 127.0.0.1 [SERVER_PORT] =&gt; 80 [REMOTE_ADDR] =&gt; 127.0.0.1 [DOCUMENT_ROOT] =&gt; /Users/uiste/www/ [REQUEST_SCHEME] =&gt; http [CONTEXT_PREFIX] =&gt; [CONTEXT_DOCUMENT_ROOT] =&gt; /Users/uiste/www/ [SERVER_ADMIN] =&gt; you@example.com [SCRIPT_FILENAME] =&gt; /Users/uiste/www/test.php [REMOTE_PORT] =&gt; 50802 [GATEWAY_INTERFACE] =&gt; CGI/1.1 [SERVER_PROTOCOL] =&gt; HTTP/1.1 [REQUEST_METHOD] =&gt; GET [QUERY_STRING] =&gt; [REQUEST_URI] =&gt; /test.php [SCRIPT_NAME] =&gt; /test.php [PHP_SELF] =&gt; /test.php [REQUEST_TIME_FLOAT] =&gt; 1473411169.446 [REQUEST_TIME] =&gt; 1473411169) 【PATH】：服务器端的环境变量$_SERVER[‘REMOTE_ADDR’] 获取本地的IP地址；REQUEST_URI 获取请求的资源名 DOCUMENT_ROOT 站点根目录 Referer ：防盗链123456789if (isset($_SERVER[&apos;HTTP_REFERER&apos;])) &#123; if (strpos($_SERVER[&apos;SERVER_ADDR&apos;],$_SERVER[&apos;HTTP_REFERER&apos;])===0) &#123; echo &apos;您是合法用户&apos;; &#125;else&#123; echo &quot;您是非法用户&quot;; &#125;&#125;else&#123; echo &quot;你这用户不合法&quot;;&#125; 注意字符串查找返回0，0与false的比较问题 http请求有两种主要的方式get/post相同：都是向服务器发送数据区别：1、安全性get请求的数据会显示在地址栏上，post请求的数据，放在http协议的消息体上2、http协议本身并没有限制数据的大小，主要是浏览器限制get请求2k+35 对post请求没有限制3、get提交的更利于添加到收藏夹 状态码状态码-含义100~199：表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程200~299：表示成功接收请求并已完成整个处理过程，常用200300~399：为完成请求，客户需进一步细化请求，例如，请求的资源已经移动到一个新地址，常用302，304400~499：客户端的请求有错误，常用404500~599：服务器端出现错误，常用500 302:页面重定向404:该页面不存在304:资源已存在 跳转header(&quot;refresh:3;url=http://www.uiste.com&quot;); 通过header禁用缓存(ajax)header(“Expires:-1”);header(“Cache-Control:noch”);header(“Pragma:no-cache”); 文件下载12345678910111213141516171819202122232425262728293031&lt;?php function downfile($filename)&#123;$filename = 'xxx.jpg';//中文转码$filename = iconv('utf-8','gb2312',$filename);//绝对路径$filepath = $_SERVER['DOCUMENT_ROOT'].'down/'.$filename;//打开文件if (!file_exists($filepath)) &#123; echo '文件不存在'; return;&#125;$fp=fopen($filename,'r');//获取下载文件的大小$filesize = filesize($filepath);//返回的文件header("Content-Type:application/octet-stream");//按照字节大小返回header("Accept-Ranges:bytes");//返回文件大小header("Accept-Length:$filesize");//客户端弹出对话框，对应的文件名header("Content-Disposition:attachment;filename=".$filename);//先客户端回送数据$buffer = 1024;//读取文件$filedata = fread($fp,$buffer);//关闭文件fclose($fp);&#125;?&gt;]]></content>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-错误处理、异常处理]]></title>
    <url>%2F2015%2F20150907-1.html</url>
    <content type="text"><![CDATA[die 的应用方式一：if(条件){ die(‘错误信息’);}方式二：执行语句 or die(‘错误信息’); 错误函数（处理器）自定义错误处理方式 创建自定义错误处理器123456function customError($errno, $errstr) &#123; echo &quot;&lt;b&gt;Error:&lt;/b&gt; [$errno] $errstr&lt;br /&gt;&quot;; echo &quot;Ending Script&quot;; die(); &#125; Set Error Handlerset_error_handler(&quot;customError&quot;); 实例123456789101112131415&lt;?php//error handler functionfunction customError($errno, $errstr) &#123; echo &quot;&lt;b&gt;Error:&lt;/b&gt; [$errno] $errstr&quot;; &#125;//set error handlerset_error_handler(&quot;customError&quot;);//trigger errorecho($test);?&gt;以上代码的输出应该类似这样：Error: [8] Undefined variable: test 错误函数（触发器）12345678&lt;?php$age = 700;if ($age&gt;120) &#123; trigger_error('输入年龄太大',E_USER_ERROR); exit();&#125;?&gt; 指定报错方式 错误日志根据php.ini中的error_log配置，PHP向服务器的错误记录系统或文件发送错误记录。通过使用error_log()函数，用户可以向指定的文件或远程目的地发送错误记录 bool error_log (string $message [,int$message_type=0[,string $destination [,string $extra_headers]]]) 预定义异常exception]]></content>
      <tags>
        <tag>PHP错误处理</tag>
        <tag>PHP异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP、终端-模拟get请求]]></title>
    <url>%2F2015%2F20150905-2.html</url>
    <content type="text"><![CDATA[Mac 设置文件夹权限为777 1.cd 你的文件夹路径的上一级目录。2.sudo chmod -R 777 文件夹名3.输入密码4.成功 fsockopen(‘主机’,’端口号’,’错误号’,’错误描述’，’连接时限’); 使用命令行模拟get请求 telnet www.test.com 80 ctrl + ] enter GET /httpget.php HTTP/1.1 Host: www.test.com 使用PHP模拟get请求1234567891011121314151617181920header(&apos;content-type:text/html;charset=utf8&apos;);$fp = fsockopen(&apos;www.test.com&apos;,80,$errno,$error,3);if (!$fp) &#123; // 主机或者端口等定义内容写错了就会报错 echo &apos;错误号&apos;.$errno.&apos;&lt;br&gt;&apos;; echo &apos;错误描述&apos;.$error.&apos;&lt;br&gt;&apos;;&#125;$str = &apos;GET /httpget.php HTTP/1.1&apos;.PHP_EOL;$str.= &apos;Host: www.test.com&apos;.PHP_EOL;$str.= PHP_EOL;// 向打开的连接资源中写入数据，就是get请求数据fwrite($fp,$str);// 读取数据while (!feof($fp)) &#123; echo fgets($fp).&apos;&lt;br&gt;&apos;;&#125;fclose($fp);?&gt;]]></content>
      <tags>
        <tag>Mac命令熟记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP闲来无事，小打小闹]]></title>
    <url>%2F2015%2F20150905-1.html</url>
    <content type="text"><![CDATA[文件操作123456789101112131415161718&lt;?php if (!file_exists('a/b/c/d/')) &#123; mkdir('a/b/c/d',0777,true); echo "文件目录创建成功";&#125;elseif(!file_exists('a/b/c/d/aaa.txt'))&#123; $fp=fopen('a/b/c/d/aaa.txt','w'); fwrite($fp, '闲的无聊'); echo "文件内容创建成功";&#125;elseif(file_exists('a/b/c/d/aaa.txt'))&#123; unlink('a/b/c/d/aaa.txt'); echo "文件内容删除成功",'&lt;br&gt;'; rmdir('a/b/c/d'); rmdir('a/b/c'); rmdir('a/b'); rmdir('a'); echo "文件目录删除成功";&#125;?&gt; 上传下载核心 设计表单时注意属性：enctype=&quot;multipart/form-data&quot;； 文件接收时：print_r ($_FILES[&#39;file&#39;]);返回数组文件内容 判断文件是否上传成功：is_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]) 定义上传路径与保存路径 // 把文件转存到希望的文件目录$upload_file = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;]; file_exists判断转移文件夹存在与否，通过mkdir新建转移文件夹 // 通过time()与rand()获取时间戳对文件重命名避免上传文件的重复而被覆盖$move_file = $_SERVER[&#39;DOCUMENT_ROOT&#39;].&quot;upload/&quot;.time().rand(0,100).$_FILES[&#39;file&#39;][&#39;name&#39;]; 文件路径转移函数move_uploaded_file($upload_file,$move_file) 中文转码：string iconv ( string $in_charset , string $out_charset , string $str ); 前台页面 123456789101112131415161718192021222324252627282930&lt;form action="control.php" method="post" enctype="multipart/form-data"&gt;&lt;table&gt; &lt;tr&gt;&lt;td colspan="2" &gt;&lt;font style="font-size: 20px;"&gt;上传文件&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文件分类&lt;/td&gt; &lt;td&gt; &lt;select name="resource"&gt; &lt;option value='pic'&gt;图片&lt;/option&gt; &lt;option value='mus'&gt;音乐&lt;/option&gt; &lt;option value='vio'&gt;视频&lt;/option&gt; &lt;option value='doc'&gt;文档&lt;/option&gt; &lt;option value='txt'&gt;文件&lt;/option&gt; &lt;/select&gt; &lt;span style='font-size:6px;color:#ff9955;'&gt;暂时只支持上传“png”与“jpg”格式的图片资源&lt;/span&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文件介绍&lt;/td&gt; &lt;td&gt;&lt;textarea cols="30" rows="10" name="describe"&gt;&lt;/textarea&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;上传文件&lt;/td&gt; &lt;td&gt;&lt;input type="file" name="file"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;点击提交&lt;/td&gt; &lt;td&gt;&lt;input type="submit" name="btn"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/form&gt; 控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php require $_SERVER['DOCUMENT_ROOT'].'inc/conn.php';// 判断是否提交数据if ($_POST['btn']) &#123; // 接收提交内容 $resource = $_POST['resource']; $describe = $_POST['describe']; // 显示FILES全局变量的信息 // echo "&lt;pre&gt;"; // print_r ($_FILES['file']); // echo "&lt;/pre&gt;"; //判断文件大小，限制在10M以内 if ($_FILES['file']['size']&gt;10*1024*1024) &#123; echo "上传文件太大，请重新上传，页面正在跳转"; header('refresh:10;url=upload.php'); exit(); &#125; //判断上传文件格式是否满足条件(暂未完善暂时只支持png与jpg格式图片) $type = $_FILES['file']['type']; //echo $type;//通过该输出确认文件格式； if ($type!='image/jpeg'&amp;&amp;$type!='image/png') &#123; echo "上传格式不对，请重新上传，页面正在跳转"; header('refresh:3;url=upload.php'); exit(); &#125; // 判断文件是否上传成功$_FILES['file']['tmp_name']代表临时文件 if (is_uploaded_file($_FILES['file']['tmp_name'])) &#123; // 把文件转存到希望的文件目录 $upload_file = $_FILES['file']['tmp_name']; //根据分类创建对应文件夹（应用于根据用户创建对应文件夹） $user_path = $_SERVER['DOCUMENT_ROOT']."upload/".$resource; if (!file_exists($user_path)) &#123; mkdir($user_path,0777,true); &#125; // 通过time()与rand()获取时间戳对文件重命名避免上传文件的重复而被覆盖 $move_file = $user_path."/".time().rand(0,100).$_FILES['file']['name']; // 测试路径地址正确与否 // echo $upload_file,'&lt;br&gt;'; // echo $move_file; // 中文出错时转码函数iconv ('utf-8','gb2312',$move_file); if (move_uploaded_file($upload_file,$move_file)) &#123; $sql = "insert into resource values(null,'$resource','$describe','$move_file')"; if (mysql_query($sql)) &#123; echo '文件上传成功，正在跳转到下载页面...'; header('refresh:3;url=download.php'); &#125;else&#123; mysql_query($sql) or die(mysql_error()); &#125; &#125;else&#123; echo "文件上传失败,请上传文件..."; header('refresh:3;url=upload.php'); &#125; &#125;else&#123; echo "没有文件上传,请上传文件..."; header('refresh:3;url=upload.php'); &#125;&#125;else&#123; echo "未进行文件上传，正在跳转到上传页面..."; header('refresh:3;url=upload.php');&#125;?&gt; 显示页面 123456789101112131415&lt;?php require $_SERVER[&apos;DOCUMENT_ROOT&apos;].&apos;/inc/conn.php&apos;;$sql = &quot;select * from resource&quot;;$resource_content = mysql_query($sql);header(&apos;content-type:image/png&apos;);header(&apos;content-length:&apos;.filesize($filename));header(&apos;Content-Disposition: attachment; filename=&quot;1.png&quot;&apos;);readfile($filename);while ($resource = mysql_fetch_assoc($resource_content)) &#123; echo &apos;&lt;h1&gt;文件分类:&apos;.$resource[&apos;resource&apos;].&apos;&lt;hr&gt;&apos;; echo &apos;文件简介:&apos;.$resource[&apos;describe&apos;].&apos;&lt;br&gt;&apos;; echo &apos;下载地址:&apos;.$resource[&apos;filename&apos;].&apos;&lt;br&gt;&lt;br&gt;&apos;;&#125;?&gt;]]></content>
      <tags>
        <tag>PHP思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP操作数据库]]></title>
    <url>%2F2015%2F20150904-1.html</url>
    <content type="text"><![CDATA[连接数据库1234$link=@mysql_connect(&apos;localhost:3306&apos;,&apos;root&apos;,&apos;aaa&apos;) or die(mysql_error()); //连接数据库mysql_query(&apos;set names utf8&apos;); //设置字符编码//mysql_query(&apos;use jokedb&apos;); //选择数据库mysql_select_db(&apos;jokedb&apos;); //选择数据库 显示数据库函数mysql_fetch_row()获取资源中的一条记录，并匹配成索引数组，指针下移一条。如果匹配不到返回false mysql_fetch_assoc()mysql_fetch_row()获取资源中的一条记录，并匹配成索引数组，指针下移一条。如果匹配不到返回false mysql_fetch_array()获取资源中的一条记录，并匹配成关联数组和索引，指针下移一条。匹配不到返回false 数据的个数是记录的两倍，一般不使用 mysql_fetch_object()获取资源中的一条记录，并匹配成对象，指针下移一条。匹配不到返回false 12$rows = mysql_fetch_object($rs);echo $rows-&gt;ID,&apos;&lt;br&gt;&apos;.$rows-&gt;Title; 分页原理总页码：$pagecount=ceil($recordcount/$pagesize) 12345678910111213141516171819202122&lt;?php$titleid=isset($_GET[&apos;titleid&apos;])?$_GET[&apos;titleid&apos;]:1; //笑话类别$pagesize=10; //声明一页放10条记录//第一步：求总记录数$sql=&quot;select count(*) from contents where title=$titleid&quot;;$rs=mysql_query($sql);$rows=mysql_fetch_row($rs);$recordcount=$rows[0]; //总记录数//第二步：求总页数$pagecount=ceil($recordcount/$pagesize); //总页数//第四步：获取当前页码$pageno=isset($_GET[&apos;pageno&apos;])?$_GET[&apos;pageno&apos;]:1;if($pageno&lt;1) $pageno=1;if($pageno&gt;$pagecount) $pageno=$pagecount;//第五步：计算起始位置$startno=($pageno-1)*$pagesize;//第六步：获取当前页面的内容$sql=&quot;select * from contents where title=$titleid limit $startno,$pagesize&quot;;$rs=mysql_query($sql,$link);?&gt; mysql_close()关闭数据库如果没有的话，系统也会自动关闭的 数据库使用原则，尽量晚创建，早释放 mysql_affected_rows($link)取得前一次操作说影响的记录数 SqlTool工具类封装1234567891011121314151617181920212223242526272829303132333435&lt;?phpclass SqlTool&#123; private $conn; private $host = "localhost"; private $user = "root"; private $password = "root"; private $db = "test"; function SqlTool()&#123; $this-&gt;conn=mysql_connect($this-&gt;host,$this-&gt;user,$this-&gt;password); if (!$this-&gt;conn) &#123; die("连接数据库失败：").mysql_error(); &#125; mysql_select_db($db); mysql_query('set names utf8'); &#125; public function exeute_dql($sql)&#123; $res = mysql_query($sql); return $res; &#125; //完成 update,delete,insert; public function exeute_dml($sql)&#123; $b=mysql_query($sql); if (!$b) &#123; return 0;//失败 &#125;else&#123; if (mysql_affected_rows($this-&gt;conn)&gt;0) &#123; return 1;//表示成功 &#125;else&#123; return 2;//表示没有行数影响 &#125; &#125; &#125;&#125;?&gt; 调用类方法 1234567&lt;?php require "SqlTool.class.php";$sql = " ";$sqlTool = new SqlTool();$res=$sqlTool-&gt;exeute_dml($sql); ?&gt; $res = mysql_query($sql,$conn);获取行数：$rows = mysql_affected_rows();获取列数：$cols = mysql_num_fields($res); 输出表头：for($i = 0;$i&lt;$colums;$i++) { $field_name=mysql_field_name($res,$i); echo “$field_name“;} mysql_insert_id 取得上一步insert操作产生的id号]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据库常见查询]]></title>
    <url>%2F2015%2F20150903-2.html</url>
    <content type="text"><![CDATA[查询语句select 【select选项】|*|字段列表|字段名 【as】 字段别名 from 表名 【as】表别名 【where子句】【group by子句】【having子句】【order by子句】【limit子句】说明：【where子句】【group by子句】【having子句】【order by子句】【limit子句】五子句，可以随意的组合，但无论如何组合，五子句的顺序一定要按语法的顺序书写。王狗和欧丽 where子句where后面跟的是条件，在数据源中进行筛选 in | not in..where 字段 in(&#39;北京&#39;,&#39;上海&#39;); between…and|not between…and..where 字段 between 25 and 28; is null | is not null..where 字段1 is null or 字段2 is null; 模糊查询（like）..where 字段 like &#39;%永%&#39;;..where 字段 like &#39;character\_set\_%&#39;; group 分组查询group by 【分组查询】..group by 字段; 回溯统计【with rollup】..group by 字段 with rollup; having条件where是对原始数据进行筛选，having是对记录集(结果集)进行筛选select stusex,count(*) total from stu group by stusex having total&gt;3; order by排序asc：升序【默认】desc：降序..from 表名 order by 字段 desc; limit 限制语法：limit 起始位置，显示长度起始位置可以省略，默认是从0开始..from 表名 order by 字段 desc limit 0,3; 查询选项条件all：显示所有数据select all 字段 from 表名;distinct：去除结果集中重复的数据select distinct 字段 from 表名; insert…select…(复制表)创建一个和stu一样结构的表stu1create table stu1 like stu;将上海的学生插入stu1表中insert into stu1 select * from stu where stuaddress=&#39;上海&#39;; on duplicate key update在插入数据的时候，如果插入的数据不满足主键约束或唯一约束则执行更新操作。 1234567891011– 创建表create table emp(id int primary key,name varchar(20) unique);– 插入测试数据insert into emp values (1,&apos;tom&apos;);- 测试数据mysql&gt;insert into emp values (1,&apos;berry&apos;) on duplicate key update name=&apos;berry&apos;;mysql&gt;insert into emp values (2,&apos;berry&apos;) on duplicate key update id=2;mysql&gt;insert into emp values (2,&apos;tom&apos;) on duplicate key update id=2,name=&apos;tom&apos;; 几个关键词distinct：去除select结果集中重复的数据engine=innodb或myisam 存储引擎 innodb：5.5版本以上，引擎支持事务安全（提供：commit、rollback功能），且支持外键 在data目录创建一个.frm的表结构文件，数据文件与索引文件，被保存在data目录的ibdata1文件中 myisam引擎中：.frm结构文件 .MYD数据文件 .MYI索引文件charset :字符集collate :校对集with rollup :回溯统计dual :表（伪表）-&gt;from dual 注意：select 嵌套 select 子句必须使用括号括起来，同时起个别名 union 纵向联合作用：将多个select语句结果集纵向联合起来语法：select 语句 union [选项] select 语句 union [选项] select 语句select stuname from stu union [all | distinct] select stuname from stu1; 小常识大问题，字段相关用反斜线 ，属性内容相关用引号 ‘’; 主键删除auto_increment一定是一个int系列的主键或唯一键 修改主键是不需要增加primary keyalter table 表名 modify id int auo_increment;不是alter table 表名 modify id int auo_increment primary key; 由于unique是一种索引，删除时使用固定语法alter table 表名 drop index 唯一键名 唯一键名默认是字段名 MySQL约束MySQL约束存在information_schema 数据库的table_constraints 中，可以通过该表查询约束信息；约束主要完成对数据的检验，保证数据库数据的完整；如果有相互依赖数据，保证该数据不被删除。 常用五类约束：not null：非空约束，指定某列不能为空unique：唯一 约束，指定某列和几列组合的数据不能重复primary key：主键约束，指定某列的数据不能重复唯一foreign key：外键，指定该列记录属于主表中的一条记录，参照另一条数据check：检查，指定一个表达式，用于检验指定数据（MySQL不支持check约束，但可以使用，没有任何效果） 虽然唯一约束不允许出现重复的值，但是可以为多个null，同一个表可以有多个唯一约束，多个列组合的约束 MySQL会给唯一约束的列上默认创建一个唯一索引。MySQL中 auto_increment 必须是主键，但主键不一定是自动增长的 Mac 使用XAMPP配置SQL-model松散模式与严格模式 问题：使用枚举类型，可以插入未列举选项为空字符 12345678910111213141516mysql&gt; create table test( -&gt; id int auto_increment primary key, -&gt; sex enum(&apos;M&apos;,&apos;W&apos;,&apos;no&apos;) -&gt; );Query OK, 0 rows affected (0.05 sec)mysql&gt; insert into test values (1,&apos;A&apos;);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from test;+----+------+| id | sex |+----+------+| 1 | |+----+------+1 row in set (0.01 sec) 进程解决方案如下(单次解决)： 12345678910111213141516171819202122mysql&gt; show variables like &apos;%sql%%&apos;;+---------------------------+------------------------+| Variable_name | Value |+---------------------------+------------------------+| slave_sql_verify_checksum | ON || sql_auto_is_null | OFF || sql_big_selects | ON || sql_buffer_result | OFF || sql_log_bin | ON || sql_log_off | OFF || sql_mode | NO_ENGINE_SUBSTITUTION || sql_notes | ON || sql_quote_show_create | ON || sql_safe_updates | OFF || sql_select_limit | 18446744073709551615 || sql_slave_skip_counter | 0 || sql_warnings | OFF |+---------------------------+------------------------+13 rows in set (0.01 sec)mysql&gt; set sql_mode=&apos;STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&apos;;Query OK, 0 rows affected (0.01 sec) 结果： 12345678910111213141516171819202122232425262728293031mysql&gt; show variables like &apos;%sql%%&apos;;+---------------------------+----------------------------------------------------------------+| Variable_name | Value |+---------------------------+----------------------------------------------------------------+| slave_sql_verify_checksum | ON || sql_auto_is_null | OFF || sql_big_selects | ON || sql_buffer_result | OFF || sql_log_bin | ON || sql_log_off | OFF || sql_mode | STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION || sql_notes | ON || sql_quote_show_create | ON || sql_safe_updates | OFF || sql_select_limit | 18446744073709551615 || sql_slave_skip_counter | 0 || sql_warnings | OFF |+---------------------------+----------------------------------------------------------------+13 rows in set (0.00 sec)mysql&gt; desc test;+-------+--------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || sex | enum(&apos;M&apos;,&apos;W&apos;,&apos;no&apos;) | YES | | NULL | |+-------+--------------------+------+-----+---------+----------------+2 rows in set (0.02 sec)mysql&gt; insert into test value (null,&apos;k&apos;);ERROR 1265 (01000): Data truncated for column &apos;sex&apos; at row 1 补充优化知识： 第一部分字段创建索引引擎-事物回滚-innodb:金融 第二部分语句优化 使用较少的条件过滤结果 第三部分分区 第四部分mysql 事物、视图 第五部分PDO数据层]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 多表查询、备份、账户权限]]></title>
    <url>%2F2015%2F20150902-2.html</url>
    <content type="text"><![CDATA[多表查询子查询：只能得到1个表的数据，另一个表只是作为一个限制条件多表查询：多个表中的数据 在设计数据表时，那么将现实中的一个实体设计为一个表，但在查询数据时，很多时候会将具有关系的不同实体表中的数据一同取出来。语法： select * from 表A,表B 【where 子句】说明： 从多个表中获取where子句的匹配条件进行获取数据 如果省略where子句，那么得到的结果是一个笛卡尔积 联合查询语法：select语句Aunion【union选项】select 语句B说明： 【union选项】 all 显示所有(包含重复记录) distinct 去复(默认)作用： 1、对同一个表的不同的部分进行不同的操作。 2、一般用于对比较大的表进行分表存储，联合查询 连接查询交差连接语法： select * from 表A cross join表B 【where子句】说明： 如果省略where子句，将是一个迪卡尔积 如果使用where子句，则是在迪卡尔积的基础上筛选满足条件的记录 内连接语法： select * from 表A inner join 表B【where子句】 外连接左外连接语法： select * from 表L left join 表R on 连接条件 右外连接语法： select * from 表L right join 表R on 连接条件说明： 1、外连接，必须使用on关键字，指定连接条件 2、from关键字后如果是左外连接第1个表，咱称之为主表，第2个表称之为从表 3、from关键字后如果是右外连接第1个表，咱称之为从表，第2个表称之为主表 using关键字当进行外连接时，如果两个表的连接字段同名，可以使用：using(进行连接的同名字段) 自然连接所谓的自然就是自已找连接条件，找到的依据是同名字段 自然左外连接语法： select * from 表A natural left join 表B 自然右外连接语法： select * from 表A natural right join 表B自然左外连接就是左外连接自然右外连接就是右外连接注意： 如果想使用自然连接代替外连接，那么作为连接的字段名子相同名，且不作为连接的字段的名子不能相同 对于自然连接会只保留一个同名的字段，且放在第1列 其实using关键字及自然连接就是简化left join或right join的语法 理解： MySQL提供很多种连接方式，不同的连接方式的区别： 共同点：都是从多个表中进行记录的横向拼接 不同点：拼接的方法不同 子查询：一个select包含另一个select联合查询：selectA union select B 多表查询：from 表A,表B交差连接：from 表A cross join表B内连接：from 表A inner join表B左外连接：from 表L left join 表R on右外连接：from 表L right join 表R on 外连接与其他连接1、其他连接与外连接，当匹配条件成立时结果完成一样2、外连接会包含，匹配不成功的记录。3、匹配不成功时，究竟包含什么样的不成功记录，要看使用的left join还是right join如果是left join保留的是左表的没有匹配成功的记录如果是right join保留的是右表的没有匹配成功的记录 备份物理备份（冷备）备份表或数据库的物理文件 对于myisam存储引擎，需要备份 .frm .myd myi对于innodb 存储引擎，需要备份 .frm data/ibdata1 或 .ibd 数据备份只备份数据表中的数据，并没有表结构 备份语法： select * from 表名 into outfile ‘备份的文件的文件路径’【fields选项】【lines选项】说明： fields选项是以fields开头的： terminated by字符 设置字段的结束符 默认是\t enclosed by字符 设置字段的包含符 默认是’’ escaped by 字符 设置字符null值使用什么字符代替 默认\N lines选项是以lines开头的： terminated by字符 设置行的结束符 默认是\t starting by 字符 设置行的开始符 12345678910111213mysql&gt; select * from stu into outfile &apos;/Users/uiste/www/back.sql&apos;;Query OK, 9 rows affected (0.01 sec)备份文件内容如下：1 it001 zhangsan 1 20 12 it002 lisi 1 26 23 it003 wangwu 1 23 24 it004 zhaoliu 1 30 35 it005 tianqi 0 28 16 it006 wangwang 1 20 17 it007 songjiu 1 18 28 it008 张三 女 19 29 it009 zhener 1 23 1 增加参数的示例 123456789101112131415161718mysql&gt; select * from stu into outfile &apos;/Users/uiste/www/back2.sql&apos; -&gt; fields -&gt; terminated by &apos;&apos; -&gt; enclosed by &apos;#&apos; -&gt; lines -&gt; starting by &apos;BEGIN&apos;;Query OK, 9 rows affected (0.02 sec)备份文件内容如下：BEGIN#1##it001##zhangsan##1##20##1#BEGIN#2##it002##lisi##1##26##2#BEGIN#3##it003##wangwu##1##23##2#BEGIN#4##it004##zhaoliu##1##30##3#BEGIN#5##it005##tianqi##0##28##1#BEGIN#6##it006##wangwang##1##20##1#BEGIN#7##it007##songjiu##1##18##2#BEGIN#8##it008##张三##女##19##2#BEGIN#9##it009##zhener##1##23##1# 数据还原load data local infile ‘备份的文件的路径’ into table ‘表名’ [files选项][lines选项] 12345678910111213141516171819202122232425mysql&gt; delete from stu;Query OK, 9 rows affected (0.01 sec)mysql&gt; select * from stu;Empty set (0.01 sec)mysql&gt; load data local infile &apos;/Users/uiste/www/back.sql&apos; into table stu;Query OK, 9 rows affected (0.02 sec)Records: 9 Deleted: 0 Skipped: 0 Warnings: 0mysql&gt; select * from stu;+----+-------+----------+------+------+------+| id | s_num | s_name | sex | age | c_id |+----+-------+----------+------+------+------+| 1 | it001 | zhangsan | 1 | 20 | 1 || 2 | it002 | lisi | 1 | 26 | 2 || 3 | it003 | wangwu | 1 | 23 | 2 || 4 | it004 | zhaoliu | 1 | 30 | 3 || 5 | it005 | tianqi | 0 | 28 | 1 || 6 | it006 | wangwang | 1 | 20 | 1 || 7 | it007 | songjiu | 1 | 18 | 2 || 8 | it008 | 张三 | 女 | 19 | 2 || 9 | it009 | zhener | 1 | 23 | 1 |+----+-------+----------+------+------+------+9 rows in set (0.01 sec) 第二种方法根据备份内容将限定选项一起加入即可 SQL备份备份的是sql(包含数据)语法： 需要在mysql之外(cmd命令行使用)mysqldump工具 mysqldump –uroot –p 数据库名【数据表名】 &gt; 位置 还原：语法1：在mysql之外 mysql –uroot –p 数据库名 &lt;位置 语法2：在mysql中 source 需要还原的文件 不加引号 权限管理创建用户：语法： create user ‘用户名’@’主机’ identified by ‘密码’;说明： 主机 表示用户所能登陆的位置 取值： IP 192.168.10.1 只允许该用户此ip地址上登陆 域名 localhost 只允许该用户在本机上登陆 % 对该用户的登陆位置没有任何限制 密码必须使用引号 查看MYSQL的用户1、进入到MySQL数据库 1234567891011121314151617mysql&gt; create user &apos;xiaoqiang&apos;@&apos;localhost&apos; identified by &apos;123&apos;;Query OK, 0 rows affected (0.01 sec)mysql&gt; use mysql;Database changedmysql&gt; select host,user,password from user;+-----------+-----------+-------------------------------------------+| host | user | password |+-----------+-----------+-------------------------------------------+| localhost | root | *7C31BA29248E9330208F65C47A673D863961B220 || linux | root | || localhost | | || linux | | || localhost | pma | || localhost | xiaoqiang | *7C31BA29248E9330208F65C47A673D863961B220 |+-----------+-----------+-------------------------------------------+6 rows in set (0.01 sec) 2、MySQL用户被保存在user表中 授权语法：grant 权限|all privileges on 数据库名.数据表名 to ‘user’@‘主机名’ 12mysql&gt; grant all privileges on uiste.* to &apos;xiaoqiang&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.01 sec) 查看权限：语法： show grants 12345678mysql&gt; show grants;+----------------------------------------------------------------------------------------------------------------------------------------+| Grants for root@localhost |+----------------------------------------------------------------------------------------------------------------------------------------+| GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY PASSWORD &apos;*7C31BA29248E9330208F65C47A673D863961B220&apos; WITH GRANT OPTION || GRANT PROXY ON &apos;&apos;@&apos;&apos; TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |+----------------------------------------------------------------------------------------------------------------------------------------+2 rows in set (0.01 sec) 收权限语法：revoke 权限|all privileges on 数据库名.数据表名 from ‘user’@‘主机名’ 12mysql&gt; revoke all privileges on uiste.* from &apos;xiaoqiang&apos;@&apos;localhost&apos;;Query OK, 0 rows affected (0.01 sec) 更改用户密码：语法： set password for ‘user’@’host’=password(‘密码’); 12mysql&gt; set password for &apos;xiaoqiang&apos;@&apos;localhost&apos;=password(&apos;&apos;);Query OK, 0 rows affected (0.01 sec) 重置管理员密码1、先停止mysql服务 2、跳过授权表来，启动mysql语法： mysqld –skip-grant-tables说明： 当执行此语句后，窗口会处于挂起状态，不接收用户的任何输入(但不要关闭此窗口) 3、重新开启一个cmd窗口，直接使用mysql登陆(不需要加任何参数)示例： 4、更改mysql数据库的user数据表中的root用户的密码 5、关闭第2步中的窗口，并在任何管理器中结束mysqld服务 6、正常启动mysql，使用新用户密码登陆 –if判断drop procedure if exists proc;create procedure proc(in num int)beginif num=1 then select ‘金牌会员’ as ‘等级’ from dual;elseif num=2 then select ‘普通会员’ as ‘等级’ from dual;elseif num=3 then select ‘游客’ as ‘等级’ from dual;else select ‘输入有误’ from dual;end if;end // –case语句（一）drop procedure if exists proc;create procedure proc(in season int)begin case season when 1 then select ‘春天’ as ‘季节’ from dual; when 2 then select ‘夏天’ as ‘季节’ from dual; when 3 then select ‘秋天’ as ‘季节’ from dual; when 4 then select ‘冬天’ as ‘季节’ from dual; else select ‘输入不正确’ as ‘季节’ from dual; end case;end // –case语句（二）select stuno,stuname,stusex,writtenexam,case when writtenexam&gt;=90 then ‘等级A’ when writtenexam&gt;=80 then ‘等级B’ when writtenexam&gt;=70 then ‘等级C’ when writtenexam&gt;=60 then ‘等级D’ when writtenexam is null then ‘缺考’ else ‘等级E’end as ‘等级’ from stuinfo natural left join stumarks; –loop循环drop procedure if exists proc;create procedure proc(in num int)begin declare total int default 0; declare i int default 1; aa:loop set total=total+i; set i=i+1; if(i&gt;num) then leave aa; end if; end loop; select total as ‘结果’ from dual;end // –while循环drop procedure if exists proc;create procedure proc(in num int)begin declare total int default 0; declare i int default 1; while i&lt;=num do set total=total+i; set i=i+1; end while; select total as ‘结果’ from dual;end // – repeat循环drop procedure if exists proc;create procedure proc(in num int)begin declare total int default 0; declare i int default 1; repeat set total=total+i; set i=i+1; until i&gt;num end repeat; select total as ‘结果’ from dual;end // – leave、iteratedrop procedure if exists proc;create procedure proc()begin declare i int default 0; aa:while i&lt;=5 do set i=i+1; if(i=3) then leave aa; –类似于break; iterate aa; –类似于continue end if; select i; end while;end // –coalesceselect stuname,coalesce(writtenexam,’缺考’),coalesce(labexam,’缺考’) from stuinfo natural left join stumarks// –获取当前时间select year(now()) ‘年’,month(now()) ‘月’,day(now()) ‘日’,hour(now()) ‘小时’,minute(now()) ‘分钟’,second(now()) ‘秒’// – select ADDDATE(now(),INTERVAL 12 day) as ‘日期’ select datediff(now(),’2017-1-1’) as ‘还有几天过年’; –函数create function fun() returns varchar(20)begin return ‘锄禾日当午’;end // drop function if exists fun;create function fun(num1 int,num2 int)returns intbegin declare num int default 0; set num=num1+num2; return num;end // –insert触发器create table t1(num int);create table t2(num int); create trigger trig1after insert on t1 for each rowbegin insert into t2 set num=new.num*new.num;end // –insert触发器drop table transinfo,bank;create table bank( cardid char(4) primary key, name varchar(20) not null, money int not null);create table transinfo( id int auto_increment primary key, cardid char(4) not null, type char(2) not null, money int not null, transdate datetime);insert into bank values (‘1001’,’tom’,1000),(‘1002’,’berry’,1) // create trigger trig_transinfo_insertbefore insert on transinfo for each rowbegin declare mytype,mycardid char(4); declare mymoney int; set mytype=new.type; set mycardid=new.cardid; set mymoney=new.money; if mytype=’支取’ then update bank set money=money-mymoney where cardid=mycardid; else update bank set money=money+mymoney where cardid=mycardid; end if;end // –delete触发器create table temp like transinfo//create trigger trig_transinfo_deleteafter delete on transinfo for each rowbegin insert into temp values (null,old.cardid,old.type,old.money,old.transdate);end // –upate触发器drop table if exists stuinfo1,stumarks1;create table stuinfo1( id int auto_increment primary key, name varchar(20) not null, sex char(1) not null, grade varchar(10) not null);insert into stuinfo1 values (null,’tom’,’男’,’未知’);create table stumarks1( id int primary key, ch int, math int);insert into stumarks1 values (1,77,88) // create trigger trig_stumarks1_updateafter update on stumarks1 for each rowbegin declare ch,math int; declare avgscore decimal(3,1); declare sid int; set ch=new.ch; set math=new.math; set sid=new.id; set avgscore=(ch+math)/2; update stuinfo1 set grade=case when avgscore&gt;=90 then ‘优秀’ when avgscore&gt;=80 then ‘良好’ when avgscore&gt;=70 then ‘一般’ when avgscore&gt;=60 then ‘及格’ else ‘不及格’ end where id=sid;end //]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 多表查询、视图、事物、索引]]></title>
    <url>%2F2015%2F20150902-1.html</url>
    <content type="text"><![CDATA[多表查询分类需求：在设计数据表时，那么将现实中的一个实体设计为一个表，但在查询数据时，很多时候会将具有关系的不同实体表中的数据一同取出来。语法： select * from 表A,表B 【where 子句】说明： 从多个表中获取where子句的匹配条件进行获取数据 如果省略where子句，那么得到的结果是一个笛卡尔积笛卡尔积： 得到的结果集的记录数是：两个表的记录数的乘积 字段数：两个表的字段数的和 union联合查询注意： 对同一个表的不同的部分进行不同的操作一般用于对比较大的表进行分表存储，联合查询 12345678910111213141516171819mysql&gt; (select * from stu where sex=1 order by age limit 999)union(select * from stu where sex=0 order by age desc limit 999);+----+--------+----------+------+------+------+| id | s_num | s_name | sex | age | c_id |+----+--------+----------+------+------+------+| 7 | it007 | songjiu | 1 | 18 | 2 || 1 | it001 | zhangsan | 1 | 20 | 1 || 6 | it006 | wangwang | 1 | 20 | 1 || 9 | it009 | zhener | 1 | 23 | 1 || 11 | it0011 | wu | 1 | 23 | 3 || 2 | it002 | lisi | 1 | 26 | 2 || 10 | it0010 | qianqian | 1 | 26 | 1 || 4 | it004 | zhaoliu | 1 | 30 | 3 || 13 | it0013 | deng | 0 | 34 | 5 || 5 | it005 | tianqi | 0 | 28 | 1 || 12 | it0012 | chen | 0 | 26 | 3 || 3 | it003 | wangwu | 0 | 22 | 2 || 8 | it008 | zhousan | 0 | 19 | 2 |+----+--------+----------+------+------+------+13 rows in set (0.00 sec) 内连接【inner join】语法一：select 列名 from 表1 inner join 表2 on 表1.公共字段=表2.公共字段 inner是可以省略的 1234567891011mysql&gt; select * from stuinfo inner join stuMarks on stuinfo.stuNo=stuMarks.stuNo;+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | stuNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | s25303 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | s25302 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | s25304 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | s25301 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | s25318 | 56 | 48 |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+5 rows in set (0.00 sec) 语法二：select 列名 from 表1,表2 where 表1.公共字段=表2.公共字段 1234567891011mysql&gt; select * from stuinfo,stuMarks where stuinfo.stuNo=stuMarks.stuNo;+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | stuNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | s25303 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | s25302 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | s25304 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | s25301 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | s25318 | 56 | 48 |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+5 rows in set (0.00 sec) select from 表1 inner join 表2 on 表1.公共字段=表2.公共字段和select from 表2 inner join 表1 on 表1.公共字段=表2.公共字段是否一样？答：一样的，因为内连接显示的是两个表的公共记录。 三个表的内连接如何实现？答：select 列名 from 表1 inner join 表2 on 表1.公共字段=表2.公共字段 inner join 表3 on 表2.公共字段=表3.公共字段 左外连接【left join】以左边的表为标准，如果右边的表没有对应的记录，用NULL填充。语法：select 列名 from 表1 left join 表2 on 表1.公共字段=表2.公共字段 12345678910111213mysql&gt; select * from stuinfo left join stuMarks on stuinfo.stuNo=stuMarks.stuNo;+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | stuNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | s25303 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | s25302 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | s25304 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | s25301 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | s25318 | 56 | 48 || s25305 | 诸葛丽丽 | 女 | 23 | 7 | 河南 | NULL | NULL | NULL | NULL || s25319 | 梅超风 | 女 | 23 | 5 | 河北 | NULL | NULL | NULL | NULL |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+7 rows in set (0.00 sec) select from 表1 left join 表2 on 表1.公共字段=表2.公共字段和select from 表2 left join 表1 on 表1.公共字段=表2.公共字段是否一样？答：不一样，第一个SQL语句以表1为准，第二个SQL语句以表2为准 右外连接【right join】以右边的表为标准，如果右边的表没有对应的记录，用NULL填充。语法：select 列名 from 表1 right join 表2 on 表1.公共字段=表2.公共字段 1234567891011mysql&gt; select * from stuinfo right join stuMarks on stuinfo.stuNo=stuMarks.stuNo;+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | stuNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | s25303 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | s25302 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | s25304 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | s25301 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | s25318 | 56 | 48 |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+5 rows in set (0.00 sec) 思考：select from 表1 left join 表2 on 表1.公共字段=表2.公共字段和select from 表2 right join 表1 on 表1.公共字段=表2.公共字段是否一样？答：一样。 交叉连接【cross join】1、如果没有连接表达式返回的是笛卡尔积mysql&gt; select * from stuinfo cross join stuMarks;等价于mysql&gt; select * from stuinfo,stuMarks;2、如果有连接表达式等价于内连接 12345678910mysql&gt; select * from stuinfo cross join stuMarks on stuinfo.stuNo=stuMarks.stuNo;+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | stuNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | s25303 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | s25302 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | s25304 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | s25301 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | s25318 | 56 | 48 |+--------+--------------+--------+--------+---------+------------+---------+--------+-------------+---------+ 自然连接【natural】自动的判断连接条件，它是通过同名字段来判断的自然连接又分为：1、 自然内连接 natural joinselect * from stuinfo natural join stuMarks;2、 自然左外连接 natural left joinselect * from stuinfo natural left join stuMarks;3、 自然右外连接 natural right joinselect * from stuinfo natural rigth join stuMarks; 自然连接结论：1、 表连接通过同名的字段来连接的2、 如果没有同名的字段返回笛卡尔积3、 会对结果进行整理，整理的规则如下a) 连接字段保留一个b) 连接字段放在最前面 using()1、用来指定连接字段。2、using()也会对连接字段进行整理，整理方式和自然连接是一样的。select * from stuinfo inner join stuMarks using(id); 子查询1、 语法：select 语句 where 条件 (select … from 表)2、 外面的查询称为父查询，括号中的查询称为子查询3、 子查询为父查询提供查询条件 =子查询使用表连接的方法 123456789mysql&gt; select stuName,writtenExam from stuinfo natural join stuMarks having writtenExam&gt;60;+--------------+-------------+| stuName | writtenExam |+--------------+-------------+| 李斯文 | 80 || 欧阳俊雄 | 65 || 张秋丽 | 77 |+--------------+-------------+3 rows in set (0.00 sec) 使用子查询方法 123456789mysql&gt; select * from stuinfo where stuNo in(select stuNo from stuMarks where writtenExam&gt;60);+--------+--------------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+--------------+--------+--------+---------+------------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 |+--------+--------------+--------+--------+---------+------------+3 rows in set (0.00 sec) 找出最高分 123456789101112131415mysql&gt; select * from stuinfo where stuNo=(select stuNo from stuMarks order by writtenExam desc limit 1);+--------+-----------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+-----------+--------+--------+---------+------------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 |+--------+-----------+--------+--------+---------+------------+1 row in set (0.00 sec)mysql&gt; select * from stuinfo where stuNo=(select stuNo from stuMarks where writtenExam=(select max(writtenExam) from stuMarks));+--------+-----------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+-----------+--------+--------+---------+------------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 |+--------+-----------+--------+--------+---------+------------+1 row in set (0.00 sec) in|not in子查询用于子查询的返回结果多个值 some()、any()、all()some:一些any:一些 和some()是一样的 类似于inall:全部 =some（=any） 等于其中任何一个!=some（!=any）不等于其中任何一个就可以了=all 等于其中的所有!=all 不等于其中的所有 思考：!=some()和not in一样吗？答：不一样；!=some()表示父查询的记录只要不等于some中的任意一条即可。!=all()才和not in一样 12345678910111213141516171819202122mysql&gt; select * from stuinfo where stuNo=some(select stuNo from stuMarks where writtenExam&gt;60);+--------+--------------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+--------------+--------+--------+---------+------------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 |+--------+--------------+--------+--------+---------+------------+3 rows in set (0.00 sec)mysql&gt; select * from stuinfo where stuNo=any(select stuNo from stuMarks where writtenExam&gt;60);+--------+--------------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+--------------+--------+--------+---------+------------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 |+--------+--------------+--------+--------+---------+------------+3 rows in set (0.00 sec)mysql&gt; select * from stuinfo where stuNo=all(select stuNo from stuMarks where writtenExam&gt;60);Empty set (0.00 sec) exists和not exists如果有人大于等于80分就显示所有的学生 12345678910111213mysql&gt; select * from stuinfo where exists (select * from stuMarks where writtenExam&gt;=80);+--------+--------------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+--------------+--------+--------+---------+------------+| s25301 | 张秋丽 | 男 | 18 | 1 | 北京 || s25302 | 李文才 | 男 | 31 | 3 | 上海 || s25303 | 李斯文 | 女 | 22 | 2 | 北京 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 || s25305 | 诸葛丽丽 | 女 | 23 | 7 | 河南 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 || s25319 | 梅超风 | 女 | 23 | 5 | 河北 |+--------+--------------+--------+--------+---------+------------+7 rows in set (0.00 sec) 如果没有人超过80分就显示所有的学生 12mysql&gt; select * from stuinfo where not exists (select * from stuMarks where writtenExam&gt;=80);Empty set (0.00 sec) 子查询分类1、 标量子查询：子查询返回的结果就一个2、 列子查询：子查询返回的结果是一个列表3、 行子查询：子查询返回的结果返回一行4、 表子查询：子查询返回的结果当成一个表(一定要取别名) 12345678mysql&gt; select *,count(*) from (select * from stuinfo order by stuAge desc) as new1 group by stuSex;+--------+--------------+--------+--------+---------+------------+----------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | count(*) |+--------+--------------+--------+--------+---------+------------+----------+| s25305 | 诸葛丽丽 | 女 | 23 | 7 | 河南 | 3 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | 4 |+--------+--------------+--------+--------+---------+------------+----------+2 rows in set (0.00 sec) 子查询一定要取别名 视图【view】1、 视图是一张虚拟表，它表示一张表的部分或多张表的综合的结构。2、 视图仅仅是表结构，没有表数据。视图的结构和数据建立在表的基础上。 创建视图语法 create [or replace] view 视图的名称as select语句 因为视图是一个表结构，所以创建视图后，会在数据库文件夹中多一个与视图名同名的.frm文件 1234mysql&gt; create view vw_stu -&gt; as -&gt; select * from stuinfo nutural join stumarks using(stuno);Query OK, 0 rows affected (0.02 sec) 查询视图视图是一张虚拟表，视图的用法和表的用法一样 1234567891011mysql&gt; select * from vw_stu;+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress | examNo | writtenExam | labExam |+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+| s25303 | 李斯文 | 女 | 22 | 2 | 北京 | s271811 | 80 | 58 || s25302 | 李文才 | 男 | 31 | 3 | 上海 | s271813 | 50 | 90 || s25304 | 欧阳俊雄 | 男 | 28 | 4 | 天津 | s271815 | 65 | 50 || s25301 | 张秋丽 | 男 | 18 | 1 | 北京 | s271816 | 77 | 82 || s25318 | 争青小子 | 男 | 26 | 6 | 天津 | s271819 | 56 | 48 |+--------+--------------+--------+--------+---------+------------+---------+-------------+---------+5 rows in set (0.00 sec) 查看视图的结构123456789101112131415mysql&gt; desc vw_stu;+-------------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------------+-------------+------+-----+---------+-------+| stuNo | char(6) | NO | | NULL | || stuName | varchar(10) | NO | | NULL | || stuSex | char(2) | NO | | NULL | || stuAge | tinyint(4) | NO | | NULL | || stuSeat | tinyint(4) | NO | | NULL | || stuAddress | varchar(10) | NO | | NULL | || examNo | char(7) | NO | | NULL | || writtenExam | int(11) | YES | | NULL | || labExam | int(11) | YES | | NULL | |+-------------+-------------+------+-----+---------+-------+9 rows in set (0.02 sec) 查看创建视图的语法1234567mysql&gt; show create view vw_stu \g+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+| View | Create View | character_set_client | collation_connection |+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+| vw_stu | CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `vw_stu` AS select `nutural`.`stuNo` AS `stuNo`,`nutural`.`stuName` AS `stuName`,`nutural`.`stuSex` AS `stuSex`,`nutural`.`stuAge` AS `stuAge`,`nutural`.`stuSeat` AS `stuSeat`,`nutural`.`stuAddress` AS `stuAddress`,`stumarks`.`examNo` AS `examNo`,`stumarks`.`writtenExam` AS `writtenExam`,`stumarks`.`labExam` AS `labExam` from (`stuinfo` `nutural` join `stumarks` on((`nutural`.`stuNo` = `stumarks`.`stuNo`))) | utf8 | utf8_general_ci |+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------+----------------------+1 row in set (0.00 sec) 显示所有视图123456789mysql&gt; show tables;+-----------------+| Tables_in_uiste |+-----------------+| stuMarks || stuinfo || vw_stu |+-----------------+3 rows in set (0.01 sec) 精确查找视图方法一：information_schema中的views表保存的是视图信息 1234567mysql&gt; select table_name from information_schema.views;+------------+| table_name |+------------+| vw_stu |+------------+1 row in set (0.12 sec) 方法二：show table status查看表的属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859mysql&gt; show table status\G*************************** 1. row *************************** Name: stuMarks Engine: InnoDB Version: 10 Row_format: Compact Rows: 5 Avg_row_length: 3276 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2015-08-31 17:18:54 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: *************************** 2. row *************************** Name: stuinfo Engine: InnoDB Version: 10 Row_format: Compact Rows: 7 Avg_row_length: 2340 Data_length: 16384Max_data_length: 0 Index_length: 0 Data_free: 0 Auto_increment: NULL Create_time: 2015-08-31 17:18:54 Update_time: NULL Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment: *************************** 3. row *************************** Name: vw_stu Engine: NULL Version: NULL Row_format: NULL Rows: NULL Avg_row_length: NULL Data_length: NULLMax_data_length: NULL Index_length: NULL Data_free: NULL Auto_increment: NULL Create_time: NULL Update_time: NULL Check_time: NULL Collation: NULL Checksum: NULL Create_options: NULL Comment: VIEW3 rows in set (0.00 sec) 显示所有视图的语法是 123456789101112131415161718192021mysql&gt; show table status where comment=&apos;view&apos;\G*************************** 1. row *************************** Name: vw_stu Engine: NULL Version: NULL Row_format: NULL Rows: NULL Avg_row_length: NULL Data_length: NULLMax_data_length: NULL Index_length: NULL Data_free: NULL Auto_increment: NULL Create_time: NULL Update_time: NULL Check_time: NULL Collation: NULL Checksum: NULL Create_options: NULL Comment: VIEW1 row in set (0.00 sec) 更改视图语法：alter view 视图名as select 语句 1234567891011mysql&gt; alter view vw_stu -&gt; as -&gt; select stuaddress,count(stuaddress) from stuinfo left join stumarks using(stuno) group by stusex; Query OK, 0 rows affected (0.02 sec)mysql&gt; select * from vw_stu;+------------+-------------------+| stuaddress | count(stuaddress) |+------------+-------------------+| 北京 | 3 || 上海 | 4 |+------------+-------------------+2 rows in set (0.02 sec) 删除视图语法：drop view [if exists] 视图1,视图2,… 12345mysql&gt; drop view if exists vw_stu;Query OK, 0 rows affected (0.01 sec)mysql&gt; select table_name from information_schema.views;Empty set (0.03 sec) 视图的作用1、 筛选数据，防止未经许可访问敏感数据2、 增加表的兼容性3、 隐藏表结构4、 降低SQL语句的复杂度 视图的算法找出语文成绩最高的男生和女生既然子查询当成一个表，我们可以用视图来代替将子查询写法改为如下 结果不正确！原因：这是因为视图的算法造成的 视图的算法1、 merge：合并算法，将视图的语句和外层的语句合并后在执行。2、 temptable：临时表算法，将视图生成一个临时表，再执行外层语句3、 undefined：未定义，MySQL到底用merge还是用temptable由MySQL决定，这是一个默认的算法，一般视图都会选择merge算法，因为merge效率高。 解决在创建视图的时候指定视图的算法create view algorithm=temptable 视图名as select 语句 重写视图 重新执行查询 事务安全【transaction】1、 事务是一个不可分割的执行单元2、 事务作为一个整体要么一起执行，要么一起回滚 开启事务1语法：start transaction或begin [work] 执行sql更新语句2update 表名 set 字段名=字段内容 条件 设置还原点3savepoint sp1 执行sql更新语句4成功提交事务5语法：commit 失败回滚事务5语法：rollback 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values (4,4);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t1;+------+------+| id | num1 |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 || 4 | 4 |+------+------+4 rows in set (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t1;+------+------+| id | num1 |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 |+------+------+3 rows in set (0.00 sec)mysql&gt; begin;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t1 values (4,4);Query OK, 1 row affected (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t1;+------+------+| id | num1 |+------+------+| 1 | 1 || 2 | 2 || 3 | 3 || 4 | 4 |+------+------+4 rows in set (0.00 sec) 思考：事务什么时候产生？什么时候结束？答：开启的时候产生，提交事务或回滚事务都结束脚下留心：只有innodb和BDB才支持事务，myisam不支持事务。 事务的特性（ACID）1、 原子性（Atomicity）：事务是一个整体，不可以再分，要么一起执行，要么一起不执行。2、 一致性（Consistency）：事务完成时，数据必须处于一致的状态。3、 隔离性（Isolation）：每个事务都是相互隔离的4、 永久性（Durability）：事务完成后，对数据的修改是永久性的。 自动提交事务默认情况下，每个独立的SQL语句都在自动提交事务的。通过如下语句查看是否自动提交事务 可以更改自动提交事务set autocommit=0 | 1； MySQL的锁的机制当在对数据表进行并发(同一时刻会有多个客户端操作同一条记录)操作时，就会触发MySQL的锁的机制①、表锁当某个客户端对一个表进行更改操作时会锁住整个表(其他客户端只能等待)非键值②、行锁–键值 索引【index】索引的优点：查询速度快索引的缺点：1、 增、删、改（数据操作语句）效率低了2、 索引占用空间 索引的类型1、 普通索引2、 唯一索引（唯一键）3、 主键索引：只要主键就自动创建主键索引，不需要手动创建。4、 全文索引，搜索引擎使用，MySQL不支持中文的全文索引，我们通过sphinx去解决中文的全文索引。 创建普通索引【create index】语法：create index 索引名 on 表名 （字段名） 创建索引查看索引 通过修改表的方式创建索引语法：alter table 表名 add index [索引的名称] （列名）创建索引 创建表的时候指定索引1234567891011121314151617181920mysql&gt; create table temp( -&gt; id int, -&gt; name varchar(20), -&gt; age tinyint, -&gt; index ix_temp_name(name), --创建索引 -&gt; key(age) --创建索引 -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; show create table temp\G*************************** 1. row *************************** Table: tempCreate Table: CREATE TABLE `temp` ( `id` int(11) DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `age` tinyint(4) DEFAULT NULL, KEY `ix_temp_name` (`name`), KEY `age` (`age`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 创建唯一索引语法一：create unique index 索引名 on 表名 （字段名）语法二：alter table 表名 add unqiue index [索引的名称] （列名）语法三：创建表的时候添加唯一索引，和创建唯一键是一样的。 创建多列组合索引删除索引语法：drop index 索引名 on 表名 创建索引的指导原则1、 该列用于频繁搜索2、 改列用于排序3、 公共字段要创建索引4、 如果表中的数据很少，不需要创建索引。MySQL搜索索引的时间比逐条搜索数据的时间要长。5、 如果一个字段上的数据只有几个不同的值，改字段不适合做索引，比如性别。 存储过程【procedure】存储过程的优点1、 存储过程可以减少网络流量2、 允许模块化设计3、 支持事务 创建存储过程语法：create procedure 存储过程名(参数)begin //sql语句end; 脚下留心：由于过程中有很多SQL语句，每个语句的结束都要用（；）表示。默认情况下，分号既表示语句结束，又表示向服务器发送SQL语句。我们希望分号仅表示语句的结束，不要将SQL语句发送到服务器执行，通过delimiter来更改结束符。 mysql&gt;delimiter // 创建简单的存储过程调用存储过程语法：call 存储过程名() 删除存储过程语法：drop procedure [if exists] 存储过程名 创建复杂的存储过程123456789101112131415161718192021mysql&gt; create procedure proc(param char(6)) -&gt; begin -&gt; select * from stuinfo where stuno=param; -&gt; select * from stumarks where stuno=param; -&gt; end //Query OK, 0 rows affected (0.00 sec)mysql&gt; call proc(&apos;s25301&apos;) //+--------+---------+--------+--------+---------+------------+| stuNo | stuName | stuSex | stuAge | stuSeat | stuAddress |+--------+---------+--------+--------+---------+------------+| s25301 | 张秋丽 | 男 | 18 | 1 | 北京+--------+---------+--------+--------+---------+------------+1 row in set (0.00 sec)+---------+--------+-------------+---------+| examNo | stuNo | writtenExam | labExam |+---------+--------+-------------+---------+| s271816 | s25301 | 77 | 82 |+---------+--------+-------------+---------+1 row in set (0.01 sec) 存储过程的参数存储过程不能使用return返回值，要返回值只能通过“输出参数”来向外传递值。存储过程的参数分为：输入参数（in）【默认】，输出参数（out），输入输出参数（inout） 变量局部变量1、 通过declare关键字来声明变量2、 语法：declare 变量名 数据类型 [default 默认值]3、 使用set或select …into…给变量赋值 使用select…into…给变量赋值12345678910111213141516mysql&gt; create procedure proc(in id char(6)) -&gt; begin -&gt; declare name varchar(20); -&gt; declare sex char(1); -&gt; select stuname,stusex into name,sex from stuinfo where stuno=id; -&gt; select name,sex from dual; -&gt; end //Query OK, 0 rows affected (0.00 sec)mysql&gt; call proc(&apos;s25301&apos;)//+--------+------+| name | sex |+--------+------+| 张秋丽 | 男 |+--------+------+1 row in set (0.00 sec) 例题：查找同桌例题：使用set赋值 全局变量在变量前面加一个@，就是全局变量全局变量是一个弱类型的变量，它的类型取决于付给变量的值 系统变量只要变量名前面有两个@@的肯定是系统变量 带输出参数的存储过程【out】123456789101112131415mysql&gt; create procedure proc(num int,out result int) -&gt; begin -&gt; set result=num*num; -&gt; end //Query OK, 0 rows affected (0.00 sec)mysql&gt; call proc(5,@result) //Query OK, 0 rows affected (0.00 sec)mysql&gt; select @result from dual //+---------+| @result |+---------+| 25 |+---------+ 带输入输出参数的存储过程【inout】查看存储过程的信息—————内连接—————-–语法一：select i.stuno,stuname,writtenexam from stuinfo i inner join stumarks s on i.stuno=s.stuno;–语法二：select stuinfo.stuno,stuname,writtenexam from stuinfo,stumarks where stuinfo.stuno=stumarks.stuno;–inner 可以省略select i.stuno,stuname,writtenexam from stuinfo i join stumarks s on i.stuno=s.stuno;————–左外连接,右外连接———-select stuinfo.stuno,stuname,writtenexam,labexam from stuinfo left join stumarks on stuinfo.stuno=stumarks.stuno; select stuinfo.stuno,stuname,writtenexam,labexam from stuinfo right join stumarks on stuinfo.stuno=stumarks.stuno; ————–自然连接—————–自然内连接select * from t1 natural join t2;–自然左外连接select * from t1 natural left join t2;–自然右外连接select * from t1 natural right join t2; —————-using()——————-select * from t1 inner join t2 using(id);select * from t1 left join t2 using(id); ——————-子查询————————––查找80分的学生–方法一select stuname,writtenexam from stuinfo natural join stumarks where writtenexam=80;–方法二select * from stuinfo where stuno=(select stuno from stumarks where writtenexam=80); –找出最高分select * from stuinfo where stuno=(select stuno from stumarks where writtenexam=(select max(writtenexam) from stumarks)); –查找及格的学生select * from stuinfo where stuno in (select stuno from stumarks where writtenexam&gt;=60); –查找不及格的学生select * from stuinfo where stuno not in (select stuno from stumarks where writtenexam&gt;=60); –查找缺考的学生select * from stuinfo where stuno in (select stuno) select * from stuinfo where stuno in (select stuno from stuinfo natural left join stumarks where writtenexam is null); –some select * from stuinfo where stuno=some(select stuno from stumarks where writtenexam&gt;=60); –exitsselect * from stuinfo where exists (select * from stumarks where writtenexam&gt;=80) –行子查询select * from stu where (stusex,ch) in (select stusex,max(ch) from stu group by stusex); –表子查询select * from (select * from stu order by ch desc) as t group by stusex; –示地区和每个地区参见考试的人数，并按人数降序排列select stuaddress,count(writtenexam) c from stuinfo left join stumarks using(stuno) group by stuaddress order by c desc; –显示有学生参见考试的地区select stuaddress,count(writtenexam) c from stuinfo left join stumarks using(stuno) group by stuaddress having c&gt;0; select distinct stuaddress from stuinfo natural right join stumarks where stuaddress is not null; –显示男生和女生的人数select stusex,count(*) from stuinfo where stusex=&#39;男&#39; union select stusex,count(*) from stuinfo where stusex=&#39;女&#39;; select sum(stusex=&#39;男&#39;) 男,sum(stusex=&#39;女&#39;) 女 from stuinfo; –显示每个地区的男生和女生，以及总人数select stuaddress,count(*) 总人数,sum(stusex=&#39;男&#39;) 男,sum(stusex=&#39;女&#39;) 女 from stuinfo group by stuaddress; ———————–视图———————– 123create view vw_stuas select stuname,stusex,writtenexam from stuinfo inner join stumarks using (stuno); select * from (select * from stu order by ch desc) t group by stusex; 123create or replace algorithm=temptable view vw1asselect * from stu order by ch desc; 12345678--create table temp(id int,name varchar(20),age tinyint,index ix_temp_name(name),key(age)) 多表查询分类将多个表的数据横向的联合起来。1、 内连接2、 外连接a) 左外连接b) 右外连接3、 交叉连接4、 自然连接]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据库设计及步骤]]></title>
    <url>%2F2015%2F20150901-1.html</url>
    <content type="text"><![CDATA[实体和实体之间的关系一对多 1：N（多对一 N：1）主表中的一条记录对应从表中的多条记录 1、 主键和非主键之间的关系就能实现一对多。2、 一对多和多对一是一样的。 问题：几个一对多的关系？1、 客户和订单2、 省和市的关系3、 商品类别和商品 一对一（1:1）主表中的一条记录对应从表中的一条记录 主键和主键建关系就能实现一对一。 思考：一对一两个表完全可以用一个表实现，为什么还要分成两个表？答：在字段数量很多情况下，数据量也就很大，每次查询都需要检索大量数据，这样效率低下。我们可以将所有字段分成两个部分，“常用字段”和“不常用字段”，这样对大部分查询者来说效率提高了。【表的垂直分割】 多对多（N：M）班级和讲师的关系科目和学生的关系 只要是多对多，必须有第三张关系表来保存关系 数据库设计的步骤目的：数据冗余、空间浪费—》节省数据的存储空间内存空间浪费、数据不完整–》保证数据的完整性数据更新与插入异常–》方便进行数据库应用系统的开发 需求分析=&gt;建模=&gt;模型转换=&gt;规范化 需求分析阶段：分析客户的业务和数据处理需求;概要设计阶段：设计数据库的E-R模型图，确认需求信息的正确和完整;详细设计阶段：将E-R图转换为多张表，进行逻辑设计，并应用数据库设计的三大范式进行审核;代码编写阶段：选择具体数据库进行物理实现，并编写代码实现前端应用;软件测试阶段：……安装部署：…… 数据库设计具体步骤1、 收集信息：与该系统有关人员进行交流、坐谈，充分理解数据库需要完成的任务2、 标识对象（实体－Entity）标识数据库要管理的关键对象或实体3、 标识每个实体的属性（Attribute）4、 标识对象之间的关系（Relationship） 项目需求BBS论坛的基本功能：1、用户注册和登录，后台数据库需要存放用户的注册信息和在线状态信息；2、用户发贴，后台数据库需要存放贴子相关信息，如贴子内容、标题等；3、用户可以对发帖进行回复【跟帖】；4、论坛版块管理：后台数据库需要存放各个版块信息，如版主、版块名称、贴子数等； 标识实体实体一般是名词：用户：论坛普通用户、各版块的版主。用户发的主贴用户发的跟贴（回贴）版块：论坛的各个版块信息 标识实体的属性论坛用户：昵称、密码、邮件、生日、性别、等级、备注、注册日期、状态、积分主贴：发帖人、发帖表情、回复数量、标题、正文、发帖时间、点击数、状态回帖：帖子编号、回帖人、表情、标题、正文、回帖时间、点击数板块：板块名称、版主、本版格言、点击率、发帖数 标识实体和实体之间的关系一个版块有多个主贴一个主贴有多个跟帖一个用户可以管理多个版块一个用户可以发多个主贴一个用户可以回复多个跟帖 绘制E-R图E-R（Entity－Relationship）实体关系图 E-R图的语法方形：实体，一般是名词椭圆：属性，一般是名词菱形：关系，一般是动词 将E-R图转成表1、 实体转成表，属性转成字段2、 如果没有合适的字段做主键，给表添加一个自动增长列做主键。 数据规范化Codd博士定义了6个范式来规范化数据库，范式由小到大来约束，范式越高冗余越小，但表的个数也越多。实验证明，三范式是性价比最高的 第一范式确保每个字段不可再分说明：Address由country和city构成，将Address分成country和city。 思考：地址包含省、市、县、地区是否需要拆分？答：如果仅仅起地址的作用，不需要统计，可以不拆分；如果有按地区统计的功能需要拆分。在实际项目中拆分! 第二范式：非键字段必须依赖于键字段一个表只能描述一件事非键字段必须依赖于键字段 第三范式：消除传递依赖在所有的非键字段中，不能有传递依赖 例如在非主键中，“学号”和”姓名“有依赖，将”姓名“删除例如顾客编号依赖于顾客姓名总分数依赖于语文和数学的分数在非主键字段中，要消除传递依赖 上面的设计不满足第三范式，但是高考分数表就是这样设计的，为什么？答：高考分数峰值访问量非常大，这时候就是性能更重要。当性能和规范化冲突的时候，我们首选性能。这就是“反三范式”。 例题演练需求假设某建筑公司要设计一个数据库。公司的业务规则概括说明如下：1、公司承担多个工程项目，每一项工程有：工程号、工程名称、施工人员等2、公司有多名职工，每一名职工有：职工号、姓名、性别、职务（工程师、技术员）等3、公司按照工时和小时工资率支付工资，小时工资率由职工的职务决定（例如，技术员的小时工资率与工程师不同） 设计异常1、 插入异常：一个职工入职，由于“工程名称”不能为空，所以必须虚拟一个工程名称。2、 更新异常：“李思岐”从“技术员”升级“工程师”，结果“小时工资率”没有从60调整到65。3、 删除异常：“李思岐”和“葛宇洪”离职，将二人删除，结果把“临江饭店”这个工程也删除了。 优化表结构工程表：工程号、项目名称员工表：职工号、姓名、职务职务表：职务、小时工资工时表：工程号、职工号、工时 查询语句语法：select [选项] 字段名 from 表名 [where 条件] [group by 分组] [having 条件] [order by 排序] [limit 限制] 1234567891011mysql&gt; create table student( -&gt; id int auto_increment primary key, -&gt; name char(16) not null, -&gt; `语文` int(5), -&gt; `数学` int(5) -&gt; )charset=utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into student values(null,&apos;张宝&apos;,56,67),(null,&apos;李青霞&apos;,89,92),(null,&apos;兰丁丁&apos;,29,96);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0 字段表达式12345678910111213141516171819202122232425mysql&gt; select 20;+----+| 20 |+----+| 20 |+----+1 row in set (0.00 sec)mysql&gt; select 20*20;+-------+| 20*20 |+-------+| 400 |+-------+1 row in set (0.01 sec)mysql&gt; select id,name,`语文`,`数学`,(`语文`+`数学`) from student;+----+-----------+--------+--------+---------------------+| id | name | 语文 | 数学 | (`语文`+`数学`) |+----+-----------+--------+--------+---------------------+| 1 | 张宝 | 56 | 67 | 123 || 2 | 李青霞 | 89 | 92 | 181 || 3 | 兰丁丁 | 29 | 96 | 125 |+----+-----------+--------+--------+---------------------+3 rows in set (0.01 sec) 时间戳 1234567mysql&gt; select unix_timestamp();+------------------+| unix_timestamp() |+------------------+| 1472347068 |+------------------+1 row in set (0.01 sec) 随机数 1234567mysql&gt; select rand();+--------------------+| rand() |+--------------------+| 0.8859497913028578 |+--------------------+1 row in set (0.00 sec) 通过as给字段取别名 1234567mysql&gt; select unix_timestamp() as &apos;时间戳&apos;,rand() as &apos;随机数&apos;;+------------+--------------------+| 时间戳 | 随机数 |+------------+--------------------+| 1472347205 | 0.8530956766131294 |+------------+--------------------+1 row in set (0.01 sec) as可以省略 1234567mysql&gt; select unix_timestamp() &apos;时间戳&apos;,rand() &apos;随机数&apos;;+------------+--------------------+| 时间戳 | 随机数 |+------------+--------------------+| 1472347268 | 0.6076290398907187 |+------------+--------------------+1 row in set (0.00 sec) from 子句from：来自，from后面跟的是数据源。数据源可以有多个。返回笛卡尔积(排列组合) 1234567891011121314151617181920212223mysql&gt; create table teacher( -&gt; id int auto_increment primary key, -&gt; name char(16) not null, -&gt; `评分` int(3) zerofill -&gt; )charset=utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into teacher values (null,&apos;贾老师&apos;,98),(null,&apos;杜老师&apos;,59);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from student,teacher;+----+-----------+--------+--------+----+-----------+--------+| id | name | 语文 | 数学 | id | name | 评分 |+----+-----------+--------+--------+----+-----------+--------+| 1 | 张宝 | 56 | 67 | 1 | 贾老师 | 098 || 1 | 张宝 | 56 | 67 | 2 | 杜老师 | 059 || 2 | 李青霞 | 89 | 92 | 1 | 贾老师 | 098 || 2 | 李青霞 | 89 | 92 | 2 | 杜老师 | 059 || 3 | 兰丁丁 | 29 | 96 | 1 | 贾老师 | 098 || 3 | 兰丁丁 | 29 | 96 | 2 | 杜老师 | 059 |+----+-----------+--------+--------+----+-----------+--------+6 rows in set (0.01 sec) 返回笛卡尔积 可以通过as给表取别名(给表取别名，as可以省略) 123456789101112mysql&gt; select i.name,m.name from student as i,teacher as m;+-----------+-----------+| name | name |+-----------+-----------+| 张宝 | 贾老师 || 张宝 | 杜老师 || 李青霞 | 贾老师 || 李青霞 | 杜老师 || 兰丁丁 | 贾老师 || 兰丁丁 | 杜老师 |+-----------+-----------+6 rows in set (0.01 sec) dual表（伪表）dual表是一个伪表。在有些特定情况下，没有具体的表的参与，但是为了保证select语句的完整又必须要一个表名，这时候就使用伪表。dual表是用来保证select语句的完整性 1234567mysql&gt; select 20*30 as `积` from dual;+-----+| 积 |+-----+| 600 |+-----+1 row in set (0.00 sec) 123mysql&gt; select * from student where `语文`&gt;59;mysql&gt; select * from student where 1; --返回所有数据mysql&gt; select * from student where 0; --返回空 思考：数据库中的表是一个二维表，返回的结果是一张二维表，既然能在数据库的二维表中进行查询，能否在结果集的二维表上继续进行查询？答：可以，使用having条件就是在结果集上继续进行筛选。 12345678mysql&gt; select * from student where name in (&apos;兰丁丁&apos;,&apos;张宝&apos;);+----+-----------+--------+--------+| id | name | 语文 | 数学 |+----+-----------+--------+--------+| 1 | 张宝 | 56 | 67 || 3 | 兰丁丁 | 29 | 96 |+----+-----------+--------+--------+2 rows in set (0.02 sec) 查询名字是兰丁丁和张宝的信息 1234567mysql&gt; select * from teacher where name not in (&apos;杜老师&apos;);+----+-----------+--------+| id | name | 评分 |+----+-----------+--------+| 1 | 贾老师 | 098 |+----+-----------+--------+1 row in set (0.00 sec) 查询不包含杜老师的信息 in：在…里面not in：不在…里面 between…and|not between…andbetween…and：在…之间 12345678mysql&gt; select * from student where id between 2 and 3;+----+-----------+--------+--------+| id | name | 语文 | 数学 |+----+-----------+--------+--------+| 2 | 李青霞 | 89 | 92 || 3 | 兰丁丁 | 29 | 96 |+----+-----------+--------+--------+2 rows in set (0.00 sec) id在2和之间包含2和3 not between …and 不在…之间 12345678mysql&gt; select * from student where id not between 2 and 2;+----+-----------+--------+--------+| id | name | 语文 | 数学 |+----+-----------+--------+--------+| 1 | 张宝 | 56 | 67 || 3 | 兰丁丁 | 29 | 96 |+----+-----------+--------+--------+2 rows in set (0.01 sec) id不在2和2之间 is null | is not null123456789mysql&gt; insert into student values (null,&apos;赵哥&apos;,null,89);Query OK, 1 row affected (0.01 sec) +----+--------+--------+--------+| id | name | 语文 | 数学 |+----+--------+--------+--------+| 4 | 赵哥 | NULL | 89 |+----+--------+--------+--------+1 row in set (0.00 sec) 查询语文或数学为空的信息； 查询一个为空的字段不能用等于，必须用is null 标量子查询= ：结果就是一个字select * from stu where id=(select id from class where name=&#39;jack&#39;); 列子查询in ：一个字段对应多个值select * from stu where id in(select id from class where name in(&#39;php&#39;,&#39;java&#39;)); 行子查询= ：n个字段名对n个值select * from stu where(id,name)=(select id,name from class where name=&#39;php&#39;); 聚合函数 聚合函数 描述 sum() 求和 avg() 求平均值 max() 求最大值 min() 求最小值 count() 求记录数 1234567mysql&gt; select sum(`语文`) as `语文总分`,avg(`语文`) as `语文平均分`,max(`语文`) as `语文最高分`,min(`语文`) as `语文最低分`,count(*) as `总人数` from student;+--------------+-----------------+-----------------+-----------------+-----------+| 语文总分 | 语文平均分 | 语文最高分 | 语文最低分 | 总人数 |+--------------+-----------------+-----------------+-----------------+-----------+| 174 | 58.0000 | 89 | 29 | 4 |+--------------+-----------------+-----------------+-----------------+-----------+1 row in set (0.01 sec) 通配符 通配符 描述 _ [下划线] 表示任意一个字符 % 表示任意字符 练习1、满足“T_m”的有（A、C）A：Tom B：Toom C：Tam D：Tm E：Tmo2、满足“T_m_”的有（B、C）A:Tmom B:Tmmm C:T1m2 D:Tmm E:Tm3、满足“张%”的是（A、B、C、D）A:张三 B：张三丰 C：张牙舞爪 D：张 E：小张4、满足“%诺基亚%”的是（A、B、C、D）A：诺基亚2100 B：2100诺基亚 C：把我的诺基亚拿过来 D：诺基亚 如果要匹配6个字符，且已ing结尾则使用“___ing” 3个下划线 使用“\”转移特殊字符 “\%”; 模糊查询（like）1234567mysql&gt; select * from student where name like &apos;兰%&apos;;+----+-----------+--------+--------+| id | name | 语文 | 数学 |+----+-----------+--------+--------+| 3 | 兰丁丁 | 29 | 96 |+----+-----------+--------+--------+1 row in set (0.01 sec) 查询兰姓小伙伴 group by 【分组查询】将查询的结果分组，分组查询目的在于统计数据 12345678mysql&gt; select id,name,sex,avg(`数学`) as `数学平均分数` from student group by sex;+----+-----------+------+--------------------+| id | name | sex | 数学平均分数 |+----+-----------+------+--------------------+| 2 | 李青霞 | 女 | 92.0000 || 1 | 张宝 | 男 | 84.0000 |+----+-----------+------+--------------------+2 rows in set (0.01 sec) 分组查询中，字段有普通字段会怎么样？只显示分组后第一条记录的字段值 注意内容插入的时候使用引号 ‘’ ，查询字段信息时使用 ; 通过group_concat()函数将同一组的值连接起来显示 12345678mysql&gt; select group_concat(id),group_concat(name),sex,avg(`语文`) as `语文平均分`,avg(`数学`) as `数学平均分` from student group by sex;+------------------+-------------------------+------+-----------------+-----------------+| group_concat(id) | group_concat(name) | sex | 语文平均分 | 数学平均分 |+------------------+-------------------------+------+-----------------+-----------------+| 2 | 李青霞 | 女 | 89.0000 | 92.0000 || 1,3,4 | 张宝,兰丁丁,赵哥 | 男 | 42.5000 | 84.0000 |+------------------+-------------------------+------+-----------------+-----------------+2 rows in set (0.01 sec) 实现分组后按降序排列 12345678910mysql&gt; select * from student group by `语文` desc;+----+-----------+------+--------+--------+| id | name | sex | 语文 | 数学 |+----+-----------+------+--------+--------+| 2 | 李青霞 | 女 | 89 | 92 || 1 | 张宝 | 男 | 56 | 67 || 3 | 兰丁丁 | 男 | 29 | 96 || 4 | 赵哥 | 男 | NULL | 89 |+----+-----------+------+--------+--------+4 rows in set (0.00 sec) 分组后降序排列 多列分组(注意：聚合函数*号的位置-&gt;count(*)) 12345678mysql&gt; select group_concat(name),sex,count(*) from student group by sex;+-------------------------+------+----------+| group_concat(name) | sex | count(*) |+-------------------------+------+----------+| 李青霞 | 女 | 1 || 张宝,兰丁丁,赵哥 | 男 | 3 |+-------------------------+------+----------+2 rows in set (0.01 sec) 回溯统计【with rollup】在分组统计的基础上再进行相同的统计 12345678910111213141516171819202122232425mysql&gt; update student set sex=null where id=3;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from student;+----+-----------+------+--------+--------+| id | name | sex | 语文 | 数学 |+----+-----------+------+--------+--------+| 1 | 张宝 | 男 | 56 | 67 || 2 | 李青霞 | 女 | 89 | 92 || 3 | 兰丁丁 | NULL | 29 | 96 || 4 | 赵哥 | 男 | NULL | 89 |+----+-----------+------+--------+--------+4 rows in set (0.00 sec)mysql&gt; select group_concat(name),sex,count(*) from student group by sex with rollup;+-----------------------------------+------+----------+| group_concat(name) | sex | count(*) |+-----------------------------------+------+----------+| 兰丁丁 | NULL | 1 || 李青霞 | 女 | 1 || 张宝,赵哥 | 男 | 2 || 兰丁丁,李青霞,张宝,赵哥 | NULL | 4 |+-----------------------------------+------+----------+4 rows in set (0.00 sec) 在分组统计的基础上再进行相同的统计 having条件having和where的区别：where是对原始数据进行筛选，having是对记录集(结果集)进行筛选。 12345678mysql&gt; select * from student having `语文`&lt;59;+----+-----------+------+--------+--------+| id | name | sex | 语文 | 数学 |+----+-----------+------+--------+--------+| 1 | 张宝 | 男 | 56 | 67 || 3 | 兰丁丁 | NULL | 29 | 96 |+----+-----------+------+--------+--------+2 rows in set (0.00 sec) 123456789101112mysql&gt; select name from student where `数学`&gt;80;+-----------+| name |+-----------+| 李青霞 || 兰丁丁 || 赵哥 |+-----------+3 rows in set (0.00 sec)mysql&gt; select name from student having `数学`&gt;80;ERROR 1054 (42S22): Unknown column &apos;数学&apos; in &apos;having clause&apos; 因为在表中查询，表中有 `数学` ，所以where可以查到结果，反之having是查询不到结果的； 1234567mysql&gt; select group_concat(name),sex,count(*) as total from student group by sex having total&gt;1; +--------------------+------+-------+| group_concat(name) | sex | total |+--------------------+------+-------+| 张宝,赵哥 | 男 | 2 |+--------------------+------+-------+1 row in set (0.00 sec) 对select出的数据，使用having进行条件设置 ####【where子句】 主要是用于根据一个条件表达式从硬盘上将数据读到内存中时筛选记录。既然where根据条件表达式进行记录的筛选，where的运算符= 判断两个值是否相等= 判断n个字段与n个值是否相等 order by排序asc：升序【默认】desc：降序 123mysql&gt; select * from student order by \`语文`; --按语文升序mysql&gt; select * from student order by \`语文` asc; --按语文升序mysql&gt; select * from student order by \`语文` desc; --按语文降序 limit语法：limit 起始位置，显示长度起始位置可以省略，默认是从0开始 找出班级总分前两名 12345678mysql&gt; select name,(`语文`+`数学`) as total from student order by (`语文`+`数学`) desc limit 2;+-----------+-------+| name | total |+-----------+-------+| 李青霞 | 181 || 兰丁丁 | 125 |+-----------+-------+2 rows in set (0.00 sec) 查询语句中的选项查询语句中的选项有两个：1、 all：显示所有数据 【默认】2、 distinct：去除结果集中重复的数据 1234567891011121314151617181920mysql&gt; select all sex from student;+------+| sex |+------+| 男 || 女 || NULL || 男 |+------+4 rows in set (0.00 sec)mysql&gt; select distinct sex from student;+------+| sex |+------+| 男 || 女 || NULL |+------+3 rows in set (0.01 sec) insert…select…选择一个表的数据插入到另外的表中 123456789101112131415mysql&gt; create table stu_boy like student;Query OK, 0 rows affected (0.03 sec)mysql&gt; insert into stu_boy select * from student where sex=&apos;男&apos;;Query OK, 2 rows affected (0.02 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from stu_boy;+----+--------+------+--------+--------+| id | name | sex | 语文 | 数学 |+----+--------+------+--------+--------+| 1 | 张宝 | 男 | 56 | 67 || 4 | 赵哥 | 男 | NULL | 89 |+----+--------+------+--------+--------+2 rows in set (0.00 sec) on duplicate key update在插入数据的时候，如果插入的数据不满足主键约束或唯一约束则执行更新操作。测试数据 12345671 –创建表2 create table emp(3 id int primary key,4 name varchar(20) unique5 );6 – 插入测试数据7 insert into emp values (1,&apos;tom&apos;); mysql&gt;insert into emp values (1,&#39;berry&#39;) on duplicate key update name=&#39;berry&#39; 编号1和主键冲突，将name改成berry mysql&gt;insert into emp values (2,&#39;berry&#39;) on duplicate key update id=2; berry 和唯一键冲突，将id改为2 union作用：将多个select语句结果集纵向联合起来语法：select 语句 union [选项] select 语句 union [选项] select 语句 例题：查找上海的男生和北京的女生 12345--方法一：mysql&gt; select * from stu where (stuaddress=&apos;上海&apos; and stusex=&apos;男&apos;) or (stuaddress=&apos;北京&apos; and stusex=&apos;女&apos;);--方法二：mysql&gt; select * from stu where (stuaddress=&apos;上海&apos; and stusex=&apos;男&apos;) union select * from stu where (stuaddress=&apos;北京&apos; and stusex=&apos;女&apos;); 例题：联合多个表的数据mysql&gt; select stuname from stu union select name from stu_info; 例题：将多个表的数据插入到新表中mysql&gt; create table stu2 like stu; --创建和stu一样的表结构 –将上海的男生和北京的女生插入到stu2表中 insert into stu2 select * from stu where (stuaddress=&#39;上海&#39; and stusex=&#39;男&#39;) union select * from stu where (stuaddress=&#39;北京&#39; and stusex=&#39;女&#39;); union的选项union的选项有两个1、 all：显示所有数据2、 distinct：去除重复的数据【默认】 默认情况下，取出重复的记录union all 显示联合的数据，不去重 union的注意事项 union两边的select语句的字段个数必须一致 12mysql&gt; select name from student union select name,sex from stu_boy;ERROR 1222 (21000): The used SELECT statements have a different number of columns union两边的select语句的字段名可以不一致，最终按第一个select语句的字段名。 123456789101112mysql&gt; select id,name from student union select name,sex from stu_boy;+--------+-----------+| id | name |+--------+-----------+| 1 | 张宝 || 2 | 李青霞 || 3 | 兰丁丁 || 4 | 赵哥 || 张宝 | 男 || 赵哥 | 男 |+--------+-----------+6 rows in set (0.00 sec) union两边的select语句中的数据类型可以不一致。 union和order by一起使用1、 每条select语句必须用括号括起来。2、 每条select语句的order by必须配合limit才能生效。 例题：男生按数学的降序，女生按语文的升序排列 123456789mysql&gt; (select * from student where sex=&apos;男&apos; order by 数学 desc limit 999) union (select * from student where sex=&apos;女&apos; order by 语文 asc limit 999);+----+-----------+------+--------+--------+| id | name | sex | 语文 | 数学 |+----+-----------+------+--------+--------+| 4 | 赵哥 | 男 | NULL | 89 || 1 | 张宝 | 男 | 56 | 67 || 2 | 李青霞 | 女 | 89 | 92 |+----+-----------+------+--------+--------+3 rows in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据类型、列属性、数据完整性]]></title>
    <url>%2F2015%2F20150830-1.html</url>
    <content type="text"><![CDATA[数据类型数据类型——值类型整型 整型 占用字节 范围 范围 tinyint 1 -2^7~2^7-1 -128~127 smallint 2 -2^15~2^15-1 -32768~32767 mediumint 3 -2^23~2^23-1 -8388608~8388607 int 4 -2^31~2^31-1 -2147483648~2147483647 bigint 8 -2^63~2^63-1 - 一个字节=8位，8位就是8个二进制数 整型支持显示宽度：最小的显示位数，比如int(5)，如果数值的位数小于5位，前面加上前导0。比如输入12，显示00012；大于5位就不添加前导0 12345678910111213141516171819mysql&gt; describe student;+-------+--------------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | char(1) | YES | | NULL | || num | int(8) unsigned zerofill | YES | | NULL | |+-------+--------------------------+------+-----+---------+----------------+3 rows in set (0.01 sec)mysql&gt; select * from student;+----+------+------------+| id | name | num |+----+------+------------+| 1 | a | 00002485 || 2 | b | 03678928 || 3 | c | 1234567890 |+----+------+------------+3 rows in set (0.00 sec) 脚下留心：必须结合zerofill才起作用显示宽度不决定显示范围，只是在数值不够指定位数时用0做前导 1234567891011121314151617mysql&gt; alter table student add num2 tinyint;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; insert into student values (null,&apos;d&apos;,&apos;1&apos;,128);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from student;+----+------+------------+------+| id | name | num | num2 |+----+------+------------+------+| 1 | a | 00002485 | NULL || 2 | b | 03678928 | NULL || 3 | c | 1234567890 | NULL || 4 | d | 00000001 | 127 |+----+------+------------+------+4 rows in set (0.00 sec) 超出最大范围会有警告提示，同时值保存最大范围值 无符号整数（unsigned）：无符号数没有负数，正数部分是有符号的两倍 12345678910mysql&gt; insert into student values (null,666);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from student;+----+------+| id | num |+----+------+| 7 | 255 |+----+------+1 row in set (0.00 sec) 浮点型（保存近似值小数） 浮点型 占用字节 范围 float（单精度） 4 -3.4E+38~3.4E+38 double（双精度） 8 -1.8E+308~1.8E+308 浮点数声明: float(M,D) double(M,D)M：总位数D：小数位数 浮点数也是支持显示宽度和无符号数 浮点数支持科学计数法insert into uiste values (5E2,4E-1); 1234567891011mysql&gt; insert into student values (null,5E2,4E-1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from student;+----+--------------+------+| id | num1 | num2 |+----+--------------+------+| 7 | NULL | NULL || 8 | 000000000500 | 00.4 |+----+--------------+------+2 rows in set (0.00 sec) 浮点的精度可能会丢失【指的是小数】insert into uiste values (99.999999999); 123456789101112mysql&gt; insert into student values (null,9.99999999999999,1.1111111111111);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+----+--------------+------+| id | num1 | num2 |+----+--------------+------+| 7 | NULL | NULL || 8 | 000000000500 | 00.4 || 9 | 000000000010 | 01.1 |+----+--------------+------+3 rows in set (0.00 sec) 小数部分如果超过D的限制会四舍五入，整数部分不能超过M-D的限制 定点数语法：decimal(M,D) 定点数是变长的，大致每9个数字用4个字节来存储。定点数之所以能保存精确的小数，因为整数和小数是分开存储的。占用的资源比浮点数要多。定点数和浮点数都支持显示宽度和无符号数 数据类型——字符型 数据类型 描述 char(L) 定长 varchar(L) 变长 tinytext 2^8-1=255 text 2^16-1=65535 mediumtext 2^24-1 longtext 2^32-1 char(10)和varchar(10)的区别？答：相同点：它们最多只能保存10个字符；不同点：char不回收富余的字符，varchar会回收富余的字符。char效率高，浪费空间，varchar节省空间，效率比char低。 char的最大长度是255。varchar理论长度是65535字节,实际根本达不到。具体长度与字符编码有关 大块文本（text）不计算在总长度中,一个大块文本只占用10个字节来保存文本的地址。 数据类型——枚举（enum）从集合中选择一个数据（单选） 1234567891011121314151617181920212223mysql&gt; create database uiste charset=utf8;Query OK, 1 row affected (0.01 sec)mysql&gt; create table student( -&gt; name varchar(20), -&gt; sex enum(&apos;男&apos;,&apos;女&apos;,&apos;保密&apos;) -&gt; )charset=utf8;Query OK, 0 rows affected (0.02 sec)mysql&gt; insert into student values (&apos;杜敏&apos;,&apos;男&apos;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into student values (&apos;钟程程&apos;,&apos;男或女&apos;);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; select * from student;+-----------+------+| name | sex |+-----------+------+| 杜敏 | 男 || 钟程程 | |+-----------+------+2 rows in set (0.00 sec) 使用枚举进行数据选择的时候，没有屏蔽错误信息只是提示了警告信息 MySQL的枚举类型是通过整数来管理的，第一个值是1，第二个值是2，以此类推既然枚举在数据库内部存储的是整数，那么可以直接插入数字 123456789101112131415161718192021mysql&gt; select sex+0 from student;+-------+| sex+0 |+-------+| 1 || 0 |+-------+2 rows in set (0.01 sec)mysql&gt; insert into student values (&apos;赵哥&apos;,2);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+-----------+------+| name | sex |+-----------+------+| 杜敏 | 男 || 钟程程 | || 赵哥 | 女 |+-----------+------+3 rows in set (0.00 sec) 枚举的优点：1、 运行速度快（数字比字符串运算速度快）2、 限制数据3、 节省空间 已知枚举占用2个字节，请问最多有多少个枚举值？答：2个字节=16位，可以保存216个数字（0-65535），枚举是从1开始，所以枚举最多可以有65535个枚举值 数据类型——集合（set)从集合中选择一些数据（多选） 12345mysql&gt; create table student( -&gt; name char, -&gt; hobby set(&apos;看书&apos;,&apos;玩游戏&apos;,&apos;敲代码&apos;,&apos;看电视&apos;) -&gt; )charset=utf8;Query OK, 0 rows affected (0.03 sec) 插入集合的值 12345678910111213141516mysql&gt; insert into student values (&apos;杜敏&apos;,&apos;玩游戏&apos;);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; insert into student values (&apos;小兰&apos;,&apos;看书,敲代码&apos;);Query OK, 1 row affected, 1 warning (0.01 sec)mysql&gt; insert into student values (&apos;兰&apos;,&apos;敲代码,看书&apos;);Query OK, 1 row affected (0.01 sec)mysql&gt; select * from student;+------+------------------+| name | hobby |+------+------------------+| 杜 | 玩游戏 || 小 | 看书,敲代码 || 兰 | 看书,敲代码 |+------+------------------+3 rows in set (0.00 sec) 插入的顺序不一样，但是显示的顺序是一样的 集合和枚举一样，每个集合的元素都分配一个固定的值，分配的方式从左往右按2的0、1、2、…次方 如果是多选，他们的关系是按位或按位与：相同的位上都是1，结果才为1，只要有一个为0，结果为0。按位或：相同的位上只要有一个为1结果就是1。 123456789mysql&gt; select hobby+0 from student;+---------+| hobby+0 |+---------+| 2 || 5 || 5 |+---------+3 rows in set (0.01 sec) 思考：已知集合占用8个字节，最多可以表示几个选项？答：8个字节=64位，一个位表示1个选项，最多可以表示64个选项。 数据类型——日期类型 数据类型 描述 datetime 日期时间，占用8个字节 date 日期 time 时间 timestamp 时间戳 占用4个字节 year 年份 占用1个字节 datetime 格式：年-月-日 小时:分钟:秒 测试 1234mysql&gt; insert into test10 values (&apos;2015-6-24 15:15:15&apos;); --正确mysql&gt; insert into test10 values (&apos;100-6-24 15:15:15&apos;); --正确mysql&gt; insert into test10 values (&apos;9999-6-24 15:15:15&apos;); --正确mysql&gt; insert into test10 values (&apos;10000-6-24 15:15:15&apos;); --错误 datetime保存范围是：1~9999年 timestamp：时间戳 1234mysql&gt; insert into test11 values (&apos;2015-6-24 15:15:15&apos;); --正确的mysql&gt; insert into test11 values (&apos;1969-12-31 23:59:59&apos;); --超过范围mysql&gt; insert into test11 values (&apos;2038-01-19 11:14:08&apos;); --超出范围mysql&gt; insert into test11 values (&apos;2038-01-19 11:14:07&apos;); --正确 datetime类型timestamp类型在表现上是一样的。他们的区别：datetime是从1到9999，而timestamp从1970年~2038年，2038年01月19日11:14:07秒以后就超出timestamp范围了。 year因为只占用1个字节，最多只能表示255个年份，范围是1901-2155之间的年份 time表示时间或时间间隔，范围是-838:59:59~838:59:59 12345mysql&gt; insert into test13 values (12:12:12); --正确mysql&gt; insert into test13 values (&apos;212:12:12&apos;); --正确mysql&gt; insert into test13 values (&apos;-838:59:59&apos;);--正确mysql&gt; insert into test13 values (&apos;838:59:59&apos;); --正确mysql&gt; insert into test13 values (&apos;839:00:00&apos;); --错误 time支持以天的方式插入 insert into student values (&#39;10 12:12:12&#39;); 数据类型——booleanMySQL不支持boolean类型，true和false在数据库中对应1和0。 123456789101112mysql&gt; create table test1( -&gt; `field` boolean -&gt; )charset=utf8;Query OK, 0 rows affected (0.03 sec)mysql&gt; describe test1;+-------+------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+------------+------+-----+---------+-------+| field | tinyint(1) | YES | | NULL | |+-------+------------+------+-----+---------+-------+1 row in set (0.01 sec) 创建数据表的数据类型 手机号码一般使用什么数据类型存储? char性别一般使用什么数据类型存储? char enum年龄信息一般使用什么数据类型存储? tinyint照片信息一般使用什么数据类型存储? binary(二进制)薪水一般使用什么数据类型存储? decimal 一个字段到底选数字还是字符，取决于有没有计算的可能，如果没有计算的可能即使是数字也要用字符类型，比如手机号、QQ号，… 列属性-是否为空(null | not null)null：可以为空not null：不可以为空 列属性——默认值（default） 如果一个字段没有插入值，可以默认插入一个指定的值没有插入的字段插入默认值default关键字用来插入默认值 列属性——自动增长（auto_increment）字段的值从1开始，每次递增1，特点就在字段中的数据不可能重复，适合为记录生成唯一的id 在MySQL中，auto_increment必须是主键。但是主键不一定是自动增长的 既然从1开始，每次递增1，所以一般自动增长都是无符号整数 如果要给自动增长列插入数据，使用null关键字。自动增长列上的数据被删除，默认情况下此记录的编号不再使用。 思考题：在一个自动增长列上，插入三行，删除两行，插入三行，删除两行，插入三行，删除两行，再插入一个记录编号是多少？答：编号从10开始。删除记录与自动增长的编号没有关系 列属性——主键（primary key）主键：唯一标识表中记录的一个或一组列主键的特点：不能重复，不能为空一个表只能有一个主键，主键可以有多个字段组成 主键的作用： 保证数据完整性 加快查询速度 添加主键：方法一【创建表的时候添加主键】12345mysql&gt; create table stu( -&gt; id int primary key, -&gt; name varchar(20) -&gt; );Query OK, 0 rows affected (0.00 sec) 添加主键：方法二【创建表的时候添加主键】12345mysql&gt; create table stu( -&gt; id int, -&gt; name varchar(20), -&gt; primary key(id) -&gt; ); 添加主键：方法三【更改表的时候添加主键】123456789mysql&gt; create table stu( -&gt; id int, -&gt; name varchar(20) -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; alter table stu add primary key (id)Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0 查看主键mysql&gt;desc stu; 创建组合键123456mysql&gt; create table stu( -&gt; id int, -&gt; name varchar(20), -&gt; primary key(id,name) -&gt; );Query OK, 0 rows affected (0.00 sec) 也可以通过更改表的方式来创建组合键alter table stu add primary key(id,name) 删除主键mysql&gt;alter table stu drop primary key; 选择主键的原则1、 最少性：尽量选择一个字段做主键2、 稳定性：尽量选择更新少的列做主键3、 尽量选择数字型的列做主键 主键思考题 在主键列输入的数值，允许为空吗? 不能为空一个表可以有多个主键吗? 不能在一个学校数据库中，如果一个学校内允许重名的学员，但是一个班级内不允许学员重名，可以组合班级和姓名两个字段一起来作为主键吗？可以标识列（自动增长列）允许为字符数据类型吗？ 不允许表中没有合适的列作为主键怎么办？ 添加一个自动增长列 如果标识列A的初始值为1，增长量为1，则输入三行数据以后，再删除两行，下次再输入数据行的时候，标识值从多少开始？ 从4开始 列属性——唯一键特点：不能重复，可以为空一个表可以有多个唯一键作用：1、 保证数据完整性2、 加快数据访问 添加唯一键【创建表的时候添加唯一键】unique keyunique 添加唯一键【创建表的时候添加唯一键】unique key(stuname)unique(stuadd) 设置名字的唯一键unique key `name` (`stuname`)name：唯一键名字stuname：字段名字 添加唯一键【修改表的时候添加唯一键】123456mysql&gt; create table stu( -&gt; id int primary key, -&gt; stuname varchar(20), -&gt; stuadd varchar(100) -&gt; );Query OK, 0 rows affected (0.00 sec) 添加唯一键 12mysql&gt; alter table stu add unique key(stuname); --key可以省略mysql&gt; alter table stu add unique (stuadd); 一次添加多个唯一键mysql&gt;alter table stu add unique(stuname),add unique(stuadd); 查看唯一键mysql&gt;show create talbe stu\G 添加组合唯一键删除唯一键通过唯一键的名字来删除唯一键语法：alter table 表名 drop index 唯一键名称mysql&gt;alter talbe stu drop index stuname; 列属性——备注（comment）SQL注释单行注释：–或#多行注释：/ / 数据完整性保证实体完整性1、 主键约束2、 唯一约束3、 自动增长列 保证域完整性1、 数据类型约束2、 非空约束3、 默认值约束 保证引用完整性1、外键约束：从表中的公共字段是主表的外键 保证自定义完整性1、 存储过程2、 触发器 主表和从表两个表建立关系（两个表只要有公共字段就有关系），一个表称为主表，一个表称为从表。外键约束可以实现：1、 主表中没有的从表中不允许插入2、 从表中有的主表中不允许删除3、 不能更改主表中的值而导致从表中的记录孤立存在。4、 先删除从表，再删除主表 外键（foreign key）1、 外键：从表中的公共字段，公共字段的名字可以不一样，但是数据类型必须一样。2、 外键约束用来保证引用完整性 添加外键foreign key (id) references stuinfo(stuno);方法一：创建表的时候添加外键 references：参照 测试： 主表中没有的，从表中不允许插入 123456先插主表，在插从表mysql&gt; insert into stuinfo values (1,&apos;tom&apos;);Query OK, 1 row affected (0.00 sec)mysql&gt; insert into stumarks values (1,77);Query OK, 1 row affected (0.00 sec) 从表中有的，主表中不能删除 不能更改主表的数据后使得从表的数据孤立 方法二：修改表的时候添加外键语法：alter table stumarks add foreign key (id) references stuinfo(stuno); 123456789101112131415mysql&gt; create table stuinfo( -&gt; stuno char(4) primary key, -&gt; stuname varchar(20) not null -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; create table stumarks( -&gt; id char(4) primary key, -&gt; score int -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; alter table stumarks add foreign key (id) references stuinfo(stuno);Query OK, 0 rows affected (0.01 sec)Records: 0 Duplicates: 0 Warnings: 0 要创建外键必须是innodb引擎，myisam不支持外键约束 创建外键的时候，给外键取名alter table stumarks add constraint `FK1` foreign key(id) references stuinfo(stuno); constraint：约束 删除外键通过外键的名字删除外键语法：alter table 表名 drop foreign key `外键名` 1mysql&gt;alter talbe stumarks drop foreign key `FK1` 如果要在某个字段上添加外键约束，改字段必须要有索引才可以。如果该字段已经存在索引，则直接使用，否则MySQL自动生成索引。 外键操作1、 严格操作（前面讲的是严格操作）2、 置空操作（set null）：如果主表记录删除或更新，从表置空3、 级联操作（cascade）：如果主表记录删除或更新，从表级联 一般来说：主表删除的时候，从表置空操作，主表更新的时候，从表级联操作。语法：foreign key(外键) references 主表(关键字段) [主表删除时候的动作] [主表更新时候的动作] 1234567mysql&gt; create table stumarks( -&gt; id int auto_increment primary key, -&gt; stuno char(4), -&gt; stuscore tinyint(3), -&gt; foreign key(stuno) references stuinfo(stuno) on delete set null on update cascade -&gt; );Query OK, 0 rows affected (0.03 sec) 1234567891011121314151617181920212223242526--错误案例--create table stuinfo(stuno char(4) primary key,stuname varchar(20) not null);create table stumarks(id char(4) primary key,score int);alter table stumarks add constraint FK1 foreign key (id) references stuinfo(stuno) on delete set null on update cascade;--正确案例--create table stuinfo(stuno char(4) primary key,stuname varchar(20) not null);create table stumarks(id1 char(4) primary key,id char(4),score int);alter table stumarks add constraint FK1 foreign key (id) references stuinfo(stuno) on delete set null on update cascade; 使用alter修改表 去创建外键时，是否不能够同时指定制空约束和级联约束？主键不能set null ,所以外键表中新增主键，将外键作为非主键，此问题与alter的设置无关foreign key (stuno) references stuinfo(stuno) on delete set null on update cascade; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263mysql&gt; create table stuinfo( -&gt; stuno char(4) primary key, -&gt; stuname varchar(20) not null -&gt; );Query OK, 0 rows affected (0.02 sec)//主键与非主键之间的关系，主键是不能set null的，所有使用非主键作为外键mysql&gt; create table stumarks( -&gt; id int auto_increment primary key, -&gt; stuno char(4), -&gt; score int, -&gt; foreign key (stuno) references stuinfo(stuno) on delete set null on update cascade -&gt; );Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into stuinfo values (&apos;1001&apos;,&apos;tom&apos;),(&apos;1002&apos;,&apos;berry&apos;);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; insert into stumarks values (null,&apos;1001&apos;,88),(null,&apos;1002&apos;,99);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from stumarks;+----+-------+-------+| id | stuno | score |+----+-------+-------+| 1 | 1001 | 88 || 2 | 1002 | 99 |+----+-------+-------+2 rows in set (0.00 sec)mysql&gt; select * from stuinfo;+-------+---------+| stuno | stuname |+-------+---------+| 1001 | tom || 1002 | berry |+-------+---------+2 rows in set (0.00 sec)mysql&gt; delete from stuinfo where stuno=&apos;1001&apos;;Query OK, 1 row affected (0.00 sec)mysql&gt; select * from stumarks;+----+-------+-------+| id | stuno | score |+----+-------+-------+| 1 | NULL | 88 || 2 | 1002 | 99 |+----+-------+-------+2 rows in set (0.00 sec)mysql&gt; update stuinfo set stuno=&apos;1003&apos; where stuno=&apos;1002&apos;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from stumarks;+----+-------+-------+| id | stuno | score |+----+-------+-------+| 1 | NULL | 88 || 2 | 1003 | 99 |+----+-------+-------+2 rows in set (0.00 sec) 再来一戳，外键级联1234567891011121314151617181920ALTER TABLE stumarks DROP FOREIGN KEY `FK1`;DROP TABLEIF EXISTS stuinfo;DROP TABLEIF EXISTS stumarks;CREATE TABLE stuinfo( stuno CHAR(4) PRIMARY KEY , stuname VARCHAR(10));CREATE TABLE stumarks( id INT auto_increment PRIMARY KEY , stuno CHAR(4) UNIQUE KEY, stuscore TINYINT(3) , CONSTRAINT `FK1` FOREIGN KEY(stuno) REFERENCES stuinfo(stuno) ON DELETESET NULL ON UPDATE CASCADE); 经验总结：设置级联外键由于 on delete set null 的原因不能设置外键为主键，解决外键数据完整的方法是给外键增加为一件 unique key;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 知识、数据库、数据表]]></title>
    <url>%2F2015%2F20150829-1.html</url>
    <content type="text"><![CDATA[SQL DML 和 DDL可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。查询和更新指令构成了 SQL 的 DML 部分：SELECT - 从数据库表中获取数据UPDATE - 更新数据库表中的数据DELETE - 从数据库表中删除数据INSERT INTO - 向数据库表中插入数据SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。SQL 中最重要的 DDL 语句:CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 数据库发展史文件系统-》层次模型-》网状模型-》关系型数据库优点：解决了导航的问题、数据完整性得到了解决 缺点：多表查询效率低解决方法：使用NOSQL（非关系型数据库，Redis、mongodb等等），在数据库中按照键值对来存储。 SQL结构化查询语言，标准SQL，也叫SQL-92 access 微软 SQLSQL Server 微软 T-SQLOracle 甲骨文 PL/SQLMySQL 被甲骨文收购 MySQL windows 服务开启win+R services.msc 打开服务面板net start 查看已经开启的服务 net start mysql 启动服务net stop mysql 关闭服务 MySQL客户端连接服务器安装文件目录下的：MySQL 5.5 Command Line Clientnavicat 客户端PHPmyadmin 客户端设置环境变量后：mysql -hlocalhost -uroot -proot -P3306 (如果MySQL服务器在本地，IP地址可以省略；如果MySQL服务器用的是3306端口，-P也是可以省略的) 退出登录exit;quit;\q;MySQL中的命令后面要加分号，windows命令行的命令后面不用加分号 数据库基本概念数据库：数据库中存放的是表，一个数据库中可以存放多个表表：用来存放数据关系：两个表的公共字段行：记录，也是实体列：字段，也是属性表结构 行 列表数据 记录 字段面向对象 实体 属性 表的冗余只能减少，不能杜绝 数据完整性：正确的数据类型，准确的数据范围 数据库操作连接数据库Mac xampp ：$ /Applications/XAMPP/xamppfiles/bin/mysql -hlocalhost -uroot -p -P3306密码初始为空； 创建数据库语法：create database [if not exists] 数据名 12mysql&gt; create database if not exists uiste;Query OK, 1 row affected (0.00 sec) 问题一： 如果创建的数据库已存在，就会报错解决：创建数据库的时候判断一下数据库是否存在，如果不存在再创建 问题二： 如果数据库名是关键字和特殊字符要报错解决：在特殊字符、关键字行加上反引号create database `$@%`; 为了创建数据库时万无一失，我们可以在所有的数据库名上加上反引号 MySQL数据库的目录数据库文件保存的路径在安装MySQL的时候就配置好。也可以在my.ini配置文件中更改 12#Path to the database rootdatadir = &quot;F:/wamp/mysql/Data/&quot; Mac xampp 数据库文件夹：/Applications /XAMPP/xamppfiles/var/mysql 创建一个数据库，就对应一个文件夹，在文件夹中有一个db.opt文件。在此文件中设置数据库的字符集和校对集 12default-character-set = utf8default-collation = utf_general_ci 显示所有数据库【show databases】1234567891011121314mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || cdcol || dedecms || mysql || performance_schema || phpmyadmin || test || uiste |+--------------------+8 rows in set (0.00 sec) information_schema：存储了MySQL服务器管理数据库的信息。比如：数据库名、表、字段名、数据类型及访问权限等等performance_schema：MySQL5.5新增的表，用来保存数据库服务器性能的参数mysql：MySQL系统数据库，保存的登录用户名，密码，以及每个用户的权限等等test：给用户学习和测试的数据库。 删除数据库语法：drop database [if exists] `数据库名` 12345678910111213141516mysql&gt; drop database if exists uiste;Query OK, 0 rows affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || cdcol || dedecms || mysql || performance_schema || phpmyadmin || test |+--------------------+7 rows in set (0.00 sec) 问题： 如果删除的数据库不存在，会报错解决：删除之前判断一下，如果存在就删除 显示创建数据库的语句语法：show create database 数据库名 1234567mysql&gt; show create database uiste;+----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| uiste | CREATE DATABASE `uiste` /*!40100 DEFAULT CHARACTER SET latin1 */ |+----------+------------------------------------------------------------------+1 row in set (0.00 sec) 修改数据库字符编码语法：alter database `数据库名` charset=字符编码 12345678910mysql&gt; alter database uiste charset=utf8;Query OK, 1 row affected (0.01 sec)mysql&gt; show create database uiste;+----------+----------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------+| uiste | CREATE DATABASE `uiste` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+----------------------------------------------------------------+1 row in set (0.00 sec) 选择数据库语法：use `数据库名 12mysql&gt; use uiste;Database changed 表的操作创建表1234567891011create table [if not exists] `表名`( `字段名` 数据类型 [null|not null] [default] [auto_increment] [primary key] [comment], 字段名 数据类型 …)[engine=存储引擎] [charset=字符编码]null|not null 是否为空default: 默认值auto_increment 自动增长primary key 主键comment: 备注engine 引擎 表名和字段名如果用了关键字，要用反引号引起来。 创建简单的表 12345mysql&gt; create table student( -&gt; id int not null auto_increment primary key comment &apos;学生编号&apos;, -&gt; name varchar(10) not null comment &apos;学生姓名&apos;, -&gt; sex char(4) default &apos;男&apos;);Query OK, 0 rows affected (0.03 sec) 创建复杂的表 123456mysql&gt; create table `goods`( -&gt; `id` int auto_increment primary key comment &apos;商品编号&apos;, -&gt; `name` varchar(20) not null comment &apos;商品名称&apos;, -&gt; `add` varchar(100) not null default &apos;地址不详&apos; comment &apos;商品产地&apos; -&gt; )engine=innodb charset=utf8 comment &apos;商品表&apos;;Query OK, 0 rows affected (0.05 sec) create table 数据库名.表名，用于给指定的数据库创建表 1234mysql&gt; create table uiste.teacher( -&gt; id int auto_increment primary key, -&gt; name varchar(16) not null);Query OK, 0 rows affected (0.02 sec) 数据表文件 一个数据库对应一个文件夹 一个表对应一个或多个文件夹引擎是myisam，一个表对应三个文件(不支持外键约束) t1.frm 表结构t1.MYD 表数据t1.MYI 表索引引擎是innodb,一个表对应一个表结构文件 所有的innodb引擎的数据统一的存放在data\ibdata1文件中。如果数据量很大，MySQL会自动的创建ibdata2，ibdata3，…，目的就是为了便于管理。 constraint：约束 显示所有表语法：show tables; 12345678mysql&gt; show tables;+-----------------+| Tables_in_uiste |+-----------------+| student || teacher |+-----------------+2 rows in set (0.00 sec) 显示创建表的语句语法：show create table `表名` 123456789101112mysql&gt; show create table student;+---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| student | CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;学生编号&apos;, `name` varchar(10) NOT NULL COMMENT &apos;学生姓名&apos;, `sex` char(4) DEFAULT &apos;男&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+---------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec) 将两个字段竖着排列语法：show create table `表名`\G 12345678910mysql&gt; show create table student \G*************************** 1. row *************************** Table: studentCreate Table: CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;学生编号&apos;, `name` varchar(10) NOT NULL COMMENT &apos;学生姓名&apos;, `sex` char(4) DEFAULT &apos;男&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 查看表结构语法：desc[ribe] `表名` 12345678910111213141516171819mysql&gt; desc student;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || sex | char(4) | YES | | 男 | |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.01 sec)mysql&gt; describe student;+-------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | varchar(10) | NO | | NULL | || sex | char(4) | YES | | 男 | |+-------+-------------+------+-----+---------+----------------+3 rows in set (0.01 sec) desc 是 describe 的简写 复制表语法一：create table 新表 select 字段 from 旧表 123mysql&gt; create table student2 select * from student;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 特点：不能复制父表的键，能够复制父表的数据 语法二：create table 新表 like 旧表 12mysql&gt; create table student3 like student;Query OK, 0 rows affected (0.03 sec) 特点：只能复制表结构，不能复制表数据 删除表语法：drop table [if exists] 表1，表2,… 12mysql&gt; drop table if exists student2;Query OK, 0 rows affected (0.01 sec) 如果删除一个不存在的表就会报错，删除的时候可以判断一下，存在就删除 可以一次删除多个表 12mysql&gt; drop tables if exists student2,student3;Query OK, 0 rows affected (0.01 sec) 修改表语法：alter table 表名 添加字段语法：alter table 表名add [column] 字段名 数据类型 [位置] 123mysql&gt; alter table student add age int(8) after name;Query OK, 0 rows affected (0.20 sec)Records: 0 Duplicates: 0 Warnings: 0 默认字段放在表的最后添加 first 字段放在表的第一位添加 after name 放在 name 字段之后 删除字段语法：alter table 表 drop [column] 字段名 123mysql&gt; alter table student drop age;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0 修改字段(改名)语法：alter table 表 change [column] 原字段名 新字段名 数据类型 … 123mysql&gt; alter table student change sex age int(8);Query OK, 0 rows affected (0.32 sec)Records: 0 Duplicates: 0 Warnings: 0 同时修改多个字段 123mysql&gt; alter table student change age myage int(8) comment &apos;我的学生年龄&apos;,change name myname varchar(16) not null comment &apos;我的学生姓名&apos;;Query OK, 0 rows affected (0.04 sec)Records: 0 Duplicates: 0 Warnings: 0 修改字段（不改名）语法：alter table 表 modify 字段名 字段属性… 123mysql&gt; alter table student modify myage int(3) not null default 18 comment &apos;如果你没 有设置年龄，我就是永远的18岁&apos;;Query OK, 0 rows affected (0.02 sec)Records: 0 Duplicates: 0 Warnings: 0 只更改字段属性 修改引擎语法：alter table 表名 engine=引擎名 123mysql&gt; alter table student engine=myisam;Query OK, 0 rows affected (0.18 sec)Records: 0 Duplicates: 0 Warnings: 0 修改表名语法：alter table 表名 rename to 新表名 12mysql&gt; alter table student rename to student2;Query OK, 0 rows affected (0.00 sec) 将表移动到其他数据库语法：alter table 表名 rename to 数据库名.数据表名 12alter table student2 rename to test.student3;Query OK, 0 rows affected (0.01 sec) 数据操作插入数据语法：insert into 表名 (字段名, 字段名,…) values (值1, 值1,…) 插入一条数据 12mysql&gt; insert into student (id,name,age) values (1,&apos;小兰&apos;,25);Query OK, 1 row affected (0.01 sec) 插入字段名的顺序和数据库字段名的顺序可以不一致 插入值的个数、顺序必须和插入字段名的个数、顺序要一致 简写方式： 12mysql&gt; insert into student values (2,&apos;杜总&apos;,24);Query OK, 1 row affected (0.02 sec) 自动增长列，可以直接插入null。 插入默认值和空值 12mysql&gt; insert into student values (null,&apos;张宝&apos;,null);Query OK, 1 row affected (0.01 sec) 自动增长列，可以直接插入nulldefault关键字用来插入默认值，null用来插入空值 插入多条数据 123mysql&gt; insert into student values (null,&apos;小张&apos;,18),(null,&apos;圆哥&apos;,18);Query OK, 2 rows affected (0.00 sec)Records: 2 Duplicates: 0 Warnings: 0 使用insert…set…插入数据 12mysql&gt; insert into student set name=&apos;赵哥&apos;,age=54;Query OK, 1 row affected (0.01 sec) 更新数据语法：update 表名 set 字段=值 [where 条件] [order by 排序] [limit 限制] 将id为三的年龄改为30 123mysql&gt; update student set age=30 where id=3;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0 需要更改多个内容的时候将需要变更的内容用逗号连接； 将id 从大到小数前3名的学生年龄改为16岁 123mysql&gt; update student set age=16 order by id desc limit 3;Query OK, 3 rows affected (0.01 sec)Rows matched: 3 Changed: 3 Warnings: 0 删除数据语法：delete from 表名 [where 条件] [order by 排序] [limit 限制] 12mysql&gt; delete from student where id=9;Query OK, 1 row affected (0.00 sec) 删除id &lt;=7; 12mysql&gt; delete from student where id&lt;=7;Query OK, 7 rows affected (0.00 sec) 清空表 12mysql&gt; delete from student;Query OK, 0 rows affected (0.00 sec) 清空表：truncate table 表名 12mysql&gt; truncate table student;Query OK, 0 rows affected (0.02 sec) delete from 表和truncate table 表区别？delete from 表：遍历表记录，一条一条的删除truncate table：将原表销毁，再创建一个同结构的新表。就清空表而言，这种方法效率高。 字符集字符集：字符在保存和传输时对应的二进制编码集合 数据存储时使用字符集MySQL可以在服务器上、数据库、表、字段上设置字符集 脚下留心：一般在数据库和表上设置字符集，每个字段设置字符集太麻烦。 数据传输时使用字符集发现：在插入数据的时候，如果有中文会报错 12mysql&gt; insert into student values (null,&apos;李白&apos;);ERROR 1366 (HY000):Incorrect string value :&apos;\xC0\xEE\xB0\xD7&apos; for column &apos;name&apos; 分析：客户端编码和服务器连接层编码必须一致，如果不一致就会报错。 查看客户端的字符编码 客户端发送某种编码给服务器，由客户端决定客户端编码不能改变客户端右键——属性——选项——可以查看当前客户端的字符编码（GBK） 查看服务器的字符编码 1234567891011121314mysql&gt; show variables like &apos;character_set_%&apos;;+--------------------------+------------------------------------------------+| Variable_name | Value |+--------------------------+------------------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || character_sets_dir | /Applications/XAMPP/xamppfiles/share/charsets/ |+--------------------------+------------------------------------------------+8 rows in set (0.01 sec) 解决：只要将服务器的编码设置成gbk就可以解决 测试：插入中文查询：插入中文 原因：结果返回的是utf8，客户端用gbk来解析，所以乱码解决：服务器按gbk返回即可 12mysql&gt;set character_set_results=gbk;Query OK, 0 rows affected (0.00 sec) 查询：结果 总结：客户端编码、character_set_client、character_set_results三个编码的值一致即可操作中文。多学一招：我们只要设置“set names 字符编码”，就可以更改character_set_client、character_set_results的值。 查看所有字符集1234567891011121314151617181920212223242526272829303132333435363738394041424344454647mysql&gt; show character set;+----------+-----------------------------+---------------------+--------+| Charset | Description | Default collation | Maxlen |+----------+-----------------------------+---------------------+--------+| big5 | Big5 Traditional Chinese | big5_chinese_ci | 2 || dec8 | DEC West European | dec8_swedish_ci | 1 || cp850 | DOS West European | cp850_general_ci | 1 || hp8 | HP West European | hp8_english_ci | 1 || koi8r | KOI8-R Relcom Russian | koi8r_general_ci | 1 || latin1 | cp1252 West European | latin1_swedish_ci | 1 || latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 || swe7 | 7bit Swedish | swe7_swedish_ci | 1 || ascii | US ASCII | ascii_general_ci | 1 || ujis | EUC-JP Japanese | ujis_japanese_ci | 3 || sjis | Shift-JIS Japanese | sjis_japanese_ci | 2 || hebrew | ISO 8859-8 Hebrew | hebrew_general_ci | 1 || tis620 | TIS620 Thai | tis620_thai_ci | 1 || euckr | EUC-KR Korean | euckr_korean_ci | 2 || koi8u | KOI8-U Ukrainian | koi8u_general_ci | 1 || gb2312 | GB2312 Simplified Chinese | gb2312_chinese_ci | 2 || greek | ISO 8859-7 Greek | greek_general_ci | 1 || cp1250 | Windows Central European | cp1250_general_ci | 1 || gbk | GBK Simplified Chinese | gbk_chinese_ci | 2 || latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 || armscii8 | ARMSCII-8 Armenian | armscii8_general_ci | 1 || utf8 | UTF-8 Unicode | utf8_general_ci | 3 || ucs2 | UCS-2 Unicode | ucs2_general_ci | 2 || cp866 | DOS Russian | cp866_general_ci | 1 || keybcs2 | DOS Kamenicky Czech-Slovak | keybcs2_general_ci | 1 || macce | Mac Central European | macce_general_ci | 1 || macroman | Mac West European | macroman_general_ci | 1 || cp852 | DOS Central European | cp852_general_ci | 1 || latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 || utf8mb4 | UTF-8 Unicode | utf8mb4_general_ci | 4 || cp1251 | Windows Cyrillic | cp1251_general_ci | 1 || utf16 | UTF-16 Unicode | utf16_general_ci | 4 || utf16le | UTF-16LE Unicode | utf16le_general_ci | 4 || cp1256 | Windows Arabic | cp1256_general_ci | 1 || cp1257 | Windows Baltic | cp1257_general_ci | 1 || utf32 | UTF-32 Unicode | utf32_general_ci | 4 || binary | Binary pseudo charset | binary | 1 || geostd8 | GEOSTD8 Georgian | geostd8_general_ci | 1 || cp932 | SJIS for Windows Japanese | cp932_japanese_ci | 2 || eucjpms | UJIS for Windows Japanese | eucjpms_japanese_ci | 3 |+----------+-----------------------------+---------------------+--------+40 rows in set (0.01 sec) 校对集在某种特定的字符集下，字符和字符的大小关系。比如a和B的大小关系：如果不区分大小写a&lt;B；如果区分大小写a&gt;B。脚下留心：不同的校对集他们的比较结果是不一样的语法：collate=校对集创建两个表 12345678910create table stu1(name varchar(20))charset=utf8 collate=utf8_general_ci;create table stu2(name varchar(20))charset=utf8 collate=utf8_bin;–插入测试数据insert into stu1 values (&apos;a&apos;),(&apos;B&apos;);insert into stu2 values (&apos;a&apos;),(&apos;B&apos;); 测试 1234567891011121314151617mysql&gt; select * from stu1 order by name;+------+| name |+------+| a || B |+------+2 rows in set (0.01 sec)mysql&gt; select * from stu2 order by name;+------+| name |+------+| B || a |+------+2 rows in set (0.00 sec) 校对集的规则：1、_bin:按二进制编码进行比较2、_ci:不区分大小写进行比较 查看所有的校对集 12345678910mysql&gt; show collation;+--------------------------+----------+-----+---------+----------+---------+| Collation | Charset | Id | Default | Compiled | Sortlen |+--------------------------+----------+-----+---------+----------+---------+| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 || big5_bin | big5 | 84 | | Yes | 1 || dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 || dec8_bin | dec8 | 69 | | Yes | 1 |此处省略200多行... 常用操作命令文件下载]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组比较-usort]]></title>
    <url>%2F2015%2F20150828-1.html</url>
    <content type="text"><![CDATA[usort()、getdate()自定义排序，书写一个函数，对数组里面的元素大小两两进行比较，如果return -1，则将大的放在前面，如果return 1，则将大的放在后面。 123456789101112131415161718192021&lt;?php $arr5 = array( array('name'=&gt;'jack','age'=&gt;24,'sex'=&gt;'man'), array('name'=&gt;'rose','age'=&gt;38,'sex'=&gt;'wom'), array('name'=&gt;'lucy','age'=&gt;16,'sex'=&gt;'girl'), array('name'=&gt;'lili','age'=&gt;19,'sex'=&gt;'girl'), array('name'=&gt;'Tomi','age'=&gt;27,'sex'=&gt;'boy') );usort($arr5,function($num1,$num2)&#123; if ($num1['age']==$num2['age']) &#123; return 0; &#125; return ($num1['age']&gt;$num2['age'] ? 1 : -1);&#125;);echo "&lt;pre&gt;";var_dump($arr5);echo "&lt;/pre&gt;"; ?&gt; 将二维数组按年龄进行排序 计算上月最后一天星期几 1234567891011121314151617//方法一：玩转一周7天$t = time();$today = date(&apos;d&apos;,$t);//28$weekday = localtime(time(),true);//时间数组$week = $weekday[&apos;tm_wday&apos;];//今天星期几$res = ($today + $week)%7; //本月已过的天数+星期取7的余数就是上月最后一天echo &apos;上月最后一天星期：&apos;.$res;echo &quot;&lt;hr&gt;&quot;;//方法二：玩转时间戳$today = getdate(time())[&apos;mday&apos;];$today2 = $today*24*60*60*1000;$today1 = time();$diff = $today1 - $today2;$res2 = getdate($diff);echo &apos;上月最后一天星期：&apos;.$res2[&apos;wday&apos;]; 补充小知识： 12getdate()[0] == time();getdate(time())[&apos;mday&apos;] == date(&apos;d&apos;,time()); 获取当前页面编码：mb_internal_encoding()修改当前页面编码：mb_interval_encoding(utf-8)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP思想养成</tag>
        <tag>数组比较</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组、字符串]]></title>
    <url>%2F2015%2F20150827-1.html</url>
    <content type="text"><![CDATA[本章是需要熟记的函数，使用的时候有问题查手册 操作数组的函数is_array()判断一个变量是否是一个数组，返回是一个布尔型，如果是数组返回真，如果不是数组，返回假 array_search()查找一个值是否正在一个数组中，返回的是以键名语法：$arr = array_search(&#39;3&#39;,$arr); array_search()查找值区分大小写，不区分数据类型，如果出现同值问题，取前面第一个下标。第三个参数如果是true则区分数据类型$arr = array_search(&#39;3&#39;,$arr,true); 操作键值的函数array_keys()获取数组中的所有下标，以一个索引数组的模式返回语法：$arr2 = array_keys($arr); 获取的数组，下标从0开始依次递增 array_values()获取数组中的所有值，以一个索引数组的模式返回语法：$arr3 = array_values($arr); 如果值是一个数组，也同样将这个数组当成以值赋值给数组 array_combine()将两个数组的值合并成一个数组，第一个数组是下标，第二个数组是值语法：$arr4 = array_combine($arr1,$arr2); 返回的数据类型是一个数组。两个数组参数的元素个数必须要一一对应 in_array()查找数组中的某一个值是否存在语法：var_dump(in_array(&#39;a&#39;,$arr)); in_array查找是区分大小写的，并且默认不区分数据类型，如果想让他区分数据类型，将第三个参数修改为true即可；第一个参数是需要查找的值，第二个参数是查找的数组，返回的结果是一个布尔值而array_search返回的是一个键名 array_key_exists()查找一个键是否在某个数组中语法：var_dump(array_key_exists(&#39;1&#39;,$arr)); 第一个参数是需要查找的下标，第二个参数是需要寻找的数组，返回的结果是一个boolean型本身就不区分数据类型，没有第三个参数； isset()判断一个变量是否已经被定义，如果没有被定义或者值为null返回的结果是false语法：var_dump(isset($arr[&#39;b&#39;])); isset()和array_key_exists的区别，如果下标对应的值为空。isset返回的结果是false，array_key_exists返回的结果是true 合并和拆分字符、数组的函数implode()将一个数组里面的元素合并成一个字符串语法：$str = implode(&#39;&#39;,$arr); 两个参数，第一个是元素值和值之间连接的符号（第一个可以不写），第二个参数是你需要遍历的数组。join()就是implode别名函数 explode()将一个字符串拆分成一个数组语法：$arr = explode(&#39;a&#39;,$str); 两个参数，第一个是拆分字符串的标志，第二个参数是需要拆分的字符串 语法：$arr = explode(&#39;a&#39;,$str,3); 如果第三个元素是正整数，分割成三个部分，最后一个元素会将包含剩下的所有的包含如果第三个原始是负整数，则会将最后的3个元素抛弃， 数组的交并差array_merge()合并两个数组：array_merge(数组1,数组2)语法：$arr = array_merge(range(0,9),range(&#39;a&#39;,&#39;z&#39;)); array_merge如果合并两个数字下标的数组，会将数字重新从0进行组合。array_merge如果合并两个字符串下标的数组，后面的值会将前面的值覆盖。array_merge合并两个数组，先从第一个数组开始合并，然后在合并第二个数组。 array_diff()计算数组差值语法：array array_diff ( array $array1 , array $array2 [, array $... ] ) 对比返回在 array1 中但是不在 array2 及任何其它参数数组中的值。返回一个数组，该数组包括了所有在 array1 中但是不在任何其它参数数组中的值。注意键名保留不变 array_intersect()计算数组的交集语法：array array_intersect ( array $array1 , array $array2 [, array $ ... ] ) array_intersect() 返回一个数组，该数组包含了所有在 array1 中也同时出现在所有其它参数数组中的值。注意键名保留不变。 函数遍历数组回调函数是由计算机自己去调用php中的函数 array_map()将回调函数作用到给定数组的单元上语法：array array_map ( callable $callback , array $arr1 [, array $... ] )语法： array_map(‘函数名’,数组名)。 1234//使用系统函数，调用数组$arr=array(10,-12,46,-9,-45);$arr2 = array_map(&apos;abs&apos;,$arr);var_dump($arr2); 12345678//使用自身定义的函数，调用数组$arr=array(10,-12,46,-9,-45);fucntion fn($num)&#123; $num+=10; return $num;&#125;$arr2 = array_map(&apos;fn&apos;,$arr);var_dump($arr2); 1234//使用匿名函数，调用数组$arr=array(10,-12,46,-9,-45);$arr2 = array_map(function($name)&#123;return &apos;hello&apos;.$name;&#125;,$arr);var_dump($arr2); 结果将所有数字转换为正数； array_map()返回一个数组，该数组包含了 arr1 中的所有单元经过 callback 作用过之后的单元。callback 接受的参数数目应该和传递给 array_map() 函数的数组数目一致。 array_map去回调我们自己定义好的函数 除了第一个参数直接写函数名的方法以外，我们也可以直接写一个匿名函数，达到回调函数的功能 如果第一个参数的值为null，则会把后面的数组的每一个值取出来进行拼接，合并成一个新的数组 array_walk()功能类似于遍历数组，可以同时获取数组里面的值和下标 12345$arr = array(&apos;name&apos;=&gt;&apos;张无忌&apos;,&apos;age&apos;=&gt;528,&apos;sex&apos;=&apos;男&apos;);function fn($value,$key)&#123; echo $key.&apos;-&apos;.$value.&apos;&lt;br&gt;&apos;;&#125;$arr2 = array_walk($arr,&apos;fn&apos;); 可以分别获取下标和值，进行计算。如果函数只写一个参数，则获取的是数组里面的值。 123$arr2 = array_walk($arr,function($value,$key)&#123; echo $key.&apos;-&gt;&apos;.$value,&apos;&lt;br&gt;&apos;;&#125;) array_walk同样支持匿名函数的用法 接触最多的回调函数还是array_map()，array_walk()用的次数相对于而言，比较少。 array_walk第一个参数写的数组名，第二个参数写的才是调用的数组array_walk返回的结果只会是一个布尔型的结果，如果array_walk执行成功返回的记过就是true，如果array_walk执行失败，返回的救过就是false，他不会生成一个新的数组； 栈和队列栈的特点就是先进后出，后进先出。队列的特点就是先进先出，后进后出。 array_push()第一个参数是需要放置的数组，后面的参数是需要放置的元素 1234$arr = array();array_push($arr,&apos;a&apos;);array_push($arr,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);print_r($arr); 一次性可以放置多个元素 array_pop()123456$arr = array();array_push($arr,&apos;a&apos;);array_push($arr,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);array_pop($arr);array_pop($arr);print_r($arr); 出栈一次只能出一个元素。d和c后进的元素，先被拿出来了 返回结果：mexd,溢出的元素 array_shift()出队列 思考：unset和arr_shift有什么区别？答案：使用array_shift去移除一个元素，那个其他的元素位置会往前移一位，保持数据完整性；但是unset删除一个元素，下标也会被删除 array_unshift()就是在数组的第一个位置插入一个元素。 往数组里面第一个元素的位置放置一个元素。 栈和队列的优点：栈和队列都是有效保证数据的完整性； 数组的排序sort()按照数值值得大小进行排序。从小到大的顺序 将原有的下标丢弃，从0开始依次递增 rsort()按照数组的数值进行排序，从大到小的顺序。 也是将原有的下标丢弃，从0开始依次递增 asort()按照数组的数值进行排序，从小到大排序，但是会保留下标 arsort()按照数组的数值进行排序，从大到小排序，但是会保留下标 ksort()按照数组的下标顺序进行排序。从小到大进行排序 krsort()按照数组的下标顺序进行排序，从大到小进行排序 natsort()自然排序 将字符串整体进行排序，而sort会挨个字符进行比较，然后进行排序 usort()自定义排序 12345678910111213141516171819$arr = array( array(&apos;name&apos;=&gt;&apos;jack&apos;,&apos;math&apos;=&gt;78,&apos;age&apos;=&gt;56), array(&apos;name&apos;=&gt;&apos;rose&apos;,&apos;math&apos;=&gt;98,&apos;age&apos;=&gt;14), array(&apos;name&apos;=&gt;&apos;jame&apos;,&apos;math&apos;=&gt;56,&apos;age&apos;=&gt;67), array(&apos;name&apos;=&gt;&apos;uiste&apos;,&apos;math&apos;=&gt;45,&apos;age&apos;=&gt;24) );usort($arr,function($num1,$num2)&#123; if ($num1[&apos;age&apos;]&gt;$num2[&apos;age&apos;]) &#123; return 1; &#125;elseif ($num1[&apos;age&apos;]&lt;$num2[&apos;age&apos;]) &#123; return -1; &#125;else&#123; return 0; &#125;&#125;);echo &quot;&lt;pre&gt;&quot;;print_r($arr);echo &quot;&lt;/pre&gt;&quot;; 在第一个参数小于，等于或大于第二个参数时，该比较函数必须相应地返回一个小于，等于或大于0的整数。 如果return -1则值放在前面如果 return 1 则值放在后面如果 return 0 则值的位置不发生变化 关于字符串的函数[]字符串可以理解成字符的合计。 所以，[]就是获取字符串中的某一个字符 strlen()获取字符串的长度 获取长度的单位是字节,中文下的感叹号也被分解为三个字节；空格也在空间 trim()去除两边的空格 rtrim()除去右边的空格 ltrim()去除左边的空格 strpos()获取字符串某个字符的位置语法：strpos($str,&#39;b&#39;); 获取某个字符首次出现的位置。如果后面加上第三个参数，代表字符串从某个位置开始往后去寻找。如果没写第三个参数，则第三个参数默认为0 语法：strpos($str,&#39;b&#39;,3); 参数为3，则是从字符串第4个位置开始去寻找 strrpos()获取某个字符出现的最后一个位置语法：var_dump(strrpo($str,&#39;b&#39;,2)); 从右往左查找，第三个参数代表最终查找到某个字符结束。找到返回下标，找不到返回false; str_repeat()将某个字符串重复多少次 第一个参数是需要重复的字符串，第二个参数重复的次数； chr()将一个数字转换成ASCII码 ord()将一个ASCII转换成对应的数字 substr()截取某个字符串语法：substr($str,3); 从下标为3的字符开始，一直截取到结束 语法：substr($str,3,4); 从下标为3的字符开始，截取4个字符 语法：substr($str,3,-3); 从下标为3的字符开始截取，舍去最后三个字符 语法：substr($str,-4,2); 从右往左数4个字符开始截取，截取2个 语法：substr($str,-5,-2); 从右往左数第五个字符开始截取，截取到倒数第二位终止 strchr()从某个字符开始截取语法：strchr($str,&#39;c&#39;); 从左往右第一个c开始截取到最后（区分大小写） strstr()的功能和strchr()的功能一模一样，只不过名称不同 stristr()也是从某个字符开始截取，但是不区分大小写 strrchr()从某个字符最后出现的位置开始往后截取 可以非常方便的获取文件的后缀名 str_replace()语法：str_replace(替换前的字符串，替换后的字符串，需要替换的字符串) str_split()分割字符串，生成一个数组 第一个参数是一个字符串，第二个参数代表以几个字节进行拆分explode是以字符进行拆分的 str_pad()填充字符串 四个参数组成，第一个是填充的字符串，第二个是长度，第三个是填充物，第四个是左，右，两边填充 strtolower()将一个字符串转换成全小写 strtoupper()将一个字符串转换成全大写 nl2br()将\n转换成 htmlspecialchars():将标签当成普通文本输出 urlencode()可以将字符串进行加密 urldecode()可以将加密好的字符串进行解码 多字符处理函数多字符处理函数，不是php默认的开启模式，需要通过配置php.ini进行操作 extension=php_mbstring.dll mb_strlen()获取字符的长度 第一个参数是我们需要获取的字符串，第二个参数是选择的编码格式 mb_internal_encoding() 获取当前的编码格式（不加参数） 修改当前的编码模式（增加参数） mb_strpos()查找当前某个字符的位置 mb_substr()截取字符 iconv()转换格式 里面三个参数，第一个是当前的编码，第二个是转换后的编码，第三个是需要转换的字符串]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组相关]]></title>
    <url>%2F2015%2F20150826-1.html</url>
    <content type="text"><![CDATA[复习：匿名函数use用法：将外部和匿名函数处于同一级的变量引用到匿名函数的内部，引用的变量和外部的变量是一个值传递的关系。如果需要引用传址，则在usb变量前加&amp;符号 迭代 单单从思想的角度上看，递归和迭代没有谁优谁劣，都是一样的，就和大家偏文科偏理科一样，但是，从代码的角度上来看，无疑是迭代的思想更加具有效率，所以建议大家以后去多用迭代的思想去解决问题。 数组不是所有关联数组都是字符串下标$arr = array(1110=&gt;&#39;刘德华&#39;,1111=&gt;&#39;金城武&#39;);不是所有数组都是整形下标$arr = array(&#39;a&#39;=&gt;&#39;雪碧&#39;,&#39;b&#39;=&gt;&#39;可乐&#39;,&#39;c&#39;=&gt;&#39;王老吉&#39;); foreach 遍历数组语法：foreach(需要遍历数组的名称 as 数组的键 =&gt; 数组的值){ } 语法：foreach(需要遍历数组的名称 as 数组的值){ } 注意： foreach遍历数组的时候，数组的指针会自动的下移。foreach遍历完数组以后，指针会指向一个非法的位置foreach在遍历数组之前，会现对数组做一个初始化的操作 foreach遍历数组，实际是遍历数组的拷贝值,改变原数组的结果，不会影响到遍历数组的结果,foreach遍历数组，如果改变$value的值，原数组不会发生变化 123456foreach($arr as $key =&gt; $value)&#123; $value = &apos;加多宝&apos;; echo &apos;数组的下标是：&apos;.$key.&apos;&lt;br&gt;&apos;; echo &apos;数组的值为：&apos;.$value.&apos;&lt;br&gt;&apos;;&#125;var_dump($arr); foreach遍历数组同样支持引用传值，改变$value的值，原数组也会随之发生变化。 12345foreach($arr as &amp;$value)&#123; $value = &apos;加多宝&apos;; echo &apos;数组的值为：&apos;.$value.&apos;&lt;br&gt;&apos;;&#125;var_dump($arr); foreach遍历完数组以后，下标是一个不确定的情况，如果foreach遍历完以后需要使用数组，最好将他做一个初始化的操作。 指针 遍历数组 通过移动数组的指针，完成一个遍历数组的情况，指针指向的位置一般是分为一个合法位和非法位 next($arr) : 让指针下移一位–&gt;指针下移current($arr): 获取指针指向当前元素的值–&gt;获取当前值key($arr) : 获取指针指向当前元素的下标–&gt;获取当前元素下标 for(;current($arr);next($arr)){ echo “数组元素的下标为：”.key($arr).’‘; echo “数组元素的值为：”.current($arr).’‘;} prev() : 让数组的指针上移一位。 上移指针和下移指针是相对于现在的位置而言，所以一旦指针处于一个非法位置，没有参照物了，指针无论上移还是下移都是非法位 reset() : 初始化指针。end() : 将数组指针指向数组的最后一个元素。 reset()和end()理解成相当于一个绝对路径的概念，我不需要管数组指针当前指向的位置，直接将数组指针指向第一个元素或者最后一个元素 each() :返回一个四个元素的数组，其中1和value代表当前数组指向的值，0和key指向当前数组的下标。并且他会让数组的指针下移一位 while+each+list 遍历数组each可以获取元素的值，下标和下移指针，所以直接和while配合，就可以遍历数组方法一 1234while($element = each($arr))&#123; echo &apos;下标：&apos;,$element[0]; echo &apos;值：&apos;,$element[1];&#125; 方法二 1234while(list($key,$value)=each($arr))&#123; echo &apos;下标：&apos;,$key; echo &apos;值：&apos;,$value;&#125; list（） ： list可以将数组里面的值赋值给一个变量 each获取的是一个数组类型的变量，所以可以利用list将数组的值获取出来 3种遍历数组的方式，for(),foreach(),while+each+list的方式，以后工作中90%的人基本上用的都是foreach,9%都会使用while+each+list的方法，for基本上没有人使用 关于赋值的指针问题1234$arr=array(‘a’,’b’,’c’,’d’);$arr2=$arr;echo current($arr2);//结果是 a，地址传递 12345$arr=array(‘a’,’b’,’c’,’d’);next($arr);$arr2=$arr;echo current($arr2);// 结果是b，复制数组的时候，指针跟着一起被复制 12345$arr=array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);$arr2=$arr;next($arr);echo current($arr2);// 结果是a ,复制数组以后，修改一个数组的指针，另一个数组不会一起发生变化。 12345678$arr=array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;);next($arr);next($arr);next($arr);next($arr);$arr2=$arr;echo current($arr2);// 结果是a ,当一个数组处于一个非法位置的时候，复制给另一个数组，此时先查看哪个，哪个就会被初始化，另一个就不会初始化； COW 写时复制如果将一个变量赋值给另一个变量，不会立刻去开辟一个空间，只有当变量进行写操作的时候，才会给他开辟一个空间。 memory_get_usage() 获取文件占用空间的大小。array_fill（开始下标，添加元素的数量，默认值）shuffle() - 将数组打乱array_fill() - 用给定的值填充数组 在foreach里面对原数组进行写操作时，复制的数组才开辟了一块空间 123456 header(&quot;content-type:text/html;charset=utf-8&quot;); $arr=array(&apos;可乐&apos;,&apos;雪碧&apos;,&apos;王老吉&apos;); foreach($arr as $key =&gt; $value)&#123; &#125; var_dump(current($arr));//指针停留在非法位，没有进行写操作。 1234567 header(&quot;content-type:text/html;charset=utf-8&quot;); $arr=array(&apos;可乐&apos;,&apos;雪碧&apos;,&apos;王老吉&apos;); foreach($arr as $key =&gt; $value)&#123; $arr[1]=&apos;加多宝&apos;; &#125; var_dump(current($arr));//结果为加多宝，foreach循环的是复制的原始数组，里面更改的也是原始数组。 123456789 header(&quot;content-type:text/html;charset=utf-8&quot;); $arr=array(&apos;可乐&apos;,&apos;雪碧&apos;,&apos;王老吉&apos;); foreach($arr as $key =&gt; $value)&#123; if($key==1)&#123; $arr[1]=&apos;加多宝&apos;; &#125; &#125; var_dump(current($arr));//结果为王老吉，进行了写操作。 12345678 $arr=array(&apos;可乐&apos;,&apos;雪碧&apos;,&apos;王老吉&apos;); foreach($arr as $key =&gt; $value)&#123; if($key==2)&#123; $arr[1]=&apos;加多宝&apos;; &#125; &#125; var_dump(current($arr));//结果为可乐，复制数组的时候，指针处于一个非法位置，所以指针被初始化操作了。 123456789 header(&quot;content-type:text/html;charset=utf-8&quot;); $arr=array(&apos;可乐&apos;,&apos;雪碧&apos;,&apos;王老吉&apos;); foreach($arr as $key =&gt; $value)&#123; if($key==3)&#123; $arr[1]=&apos;加多宝&apos;; &#125; &#125; var_dump(current($arr));//if语句一直没有被执行，所以一直没有进行写时复制。所以遍历完数组以后，指针指向非法位 foreach变量数组总结 先复制后移动，原始数组保持指针不变先移动后复制，复制的数组会将指针也复制了指针处于非法位置时，进行复制，先查看哪个数组，哪个就先被初始化 关于数组的几个函数range（初始值，结束值）$arr = range(1,10); array_merge(数组1,数组2)$arr = array_merge(range(0,9),range(&#39;a&#39;,&#39;z&#39;)); array_merge如果合并两个数字下标的数组，会将数字重新从0进行组合。array_merge如果合并两个字符串下标的数组，后面的值会将前面的值覆盖。array_merge合并两个数组，先从第一个数组开始合并，然后在合并第二个数组。 array_rand(数组，个数);随机获取一个数组的下标 array_rand获取的是元素的下标，如果只获取一个元素下标，则是以普通数据类型进行存储，如果获取多个下标，则以数组的模式进行存储。虽然array_rand是随机获取下标的，但是他获取多个下标的时候会从小到大排序 shuffle()可以打乱一个数组的元素 返回值是bool(true), 随机验证码 12345678$arr = array_merge(range(0,9),range(&apos;a&apos;,&apos;z&apos;),range(&apos;A&apos;,&apos;Z&apos;));$arr2 = array_rand($arr,4);shuffle($arr2);$str = &apos;&apos;;foreach ($arr2 as $value) &#123; $str.=$arr[$value];&#125;var_dump($str); 补充： memory_get_usage() 获取当前文件占用空间的大小；array_fill(0,10,’uiste’); 0开始下标，10是元素个数，uiste是每个元素的内容]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php函数基础]]></title>
    <url>%2F2015%2F20150824-1.html</url>
    <content type="text"><![CDATA[return 中断文件的功能：终止的仅仅是当前return所在的文件，而不是终止整个程序。 返回值 return返回结果，可以是一个变量，所以，同样支持值传递和引用传递两种方法，如果使用引用传递，则在函数名的前面加上一个&amp; exit()/die()exit()和die()的功能一模一样，他们就是一个功能的两种叫法。作用是终止程序。 sleep()sleep后面有一个参数，代表程序延迟多少秒后继续执行。 函数调用时间代码是先进行解析再执行里面的语句，解析阶段已经预先给function开辟了空间，所以执行阶段调用函数时，可以将调用函数放在函数声明之前。 可变函数可以用一个变量来存放函数名，需要调用函数的时候，直接调用这个变量 作用:将一堆复杂的函数放在一个可变的数组集合中。 12345678910111213imagecreatefromjpg();imagecreatefromjpeg();imagecreatefrombmp();imagecreatefromgif();$file = &apos;chihuo.jpg&apos;;$type = &apos;jpg&apos;;$arr = array( &apos;jpg&apos; =&gt; &apos;imagecreatefromjpg&apos;, &apos;jpeg&apos;=&gt; &apos;imagecreatefromjpeg&apos;, &apos;bmp&apos; =&gt; &apos;imagecreatefrombmp&apos;, &apos;gif&apos; =&gt; &apos;imagecreatefromgif&apos;)$arr[$type](); 匿名函数没有函数名的函数，称之为匿名函数，匿名函数一般是将他赋值给一个变量，需要加载的时候，直接加载这个变量 作用：调用完成后使用unset快速销毁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849$fn = function($name)&#123; echo $name;&#125;var_dump($fn);``&gt;在匿名函数中，要先声明函数，在定义函数### create_function() 创建一个函数&gt;作用：网站多国语言创建有需求的语言函数，节约空间语法：`create_function(‘参数列表’,’函数体’)；`&gt;create_function括号内的参数和函数体，必须要被单引号包裹起来，不能使用双引号如果要传递多个参数，在参数列表的单引号内，用,进行分割在一些大型的项目中，使用create_function模式去创建函数，可以极大的节省项目所占用的内存空间**`create_function`创建函数以后，默认的函数名是（隐藏字节+lambda_1），每当调用一次函数，后面的数字加1，重启apache以后，数字清零**### function_exists() 判断一个函数是否已经被定义&gt;一般项目中代码量很大，去寻找一个函数会比较复杂，所以会用function_exists（‘函数名’）去判断一个一个函数是否已经被定义### 参数形参： 声名函数时所使用的参数实参： 调用函数时所使用的参数**直接传递参数的模式，就是一个值传递的过程，改变一个变量的值，不影响另一个变量**&gt;如果一个参数，有默认值的话，如果实参没有传递，形参以默认值的数据存在，而如果实参传递了一个数据。则形参以实参传递的数据为主**参数的默认值不能是一个变量，因为function关键词在代码的解析阶段就会去运行，但是这个时候并没有变量的赋值，变量的赋值操作是在代码的运行阶段才会被复制。****参数的默认值，可以是一个常量，如果在调用函数之前定义了这个常量，则默认值会以常量的值进行计算。如果在调用函数之前还没有定义这个常量，则函数会将常量名当成一个普通的字符串去解析。**我们会把带默认值的形参统一放在参数列表的最右边，这样，在实参传递的时候，就不会出现问题**参数个数带来的问题**&gt;实参的个数少于形参的个数---报错--代码还会继续运行下去形参的个数少于实参的个数--不报错，代码正常运行--超出部分不被接收### 极限情况在一个函数不知道会传递多少个实参的时候，一般形参一个不写。代码不会报错。**func_get_args()**会将传递的实参以一个数组的形式去进行保存。**func_get_arg(num)**获取传递的第num+1个实参的值。**func_num_args()**获取传递实参的个数。 // 计算不确定个数数字的和。//方法一 function hs(){ $num=func_num_args(); $sum=0; for($i=0;$i&lt;$num;$i++){ $sum+=func_get_arg($i); } echo $sum; } hs(1,3,5,6,7,8,9); //方法二 function hs2(){ $arr=func_get_args(); $sum=0; for($i=0,$n=count($arr);$i&lt;$n;$i++){ $sum+=$arr[$i]; } echo $sum; } hs2(1,3,5,6,7,8,9); 1234567891011121314151617181920212223242526&gt;我们可以用func_get_args去同时替代func_get_arg,func_num_args两个函数&gt;如果我需要返回的值是一个非常非常大的数组或者其他数据类型，如果使用值传递，则需要花费时间去重新复制一个值，而如果使用引用传递，直接复制地址就可以了，可以节省很多的时间### 变量的作用域#### 全局变量在函数外部定义的变量称之为全局变量#### 局部变量在函数体内部定义的变量称之为局部变量&gt;在JS中全局变量可以在局部使用，局部变量不能在全局中使用。在PHP中，全局变量不能再局部使用，局部变量也不能在全局中使用。PHP中全局变量只能在函数的外面使用，局部变量只能在函数的内部使用**如果一个变量的作用域同时包含函数内和函数外，那么他就是一个超全局的变量**九大超全局变量的作用域都是函数内+函数外##### $GLOBALS用$GLOBALS去定义一个变量，$变量名和$GLOBAL[‘变量名’]存在一定的关系。&gt;$变量名和$GLOBALS变量名两者是一个一体的关系，修改一个另一个也会发生变化，删除一个另一个就不存在了**关键词global**语法 global 变量名 作用，将一个全局变量引用传值到局部变量中，两者是两个独立的变量 function hs(){ global $age; $age++; unset($age);}$age = 27;hs();echo $age; 结果：28;12345678910111213141516171819202122&gt;虽然global被php大力推广，但是效果很差，程序员还是习惯使用$GLOBALS用法### 变量的生命周期全局变量的生命周期，是从**被定义的时候开始，到文件运行完毕**以后，当前文件的全局变量生命周期就会结束。局部变量的生命周期，是从**函数内部被定义开始，到函数执行完毕**以后，当前函数内的所有变量，生命周期就会结束**static 静态变量**static 用来定义一个静态变量&gt;静态变量只会被初始化一次，之后不会被重新初始化静态变量的生命周期等同与全局变量的生命周期，但是他的作用域等同于局部变量的作用以上所说都是正常情况下变量的生命周期，但是，我们同样可以用unset()来提前结束一个变量的生命周期。### 匿名函数可以通过对变量的类型进行判断，如果是一个字符串，说明是一个可变函数，如果是一个对象，说明是一个匿名函数匿名函数的优点&gt;匿名函数可以随时随地被调用，也可以随时随地被销毁。特别适合一些临时性的函数**use**虽然，匿名函数是一个赋值语句，但是里面的变量都是一些局部变量。 我们可以利用use将一个和函数处于同一作用域的变量引用进来 $c = 30;$fn = function() use($c){ $a = 10; $b = 20; echo $a+$b+$c;} $fn(); 结果：60;12 $name = ‘rose’;function abc(){ $name = ‘jack’; $fn = function() use($name){ echo $name; }$fn();}abc(); 结果是：jack;123456789101112131415161718192021222324252627&gt;作用域并不是一成不变的，一个全局变量，也可能会变成一个局部变量。use调用函数同样支持值传递和引用传递，如果使用引用传值，在use右边的变量前加上一个&amp;### 递归函数递归是属于分治（分，治，合）的算法。迭代也属于分治的算法。递归函数，就是在一个函数里面继续调用一个函数。递归函数必须由两个部分组成：递归点：一个函数继续调用他本身。 如果没有递归点，他就不算一个递归函数。递归出口：如果一个函数不断地调用他本身，没有出口的话，这个函数会一直运行到空间耗尽或者是时间耗尽的情况才会结束。所以一个函数必须要有递归出口计算个菲波拉契数列，输出第n项的数字```php//计算菲波拉契数列 //用递归实现菲波拉契数列 function fn($n)&#123; //第一项和第二项的结果是1 if($n==1||$n==2)&#123; return 1; &#125; //从第三项开始，每一项等于前两项的和 return fn($n-1)+fn($n-2); //递归点 &#125; echo fn(11);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php基础语法-数据类型、运算符、分支结构、包含文件]]></title>
    <url>%2F2015%2F20150823-1.html</url>
    <content type="text"><![CDATA[ASCII编码ASCII码一共有128个，一个ASCII编码占用1个字节，也就是8位。所以我们书写字符串的时候，一个字母占用1个字节。ASCII编码全部都是连续的，比如A是65，B是66，C，67。ASCII编码小写字母比大写字母大32。比如A是65，小写a是97。 chr() : 将一个数字转换成对应的ASCII码的字符。ord() : 将一个ASCII码的字符转换成相对应的数 \num 就是将八进制的num转换成ascii编码\xnum 就是将十六进制的num转换成ascii编码 布尔型数字：0、0.0、0.00 等0数都是false字符串：”0”、” “空字符串都是falsenull 和所有为空的数据类型都是false 数组如果不给数组添加下标，则默认下标从0开始依次递增如果数组元素下标之前已经存在数字下标了，那么新的元素下标则为之前元素下标的最大值+1;如果数组元素存在同样的下标，那么后面下标对应的值会将前面的值给覆盖。数组的下标只能是字符串或者整型，如果是其他数据类型，他会将其强制转换成字符串或者整型。 对象对象和数组非常的相似，唯一的区别就是可以在对象里面书写函数，所以我们一般成对象为有生命的数组 空型 null如果一个变量，我们不进行赋值，那么他就是一个null同样的我们也可以主动的给一个变量赋值为null一般情况下，如果一个变量占据了很大的空间，我们又暂时用不到他，我们就可以将他赋值为null，这样他所占据的空间就会被释放 资源 resource一般来说，我们不能自己去创建一个资源，所有的资源都是php已经预先定义好的，我们所能做的就是直接拿过来使用。 数据类型的转换字符串存储在计算机中，是以ASCII编码进行存储，所以他们的存储方式不一样，在做不同数据类型计算的时候，计算机会自动的做一个数据类型的转换 计算机自动的做数据类型的转换 123$a = 12;$b = &apos;4abc&apos;;echo $a+$b; 获取的数据和我们想要的结果不一样，所以我们需要手动的做数据类型的转换 123$a = 12;$b = 3.45;echo $a+(int)$b; (需要转换的数据类型)需要转换的数字即可 如果是一个纯数字的字符串转换的结果就是数字本身，如果带有字母，则从最左边寻找，如果遇到字母，则直接将右边的部分抛弃，如果是空的内容，则强制转换整型的结果为0，false为0,true为1 运算符当进行逻辑运算的时候，如果左边已经达到了最终的结果，那么php为了节省运算的时间，右边就不进行运算了，那么相当于右边的内容被短路了。所以为了避免逻辑短路，尽量不要在逻辑运算符中做算数运算 思考： a++和a+=1对于a本身而言是否一样？答案： 不一样，在++操作字符串的时候，他会做ASCII编码操作。一般来说，只有在算数运算中使用自增自减操作 常用的函数isset() isset(变量名) ： 判断一个变量是否已经被定义。如果被定义，返回的结果是true，否则返回的结果是false。只有变量没有被定义或者变量被定义的结果是null，那么isset()返回的结果是false，除此以外，只要你定义了这个变量，isset的结果就是true。 empty() 语法：empty(变量名)，如果变量里面的内容不为空，则返回的结果是false，否则返回的结果为true。 empty转换的结果和boolean转换的结果正好相反，所以，只需要记住其中一个就可以了。 is_XXX XXX表示一个数据类型。is_int(变量) 判断变量是否是一个整型，true表示是整型，false表示不是整型。is_boolean()is_string()is_float() 替代语法将开始的大括号使用:进行替代，将结束的大括号使用end XXX来替代，这里面的XXX代表的就是这个结构的名称结尾加上“;”分号 替代语法一般来说，是写在html和php的混编语言中使用替代语法，可以非常清晰明了的判断，结束标记到底是属于哪个结构 if语句中如果要是用elseif的话在else和if之间不要加上空格 思考：如果for循环执行了n次循环，那么初始化变量，条件判断和变量更新分别执行了多少次？答案： 初始化变量执行1次，条件判断执行n+1次，变量更新执行n次。 break,continue参数的问题break和continue默认的参数是1，代表break和continue只会跳出当前的一层for循环，如果你想让break和continue一次性跳出多层循环，需要在break和continue的后面加上一个需要跳出的层数 关于switch跳出循环的问题我们可以将switch看成是一个只执行一次的循环体，所以如果要在switch中跳出循环，则要在break的基础上+1 在switch语句中写break和continue的效果是一模一样的 绝对路径和相对路径所谓的相对路径，就是相对于当前文件去查找另一个文件就是一个相对路径。绝对路径就是不参照任何一个位置，所书写的地址。程序中的绝对路径就是从盘符开始，去书写一个路径 ../文件名 上一级文件夹./文件名 当前文件夹文件名 当前文件夹 包含文件所谓的包含文件就是将需要的文件加载到你所编写的文件中去，包含文件有四种方式。include include_once require require_once include加载文件语法，include(需要加载的文件) ， include 需要加载的文件 相对路径的位置不太好确定，在工作中容易引发报错，所以在工作中最好去使用绝对路径 打开phpinfo()，搜索include_path 使用set_include_path(‘需要设置的目录’)123$str = get_include_path();set_include_path(&apos;c:/php/joker;&apos;.$str);include(&apos;joker.php&apos;); 思考，将原来的路径放在新增文件夹路径的左边效率更高还是右边效率更高？答案：放在右边更高一般情况下，在项目中，会将所有需要加载的文件统一放在一个文件夹中，通过set_include_path去进行设置加载 include PK requirerequire也是加载一个文件include加载文件，如果出现了错误，会报一个警告性（warning）的错误，然后代码还会继续往下执行。require加载文件，如果出现了错误，会报一个致命性（fatal error）的错误。然后代码就不会继续往下执行。 include PK include_onceinclude如果载入相同的文件都会分别去执行，但是include_once如果载入相同的文件，只会执行一次。 include_once 的效率更低，因为include_once在加载一个文件之前，都会检查前面的代码，看看这个文件是否已经被加载过了 exit()/die()exit()和die()是同一样函数，只不过起的名字不同。它的作用就是让一个程序终止执行。 sleep()延时函数，让一个程序停止任意秒后继续执行]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP思想养成-打印菱形]]></title>
    <url>%2F2015%2F20150822-2.html</url>
    <content type="text"><![CDATA[拿出一张纸画个图，站在代码外面的世界，分析一下功能实现的步骤，再讲思想转换成代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php header("content-type:text/html;charset=utf-8");// PHP打印菱形的两种方法，备注的信息由于定义层数是从0开始，所以思想与代码有略微区别// copyright ：uisteecho "方法一：通过判定半个菱形的层数将剩余层数输出&lt;br/&gt;";//定义所打印菱形的上半区的层数$row = 5;//循环上半区层数从第0层到层数减一for ($i=0; $i &lt; $row; $i++) &#123; //先打印左侧的空格：总层数减去当前层数减1 for ($j=0; $j &lt; $row-$i-1; $j++) &#123; echo "&amp;nbsp"; &#125; //打印“*”号，当前层数乘以2加1 for ($k=0; $k &lt; $i*2+1; $k++) &#123; echo "*"; &#125; echo "&lt;br/&gt;";&#125;//循环下班去层数从上半区总层数减1for ($i=0; $i &lt; $row-1; $i++) &#123; //打印左侧空格等于下班去当前的层数 for ($j=0; $j &lt;= $i; $j++) &#123; echo "&amp;nbsp"; &#125; //打印“*”号，下半区总层数减去当前层数乘以2加1 for ($k=0; $k &lt; ($row-1-$i)*2-1; $k++) &#123; echo "*"; &#125; echo "&lt;br/&gt;";&#125;echo "&lt;br/&gt;方法：通过整个层数判定分区进行输出（必须为奇数层数）&lt;br/&gt;";//定义所打印菱形的总层数$row=9;//定义上半区的总层数$n = ceil($row/2);//循环所有层数for ($i=0; $i &lt; $row; $i++) &#123; //判断若小于上半区层数进行上半区的循环 if ($i&lt;$n) &#123; //打印空格上半区总层数减去当前层数 for ($j=0; $j &lt; $n-$i-1; $j++) &#123; echo "&amp;nbsp"; &#125; //打印“*”号，当前层数乘以2减1 for ($k=0; $k &lt; $i*2+1; $k++) &#123; echo "*"; &#125; echo "&lt;br/&gt;"; &#125;else&#123; //如果条件不满足上去，开始打印下半区信息 //先打印空格，等于当前层数减去上半区层数 for ($j=0; $j &lt; $i-$n+1; $j++) &#123; echo "&amp;nbsp"; &#125; //打印“*”号，等于总层数减去已经打印层数乘以2加1 for ($k=0; $k &lt; ($row-$i)*2-1; $k++) &#123; echo "*"; &#125; echo "&lt;br/&gt;"; &#125;&#125; ?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP思想养成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统截图快捷键详细介绍]]></title>
    <url>%2F2015%2F20150822-1.html</url>
    <content type="text"><![CDATA[这篇文章介绍了Mac系统截图快捷键组合方式，使用不同的快捷键组合可以在Mac系统截取不同大小和区域的截图。完全可以不用第三方截图工具了，Mac很强大！ 一、基础快捷键（+表示同时操作、-表示分步操作)Cmd+Shift+3：全屏截图；截取整个屏幕，保存截图至桌面文件夹。 Cmd+Shift+4：区域截图；鼠标光标变成带坐标的小十字，通过拖拽截取特定区域，保存截图至桌面文件夹。 Cmd+Shift+4 – 单击空格键 – 鼠标单击指定窗口：窗口截图；出现小十字光标后对指定窗口按空格键，鼠标光标变成照相机，鼠标单击截取指定窗口，保存截图至桌面文件夹。 二、进阶快捷键Cmd+Shift+4 – 按住空格键拖动鼠标：区域截图；选取区域范围后，按住空格键并拖到鼠标可移动选取范围，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 – 按住Shift – 上下/左右移动鼠标：区域截图；选取区域范围后，按住 Shift 并上下/左右移动鼠标即可固定选取范围宽度/高度改变高度/宽度，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 – 按住Shift和Option: 区域截图；选取区域范围后，按住 Shift 和 Option 键在上一快捷键功能的基础上自由切换高度宽度，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 – 按住Option: 区域截图；选取区域范围后，按住 Option 键可按比例缩放选取范围，释放按键后保存截图至桌面文件夹。 PS：以上介绍的快捷键配合按住 Control 键即可将截图文件保存在剪切板，以供调用。 三、利用终端截图还有比较 Geek 的方法就是通过终端（Terminal）命令来截图，终端截图命令 screencapture 有十多种参数可以选择，比如截图后立即显示、消除截图声音、延迟数秒后截图等。有兴趣的读者可以通过下面这条命令查看各个参数的具体使用方法。 screencapture -h]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac系统工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php基础语法-常量、变量、数据类型]]></title>
    <url>%2F2015%2F20150821-1.html</url>
    <content type="text"><![CDATA[php的四种头文件2种标准模式的头文件 &lt;?php ?&gt; 短标签模式 &lt;? ?&gt; 修改配置文件short_open_tag=on asp模式 &lt;% %&gt; 修改配置文件asp_tags=on php的基本语法 php每条语句结束时必须加上结束符;，除非是代码的最后一条语句，并且要有结束标签。 php在单独存在的时候，结束标签可以省略，但是，如果是和html混编在一起，并且结束时后面还有Html代码，则结束标签不能省略 php的输出。 123echo printvar_dump 3个 类型，长度，值 变量$变量名 = 变量值；变量名是由字母，数字和下划线组成，但是数字不能开头，也可以是中文。帕斯卡命名，驼峰命名，下划线命名。删除：unset(), 删除的是变量名和变量的引用，保留了变量值。值传递和引用传递：$变量名1=$变量名2 复制的是值，两个变量是独立存在的，修改一个不影响另一个结果$变量名1=&amp;$变量名2 复制的是变量的引用，两个变量同时指向一个变量值，修改一个变量，另一个也会发生变化。 九大超全局预定义数组变量 $_GET : 获取地址栏提交的数据$_POST : 获取表单post提交的数据$_REQUEST : 既能获取get提交的数据也能获取post提交的数据$_SERVER : 获取服务器的信息$_COOKIE : 获取cookie存储的数据$_FILE : 获取文件信息$_SESSION : 获取session信息$_ENV : 在linux系统下获取的信息$GLOBALS : 设置一个超全局变量 $_GET获取方式： 表单提交提交js提交 ?: 分割域名和get提交数据=： 下标和值的分割&amp;： 获取的不同元素之间的分割。 $_POST获取方式：表单提交$_POST的安全性能更高，$_POST获取的大小更大$_POST 可以获取各种数据类型$_GET只能获取字符串。 $_REQUEST 理解成$_GET+$_POST 既可以获取get数据也可以获取post数据默认情况下如果get和post提交的数据发生冲突，以post提交的数据为主。修改方法：打开php.ini，搜索 request_order，将GP改成PG则以get数据为主 常量：define(“常量名”，‘常量值’，boolean) 常量名：如果直接输出，则必须是字母数字和下划线组成，中文也可以。如果想输出特殊的函数，使用constant(‘常量名’)进行输出。 defined（‘常量名’）判断常量是否已经被定义。 1234567define(&quot;^_^&quot;, &quot;老的常量值&quot;);if (!defined(&quot;^_^&quot;)) &#123; define(&quot;^_^&quot;, &quot;新的常量值&quot;);&#125;else&#123; echo &quot;常量已经定义：&quot;;&#125;echo constant(&quot;^_^&quot;); get_defined_constants（） 获取所有已经被定义过的常量魔术常量：披着常量外皮的变量。LINE 获取代码当前的行数FILE 获取文件所在的路径 const 常量名=值。 数据类型标量数据类型整型 int浮点型 float布尔型 boolean字符串 string 复合数据类型数组 array对象 object 特殊数据类型空型 null资源 resource 整型四个字节，32位，第一位为符号位 0为正 1为负最大值 $$2^31-1 -2^31$$ 如果超出最大值，则会变成浮点型。PHP_INT_MAX 可以获取Int类型的最大值 进制转换十进制 转其他进制使用除法从下往上读取其他进制转换成十进制使用乘法 2 ： bin8 ： oct10 ： dec16 ： hex二进制转换为十进制：bindec(‘需要转换的数字’)八进制转换为十进制：octdec(‘需要转换的数字’)十六进制转换成十进制：hexdec(‘需要转换的数字’)十进制转换为二，八，十六进制：decbin(); decoct(); dechex(); 浮点型有效数字是14位如果要表示一个有效数字超出14位的数字，使用科学记数法。aEb a10^baE-b a10^-b约（1.8E308）浮点型的比较是不标准的。浮点型的进制转换十进制到二进制乘法从上往下读取。绝大情况下获取的数字都是无限循环小数，所以，php只能取他的近似值。 布尔型只有真和假，一般在条件判断中使用。整型：值为零的情况下是false其他都是true字符串：字符串0，和空的情况下，是false，其他都是true其他数据类型：只有空的情况下，结果为false，其他都是true 字符串单引号：若输出字符串使用单引号速度较快双引号：会解析引号内的内容，如果包含的是变量会转换成结果heredoc： 语法&lt;&lt;&lt;heredoc…………………..………heredoc; nowdoc： 语法&lt;&lt;&lt;’heredoc’…………….…………heredoc; 注意： 前后名称可以随意起但是必须要一致。结束名称必须要在当前行的最左边。结束名称后面必须要加;heredoc可以解析php中的变量，但是nowdoc不能解析php中的变量。他俩的区别和单引号双引号的区别非常的相似nowdoc是高版本php中才支持的语言 /php会将机器语言，存储在内存之中/]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP核心编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wamp 多站点配置]]></title>
    <url>%2F2015%2F20150820-1.html</url>
    <content type="text"><![CDATA[wampwindowsa:apachem:mysqlp:php apache的安装安装好了以后右下方会有一个小羽毛按钮。 测试，浏览器的地址栏上输入127.0.0.1 apache四种开启方式 左击小羽毛或者双击小羽毛右击我的电脑，选择管理，再选择服务cmd命令行的模式httpd -k start 环境变量的设置，右击我的电脑，属性，高级系统设置，环境变量，选择path进行编辑。httpd -t 检查apache是否可以正常运行 apache几个比较重要的文件夹 bin:里面都是一些apache可执行文件httpd.exe，apacheMonitor.exehtdocs:默认站点，一般刚安装完apache以后，运行网页会放在htdocs中conf:里面都是apache一些可以配置的文件module：里面是apache的一些模块，加载的模块的功能就是apache的功能。 php的安装解压安装包就可以运行了。打开cmd，输入php.exe -v 可以查看php的版本号目前apache和php是两个独立的存在。打开apache的配置文件。所有加载模块都是 LoadModule 模块名 “路径”加载完了以后，apache不知道后缀名是.php的文件交给php脚本处理器。 加载PHP模块LoadModule php5_module &quot;C:/wamp/php/php5apache2_2.dll&quot; 引入php.ini配置文件PHPIniDir &quot;C:/wamp/php&quot; addtype application/x-httpd-php .php重启apache 代码中输入phpinfo（）可以查看php的所有信息。 方法一：c:/windows，php.ini复制到c:/windows方法二：打开apache的配置文件，输入PHPIniDir “路径” Php的配置文件有两个，php.ini-development php.ini-product一定要重命名php.ini 要给php设置时区。打开php.ini 搜索date.timezone = PRC 安装mysqlmysql 是一个c/s结构，同时安装了客户端和服务器端。配置mysql的配置文件，打开配置向导配置完安装，有四个勾打开cmd 输入mysql.exe -uroot -proot如果出现welcome界面代表大家安装成功 mysql_connect();关联mysql和php打开php的配置文件extension，将php_mysql.dll的注释去掉extension_dir=”路径” 打开apache的配置文件httpd.conf站点：documentRoot允许加载：allow from all关于允许拒绝的顺序 order设置目录：options indexes设置首页: directoryIndex 首页名称 配置虚拟主机12345678&lt;virtualHost *:80&gt;documentRoot 设置站点serverName 设置域名directoryIndex 站点&lt;directory “站点”&gt;&lt; /directory&gt;&lt;/virtualHost&gt; 分布式部署 allowoverride all分布式部署的文件夹 .htaccess不能直接创建，需要通过编辑器去创建。 虚拟站点配置1234567891011121314151617181920&lt;VirtualHost *:80&gt; # 配置管理员的邮箱，当服务器产生500错误（服务器内部错误）的时候会在错误页面上展示该邮箱 ServerAdmin hi@uiste.com # 站点根目录 DocumentRoot &quot;E:\webdocs\sh06&quot; # 站点所绑定的域名 ServerName www.uiste.com # 站点配置别名（域名绑定的另一种形式） ServerName uiste.com # 错误日志，logs目录是指Apache目录下 ErrorLog &quot;logs/sh/error.log&quot; # 正常访问日志，logs也是在Apache目录下，common是指日志记录规则 CustomLog &quot;logs/sh/access.log&quot; common # 针对站点目录的详细配置 &lt;Directory &quot;E:\webdocs\sh06&quot;&gt; allow from all AllowOverride all Options +indexes &lt;/Directory&gt;&lt;/VirtualHost&gt; cmd to hosts127.0.0.1 www.sh06.com sh06.com]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js思想养成-光标定位]]></title>
    <url>%2F2015%2F20150818-1.html</url>
    <content type="text"><![CDATA[当鼠标划过文本框,自动选中文本框中的内容123456789101112131415161718192021&lt;body&gt; &lt;form action="a.php" method="post" name="login" id="form1" onsubmit="return checkName()"&gt; 用户名：&lt;input type="text" name="username" id="username"/&gt;&lt;br/&gt; &lt;input type="submit" id="btn" value="提交"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; // 当鼠标划过文本 框,自动选中文本框中的内容 var obj = document.getElementById("username"); obj.onmouseover = function()&#123; this.select(); &#125; // 表单验证不为空 function checkName()&#123; if (obj.value != "") &#123; return true; &#125;else&#123; return false; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 网页自动跳转so easy!!!1234function gonewpage()&#123; window.location.href = &quot;./new.html&quot;;&#125;setTimeout(&quot;gonewpage()&quot;,2000); 在弹出窗页面输入信息，返回到原始页面中 一个网页,使得打开它时弹出一个全屏的窗口,该窗口中有一个文本框和一个按钮。主窗口 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;主窗口&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;!-- 通过弹出窗口接受信息 --&gt; &lt;a href="" id="a1" target="new"&gt;新窗口&lt;/a&gt; &lt;input type="text" id="msg"&gt; &lt;script type="text/javascript"&gt; var a1 = document.getElementById("a1"); a1.onclick = function()&#123; window.open("new.html","弹出窗口","location=no,toolbar=no,menubar=no"); return false; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 弹出窗口 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;弹出窗口&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="message" id="m1"/&gt;&lt;br/&gt; &lt;input type="button" value="关闭" id="btn" onclick="btn3()"&gt; &lt;script type="text/javascript"&gt; var message = document.getElementById("m1"); var btn2 = document.getElementById("btn2"); function btn3()&#123; var form1 = window.opener.document.getElementById("msg"); form1.value = message.value; window.close(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js思想养成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础知识点]]></title>
    <url>%2F2015%2F20150817-2.html</url>
    <content type="text"><![CDATA[优先级运算符优先级：括号优先逻辑与比逻辑或优先赋值运算符最后 typeof(变量名) 输出变量数据类型 firebug 调试js代码，函数执行完成后会继续返回到调研的位置 在函数内部定义的变量为局部变量，局部变量取消前面的var 就默认为全局变量，全局变量在函数外部使用时，需要先调用函数； 函数可以先定义后调用，同时也可以先调用后定义； arr.length 计算数组长度 isNaN(24) 判断是否不是一个数字,若为”23b”，则不是一个数字，返回ture 数组对象var arrr = [23,24,25];arr.concat(arr1,arr2) 使用concat连接数组或者在arr数组后面增加元素,组成的是新的数组 arr.join(“-“) 使用“-”连接数组的每一项 返回的结果是 23-24-25;如果以空字符串连接，返回的是字符串pop(),删除数组的最后一项，并且返回被删除的元素；push(),加入新的内容，并返回新的长度；reverse():翻转数组的顺序； 字符串对象charAt(3) ,获取指定字符串下标的元素charCodeAt(3),获取指定字符串下标元素的ASCCI值indexOf(“d”),获取字符d在字符串中第一次出现的位置，若无法查找返回-1；lastIndexOf(“d”),获取字符d在字符串中最后一次出现的位置，若无法查找返回-1；split(“n”),将字符串以字符n进行分割，返回一个数组；substr(n,m),截取字符串从n开始的m个元素，如果只有一个参数就截取到最后substring(n,m),截取从下标为n的位置到m的位置；左开右闭区间；如果只有一个参数就截取到最后toLowerCase():将字符串字母转换成小写形式返回，原有字符串大小写不变toUpperCase():将字符串字母转换成大写形式返回，原有字符串大小写不变 判断上传文件的思路：通过使用lastIndexOf(“.”)判断“.”最后出现的文字，再通过substr(n+1,4)截取文件格式后缀进行判断；为避免大小写问题可以通过toLowerCase()统一转换成小写进行判断 Math对象Math.pow(n,m):求n的m次方Math.abs(n)：求n的绝对值Math.round(n):求n的四舍五入值Math.floor(n):求n的向下取整的值Math.ceil(n):求n的向上取整的值Math.random():求0-1的随机整数 ，左开右闭区间求10-20的整数Math.floor(Math.random()*10+10);使用floor比用round公平，出现0的概率与出现1的概率相同； DaTe对象四种创建方式：var n1 = new Date();var n2 = new Date(“1991/11/5”);var n3 = new Date(1991,11,5);显示12月var n4 = new Date(233428408324);toLocaleString():该方法以本地格式显示 getFullYear();获取年份getMonth();获取月份getDate();获取日期getHours();获取小时getMinutes();获取分钟getSeconds();获取秒getMilliSeconds();获取毫秒getDay();获取星期getTime();获取从1970到时间点的毫秒 样式对象obj.style.background = “res”; 背景颜色变为红色obj.style.fontSize = “60px”; 更改字体大小innerHtml获取文档内容（带html标签）innerText获取文本内容（去除HTML标签） 事件onfous:获得焦点onblur:失去焦点onsubmit：提交事件onchange:当发生改变的时候onreset：重置事件onload 当页面加载完成立刻执行的事件两种方式： window.onload=init; Event事件信息对象Event:保存事件发生时的相关信息Event.clientX:事件发生时的X的坐标（鼠标事件的对象）var obj = Event.target:事件发生源（返回触发此事件的元素）Event：必须通过参数形式传递给函数才可以使用 cursor 光标cursor：crosshair;cursor: help;cursor：wait; 错误调试try{运行错误代码}catch(err){alert(err.message);} 创建标签对象var obj = document.createElement(“标签名”) 通过createElement创建标签对象document.body.appendChild(obj); 将标签对象增加到obj中 注意：body中由于margin边距原因可能导致事件不会被触发（小星星案例） 按钮开关的切换方式方法一：通过if语句进行判断value值方法二：通过记录点击的次数，默认开，如果是偶数就返回开，如果是奇数就返回关。注意定义记次变量需作为全局变量方法三：定义一个flag 变量记录bool值，开为ture，关为false方法四：通过this传递当前对象，判断当前对象的value值this代表当前obj window对象var n = prompt(“提示信息”,”默认值”); //pppp就是可以输入信息的confirm()选择确定和取消open(“www.uiste.com&quot;,&quot;uiste博客&quot;,&quot;width=300,height=300,top=20,left=20&quot;) 打开一个新的窗口 定时器一次性定时器：var time1 = windows.setTimeout(“js代码”,时间);反复性定时器：var time2= window.setInterval(“js代码”,时间);清楚定时器：window.clearTimeout(time1); 图片轮播的思想 声明全局变量：背景图变换的序号i,用于清楚定时器的time；第一步：初始化函数中加入一个交换背景图片的反复性定时器用于加载交换函数第二步：图片自动播放联动按钮变化：在交换函数中通过for循环改变i的值，再通过元素样式对象属性进行切换图片；通过第二个循环，与第一循环的i值关联，用于联动按钮的背景样式第三步：写一个stop函数当鼠标放置在img上清楚定时器，start函数鼠标离开时重新启动定时器(注意设置定时器名字)（dsq=window.setInterval(&quot;change()&quot;,1000);）重写一遍定时器第五步：按钮点击联动图片自动切换：通过使用函数值传递，进行判断切换stopImg函数(注意i=n来控制图片切换避免鼠标离开时乱启动图片)&lt;li id=&quot;d1&quot; onmousemove=&quot;stopImg(1,this)&quot; onmouseout=&quot;startImg(this)&quot;&gt;1&lt;/li&gt; 找对象的方法id:document.getElementById(“id名”)；标签名：document.getElementsByTagName(“标签名”);//多个标签以数组形式保存name:document.getElementsByName(“name名”);//数组className:document.getElementsByClassName(“class名”);//数组img:document.images;//数组link对象：document.links;//获取连接对象，数组表单对象：document.form;body标签对象：document.body;html标签对象：document.docuementElement;事件信息对象：event;当前对象：this; location对象location.属性 返回当前页面的URL相关信息location.方法()assign加载新文档【跳转】reload重新加载当前文档【刷新】replace 用新文档替换当前文档【不会再history中生成新的记录】 history 对象包含用户访问过的URL属性：length：返回历史记录中的URL数量方法：back():加载前一个页面forward()：加载后一个页面go(-3)：跳转到指定页面，后退几个页面就写数字几 screen对象screen.height:获取屏幕的高度screen.width:获取屏幕的宽度 navigation对象包含有关浏览器的相关信息appName : 返回浏览器名称appCodeName：返回浏览器代码名appVersion:浏览器版本号和平台信息userAgent:浏览器信息浏览器判断12345678var obj = navigator.userAgent;if(obj.indexOf(&quot;Firefox&quot;!=-1))&#123; alert(&quot;火狐浏览器&quot;);&#125;else if (obj.indexOf(&quot;Chrome&quot;!=-1))&#123; alert(&quot;谷歌浏览器&quot;);&#125;else&#123; alert(&quot;其它浏览器&quot;);&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片轮播]]></title>
    <url>%2F2015%2F20150817-1.html</url>
    <content type="text"><![CDATA[实现思路一步一步来 图片切换 鼠标悬停 按钮跟踪 ………………源代码css javascript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;轮播图片&lt;/title&gt; &lt;style type="text/css"&gt; *&#123; margin: 0; padding: 0; &#125; div &#123; margin:50px; width: 470px; &#125; div ul&#123; float: right; margin-top:45px; &#125; div ul li&#123; list-style:none; width:30px; height: 20px; line-height: 20px; text-align: center; border: 1px solid orange; margin-top:5px; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; window.onload = init; var i =1; var time; function init()&#123; var obj = document.getElementById("d1"); //解决第一背景颜色不变的情况 obj.style.background = "orange"; time = window.setInterval('change()',1000); &#125; function change()&#123; i++; if (i&gt;5) &#123; i=1; &#125; var obj = document.getElementById('img'); obj.src = "images/beijing_" + i + ".jpg"; var obj2 = document.getElementById("d"+i); obj2.style.background = "orange"; for (var j=1 ; j&lt;6; j++)&#123; if(j!=i)&#123; var obj3 = document.getElementById("d"+j); obj3.style.background = "white"; &#125; &#125; &#125; function stop()&#123; window.clearInterval(time); &#125; function start()&#123; time = window.setInterval('change()',1000); &#125; function stopImg(n,m)&#123; i = n; var obj = document.getElementById('img'); obj.src = "images/beijing_" + i + ".jpg"; window.clearInterval(time); m.style.background="orange"; for (var j=1 ; j&lt;6; j++)&#123; if(j!=i)&#123; var obj3 = document.getElementById("d"+j); obj3.style.background = "white"; &#125; &#125; &#125; function startImg(m)&#123; time = window.setInterval('change()',1000); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;img src="images/beijing_1.jpg" width="400" id="img" onmousemove="stop()" onmouseout="start()" title="背景图1" alt="背景图1"&gt; &lt;ul&gt; &lt;li id="d1" onmousemove="stopImg(1,this)" onmouseout="startImg(this)"&gt;1&lt;/li&gt; &lt;li id="d2" onmousemove="stopImg(2,this)" onmouseout="startImg(this)"&gt;2&lt;/li&gt; &lt;li id="d3" onmousemove="stopImg(3,this)" onmouseout="startImg(this)"&gt;3&lt;/li&gt; &lt;li id="d4" onmousemove="stopImg(4,this)" onmouseout="startImg(this)"&gt;4&lt;/li&gt; &lt;li id="d5" onmousemove="stopImg(5,this)" onmouseout="startImg(this)"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 代码分析 声明全局变量：背景图变换的序号i,用于清楚定时器的time；第一步：初始化函数中加入一个交换背景图片的反复性定时器用于加载交换函数第二步：图片自动播放联动按钮变化：在交换函数中通过for循环改变i的值，再通过元素样式对象属性进行切换图片；通过第二个循环，与第一循环的i值关联，用于联动按钮的背景样式第三步：写一个stop函数当鼠标放置在img上清楚定时器，start函数鼠标离开时重新启动定时器(注意设置定时器名字)（dsq=window.setInterval(&quot;change()&quot;,1000);）重写一遍定时器第五步：按钮点击联动图片自动切换：通过使用函数值传递，进行判断切换stopImg函数(注意i=n来控制图片切换避免鼠标离开时乱启动图片)&lt;li id=&quot;d1&quot; onmousemove=&quot;stopImg(1,this)&quot; onmouseout=&quot;startImg(this)&quot;&gt;1&lt;/li&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js特效</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP弱类型安全问题总结]]></title>
    <url>%2F2015%2F20150815-1.html</url>
    <content type="text"><![CDATA[PHP特性就是弱类型，以及内置函数对于传入参数的松散处理本篇文章主要就是记录PHP的弱类型所带来的问题。 PHP弱类型简介在PHP中，可以进行一下的操作。123$param = 1;$param = array();$param = &quot;stringg&quot;; 弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。 类型转换问题类型转换是无法避免的问题。例如需要将GET或者是POST的参数转换为int类型，或者是两个变量不匹配的时候，PHP会自动地进行变量转换。但是PHP是一个弱类型的语言，导致在进行类型转换的时候会存在很多意想不到的问题。 比较操作符类型转换在$a==$b的比较中12$a=null;$b=flase ; //true$a=&apos;&apos;;$b=null; //true 这样的例子还有很多，这种比较都是相等。使用比较操作符的时候也存在类型转换的问题，如下：12340==&apos;0&apos; //true0 == &apos;abcdefg&apos; //true0 === &apos;abcdefg&apos; //false1 == &apos;1abcdef&apos; //true 当不同类型的变量进行比较的时候就会存在变量转换的问题，在转换之后就有可能会存在问题。 Hash比较除了以上的这种方式之外在进行hash比较的时候也会存在问题。如下：123&quot;0e132456789&quot;==&quot;0e7124511451155&quot; //true&quot;0e123456abc&quot;==&quot;0e1dddada&quot; //false&quot;0e1abc&quot;==&quot;0&quot; //true 在进行比较运算时，如果遇到了0e\d+这种字符串，就会将这种字符串解析为科学计数法。所以上面例子中2个数的值都是0因而就相等了。如果不满足0e\d+这种模式就不会相等。这个题目在攻防平台中的md5 collision就有考到。 十六进制转换还存在一种十六进制余字符串进行比较运算时的问题。例子如下：123&quot;0x1e240&quot;==&quot;123456&quot; //true&quot;0x1e240&quot;==123456 //true&quot;0x1e240&quot;==&quot;1e240&quot; //false 当其中的一个字符串是0x开头的时候，PHP会将此字符串解析成为十进制然后再进行比较，0×1240解析成为十进制就是123456，所以与int类型和string类型的123456比较都是相等。攻防平台中的起名字真难就是考察的这个特性。 类型转换常见的转换主要就是int转换为string，string转换为int。 int转string：$var = 5;方式1：$item = (string)$var; 方式2：$item = strval($var); string转int：intval()函数。 对于这个函数，可以先看2个例子。123var_dump(intval(&apos;2&apos;)) //2var_dump(intval(&apos;3abcd&apos;)) //3var_dump(intval(&apos;abcd&apos;)) //0 说明intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。即使出现无法转换的字符串，intval()不会报错而是返回0。intval()的这种特性在攻防平台中的MYSQL这道题目中就有考到。同时，程序员在编程的时候也不应该使用如下的这段代码：123if(intval($a)&gt;1000) &#123; mysql_query(&quot;select * from news where id=&quot;.$a)&#125; 这个时候$a的值有可能是1002 union….. 内置函数的参数的松散性内置函数的松散性说的是，调用函数时给函数传递函数无法接受的参数类型。解释起来有点拗口，还是直接通过实际的例子来说明问题，下面会重点介绍几个这种函数。1234567md5()$array1[] = array( &quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;,);$array2 = array(&quot;foo&quot;, &quot;bar&quot;, &quot;hello&quot;, &quot;world&quot;);var_dump(md5($array1)==var_dump($array2)); //true PHP手册中的md5()函数的描述是string md5 ( string $str [, bool $raw_output = false ] )，md5()中的需要是一个string类型的参数。但是当你传递一个array时，md5()不会报错，知识会无法正确地求出array的md5值，这样就会导致任意2个array的md5值都会相等。这个md5()的特性在攻防平台中的bypass again同样有考到。 strcmp() strcmp()函数在PHP官方手册中的描述是int strcmp ( string $str1 , string $str2 ),需要给strcmp()传递2个string类型的参数。如果str1小于str2,返回-1，相等返回0，否则返回1。strcmp函数比较字符串的本质是将两个变量转换为ascii，然后进行减法运算，然后根据运算结果来决定返回值。 如果传入给出strcmp()的参数是数字呢？12$array=[1,2,3];var_dump(strcmp($array,&apos;123&apos;)); //null,在某种意义上null也就是相当于false。 strcmp这种特性在攻防平台中的pass check有考到。 switch() 如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：12345678910$i =&quot;2abc&quot;;switch ($i) &#123;case 0:case 1:case 2: echo &quot;i is less than 3 but not negative&quot;; break;case 3: echo &quot;i is 3&quot;;&#125; 这个时候程序输出的是i is less than 3 but not negative，是由于switch()函数将$i进行了类型转换，转换结果为2。 in_array() 在PHP手册中，in_array()函数的解释是bool in_array ( mixed $needle , array $haystack [, bool $strict = FALSE ] ),如果strict参数没有提供，那么in_array就会使用松散比较来判断$needle是否在$haystack中。当strince的值为true时，in_array()会比较needls的类型和haystack中的类型是否相同。123$array=[0,1,2,&apos;3&apos;];var_dump(in_array(&apos;abc&apos;, $array)); //truevar_dump(in_array(&apos;1bc&apos;, $array)); //true 可以看到上面的情况返回的都是true,因为’abc’会转换为0，’1bc’转换为1。array_search()与in_array()也是一样的问题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP安全问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin：0 auto 不能居中]]></title>
    <url>%2F2015%2F20150812-1.html</url>
    <content type="text"><![CDATA[既然用了 position:absolute, margin 也就不再对元素的位置产生影响了。办法很多: 如果ul宽度是固定的话（已知数量的li以及图片长度），可以用 left: calc(100% - ul 宽度的一半)。 又或者，把 Position: absolute 等使元素沉底的 styles 放置到外一层的div当中。将 ul 设为 text-align: center，li 设为 display:inline-block 来居中图片元素。 作者：Eastenluis链接：http://www.zhihu.com/question/23861520/answer/25936737来源：知乎著作权归作者所有，转载请联系作者获得授权。 因为有position:absolute一种可以参考的方法是套两层，外面一层margin-left:50%，里面margin-left:-50%另一种是外面一层width:100%，里面再margin:0 auto;display:table 就算没有position:absolute，要是不明确设宽的话也需要display:table或者其它方法 作者：于航链接：http://www.zhihu.com/question/23861520/answer/25893095来源：知乎著作权归作者所有，转载请联系作者获得授权。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡，选择，插入，快速]]></title>
    <url>%2F2015%2F20150807-1.html</url>
    <content type="text"><![CDATA[冒泡，选择，插入，快速，四种常用的排序方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;冒泡排序法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php function bubbleSort($arr)&#123; //利用双重循环完成 //外层循环控制 比较的轮数，每轮会将一个最大的气泡（数）浮到水面 //如果数组的元素个数为N 则需要N-1轮完成 for ($i=0,$len = count($arr); $i &lt; $len-1; $i++) &#123; //内层循环控制 的比较的次数， ////第一轮需要比较 N-1次 //第二轮需要比较 N-2次 for ($j=0; $j &lt; $len-1-$i; $j++) &#123; if ($arr[$j]&gt;$arr[$j+1]) &#123; $temp = $arr[$j]; $arr[$j]=$arr[$j+1]; $arr[$j+1]=$temp; &#125; &#125; &#125; return $arr; &#125; function selectSort($arr)&#123; //实现思路 //双重循环完成，外层控制轮数，当前的最小值。 //内层 控制的比较次数 //$i 当前最小值的位置， 需要参与比较的元素 for ($i=0,$len=count($arr); $i &lt; $len-1; $i++) &#123; $p=$i; for ($j=$i+1; $j &lt; $len; $j++) &#123; if($arr[$j]&lt;$arr[$p])&#123; $p=$j; &#125; &#125; if ($p!=$i) &#123; $temp = $arr[$i]; $arr[$i]=$arr[$p]; $arr[$p]=$temp; &#125; &#125; return $arr; &#125; function insertSort($arr)&#123; //利用双重循环，外层控制要进行插入判断的数 //内层是已经排好的数与外层的数进行比较交换 for ($i=1,$len=count($arr); $i &lt; $len; $i++) &#123; $temp=$arr[$i]; for ($j=$i-1; $j &gt;= 0; $j--) &#123; if ($temp&lt;$arr[$j]) &#123; $arr[$j+1]=$arr[$j]; $arr[$j]=$temp; &#125;else&#123; break; &#125; &#125; &#125; return $arr; &#125;/***快速排序** @param array $arr 需要排序的数组** @return array 排序好的数组*/function quick_sort($arr) &#123; //先判断是否需要继续进行 $length = count($arr); if($length &lt;= 1) &#123; return $arr; &#125; //如果没有返回，说明数组内的元素个数 多余1个，需要排序 //选择一个标尺 //选择第一个元素 $base_num = $arr[0]; //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内 //初始化两个数组 $left_array = array();//小于标尺的 $right_array = array();//大于标尺的 for($i=1; $i&lt;$length; $i++) &#123; if($base_num &gt; $arr[$i]) &#123; //放入左边数组 $left_array[] = $arr[$i]; &#125; else &#123; //放入右边 $right_array[] = $arr[$i]; &#125; &#125; //再分别对 左边 和 右边的数组进行相同的排序处理方式 //递归调用这个函数,并记录结果 $left_array = quick_sort($left_array); $right_array = quick_sort($right_array); //合并左边 标尺 右边 return array_merge($left_array, array($base_num), $right_array);&#125; $myarr=array(23,45,64,21,5,75); print_r(bubbleSort($myarr)); echo "&lt;br/&gt;"; print_r(selectSort($myarr)); echo "&lt;br/&gt;"; print_r(insertSort($myarr)); echo "&lt;br/&gt;"; print_r(quick_sort($myarr)); ?&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得与失]]></title>
    <url>%2F2015%2F20150805-1.html</url>
    <content type="text"><![CDATA[说服自己最近一直在思考，放弃是会得到更多，还是失去的更少 其实，内心坚定的我已经将第一句扭曲了 不论结果如何，自己认定的，自己去承担 认定不是盲目的跟随，是分析过现有状态的优势 亦分析过新决策的弊端，究竟优有多优，弊有多弊 心里清晰，，， 不装B了，记录这段话只是为了说服自己， 很感谢，今日领导的挽留，即成为我将来没事儿吹牛炫耀的话题了 喝碗鸡汤 人生一世，草木一秋， 努力去做一个不计较得失的人吧！淡然于心，从容于表，优雅自在地生活。 咀嚼平淡如水的日子，领略四季起伏的风景，走着属于自己的人生之路 。学会在得失中找回自我，舍得下，放得开，便自然是春风得意，月明清高。 简单总结一下策划工作体会个人感悟，职场鸡汤，没有逻辑亦没有案例，信则有，不信则无 最牛策划人小组竞选通过本来不爱吹牛的我，开头这里还是要提一下；天性对于做事的方法就有思想，加之执行力强（效率有待提升），在做了充足的准备；充分洞悉老板的内心，因而通过了老板的法眼，成功从竞选小组脱颖而出。 自以为老板的内心如下：第一：喜欢以团队为核心的员工，所以你不要试图在老板面前争风头，即使内容全是你做的，亦要将成果分享队友，因为真正谁承担了多少，老板心里清楚第二：有想法就去行动，因为空想者太多了，竞技项目领导打分的唯一标准是可实现度，及项目所做的深度第三：最好做事能有逻辑，能有几个点是独特的，能打动到老板的内心，这就要洞悉他真正的需求，及你与他人的差异化的点第四：做好充分的准备，再不擅长演讲的人，就像我，有自己的想法后，将讲稿改几十遍背几百遍，能将思想讲述清楚，剩下的就是听天由命了第五：补充一点，如果可以事先准备几个问题的答案，或者能故意预留几个点准备好答案，等待提问。那样可能效果更佳，因为既然你这样做了，起码自己认定是正确，这里不是玩心计，是通过方法去说服别人，认定你的想法 策划工作-概念、设计、优化、量产没有收集资料，想到什么就先记录什么了，以后有补充，另行记录 定位 为什么要做这个产品，是为了通过产品本身盈利，还是通过产品周边盈利，亦或者做高端占位，提升品牌形象？ 纯创新性的产品也没有做过，常规性的产品一般都是看行业动态，在结合品牌与产品匹配，分析竞争对手：价格段分析，品牌分析，品项属性配置分析，这些分析都是后续进一步工作的基数，不得结果； 目标受众人群：按场景使用需求划分，比按财富值划分重合度更低，可有效避免重复数据对定位人群的结果影响 概念 初次概念：概念只做0-1，不做1-N，因为1-N基本不用看这里的内容，那是有了0-1的过程后的扩展 趋势分析：好产品为什么好，价格原因、品牌原因、功能配置？不好的产品又为什么不好，一定要清楚不好的产品，只看好产品，会导致，决策的武断做了类似于本来就不好的产品，那样结果可想而知趋势分析，应该是用户想要的，而不是需要的，其实这个道理也很简单，需要的可以买亦可以不买，不买通过其他方案解决需求；而想要的，是用感性战胜了理智，所以可能你在某个点打动了他，他会不经过大脑而买了这个产品，似乎有点阴险，但客户买了，就是因为其喜欢，他甚至不会去使用，将其作为收藏品，但就是想要，所以两全其美 使用地图：原则，不要考虑技术实现，不要考虑制造成本，一定要发散思维，且需要有想法的小团体去完成这个事；从使用场景的第一步入手，你发现了生活中的一个痛点，你想到通过一个东西去解决这个问题，可能想到自己创造什么样的解决方案，当然这个基本不用考虑，因为你做个思考是要通过一个产品，一个东西去解决这个痛点；所以你需要买一个东西，你会想到从什么样的渠道购买，这个可能就是未来的重点销售渠道；你会想到我买到这个产品，产品到我手里是什么样子的，这里可能涉及配送，搬用的方式；你会想到我开封后希望有个什么样的面貌，这里涉及到产品的包装形态；你会想到第一次安装使用，你会想到产品使用的一切的一切，尽量全面，记录这些想法，这才能深入挖掘到产品使用场景的痛点，产品的体验，甚至于产品的售后，当然这里是产品的概念定义，重点是产品的概念，千万不要由于全面，反而没有重点，跑偏了。 技术突破：依托技术储备，积木式的拼接，可能这将带来颠覆性的体验，在这里不是重点，梦想太大了，需要承载的更多，看这里可能会跑偏，回归正题，技术突破，是用来补充产品概念的 补充一个九宫格： 横轴：过去、现在、将来， 纵轴：父类、本体、子类；这里面有点深奥，有机会再详细研究下 研究计划 分析：成本，性价比 QFD工具观察：痛点，概念 访谈：一般都是田野工作不建议，访谈四段式：情景，过去，现在，将来；这里面的一个核心思想就是验证问题的错误，只有验证不了问题的错误，才能说明问题的正确，如果本来你是认为，你的问题正确存在，带有这样的倾向性，基本不会发现准确真实的用户需求。借按钮增加与否的调研，现在回想起来，就不应该给用户看产品，再去介绍产品的定义，可以和他们聊未来，似乎可以这样做；录音，转意；拍视频、照片；样本展示； 目标用户：发烧友：提出问题甚至有解决方案，亦能提供发展趋势的建议重度用户：提痛点需求极端用户：特殊产品的需求早期用户： 以上，鉴定概念真伪，筛选概念；以敏锐的眼光与定位，抓取核心概念 确定最佳概念扩大访谈，（定量阶段）调研核心思想：定性调研找问题，定量调研找共性。不管是哪个过程，千万别引到用户去选你想要的答案，尽可能开放性，另外一定要做好充足的准备，调研的核心问题，问题的具体描述，调研过程的录音、拍照取证。转意最好能在调研结束的当日内完成。 （行业趋势、市场容量、品牌占比、TOP品项） 累了，困了，没思绪了先睡了date: 2015-08-06 01:05:20 策划工作-项目管理全面思考的思想本人最不喜欢，也最不擅长的，同时也是未来可提升的最大一块；即使他是一个很努力的工程师，也不可能和你的思想一致，所以沟通协调中，难免出现分歧，矛盾可能不知不觉中产生了。这是沟通的艺术，需要加紧强化了；粗浅的认为，讲话的时候尽量不要有盛气凌人的态度，好好说话（可以听听马东的好好说话了）。不扯了，进入正题 先从产品变更开始吧，收到产品变更需求，站在产品策划的角度，可不是单纯的将任务需求下发出去。还是之前那句话，多部门协调工作，必然出现扯后腿的人。所以你要尽可能的将问题考虑全面。不管有没有启动会，你都要考虑以下问题： 项目里程碑：要考虑设计师、研发工程师的项目时间安排，确认项目里程碑的合理性切换时间周期：要考虑变更过程涉及到老物料的库存及供应商库存的切换，去除公有物料的专用物料可能是老产品自然切换的最多生产量（当然成本太少的可综合评估报废处理），依据常规消耗量，规定切换的时间周期，再定期去检讨；关键人员安排：变更过程一定要和采购、生管、订单、市场、沟通好；市场认定你的变更是第一步，当然一般情况下，这些需要本身就是来源于市场，然后市场要根据新规格的变更产品做出来至少一个季度的需求量，到订单中心；这样由订单中心到生管的客户需求量就是正确的，生管排计划时，会根据切换的产品将新产品排进去，物控到采购的物料也是最新的。规范产前流程：产品规格调整会涉及品质入库检核，所以变更项目需有试产安排，当然这个本来应该是必须的，但本企业还没有固化下来，所以只能去推动了，试产做相关的品质验证，通过后要交由领导对产品进行封样确认，避免入库前的忙乱 没什么技术含量，就是多动脑，勤思考，所以不浪费时间记这些东东了date: 2015-08-06 10:15:53 策划工作-产品管理改善产品，功能迭代]]></content>
      <tags>
        <tag>产品经理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime]]></title>
    <url>%2F2015%2F20150801-1.html</url>
    <content type="text"><![CDATA[alt+command+2 左右分2屏 ctrl+shift+k 快速删除整行 Ctrl+command+⬆️ 上下行交换 ctrl+K 从光标位置，删除代码至行尾 command + P @ js command + D 多次输入 command + K alt + F3 多选 command + enter command + shift + enter command + H command + A command + shift + L shift + 鼠标右键 + 向下移动 ul&gt;.item$*10 h2{内容} command + shift + V 带缩进粘贴 资源收集]]></content>
      <tags>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github 常用命令]]></title>
    <url>%2F2015%2F20150731-2.html</url>
    <content type="text"><![CDATA[使用git在本地创建一个项目的过程:q 退出编辑页面 创建项目123456789101112$ makdir test //创建一个项目test$ cd test/ //打开这个项目$ git clone https://github.com/uiste/test.git //检出项目到本地$ ls //即list显示当前目录中的文件名字$ vi README.md //打开文件，进入编辑状态;编辑完成后 :wq 保存退出$ git init //初始化$ touch README //创建README文件$ git status //查看工作区状态，是否有为跟踪文件$ git add README //更新README文件$ git commit -m ‘记录修改内容’ //提交更新，并注释信息“first commit”$ git remote add Hexo https://github.com/uiste/Hexo.git //连接远程github项目$ git push -u Hexo master //将本地项目更新到github项目上去 回到过去123$ git log //查看提交日志，找到对应记录的修改文件，复制commit 指针$ git reflog //查询具体的版本号，最前面即为commit ID号$ git reset --hard 0ce6fd2 //恢复到以前版本 建立里程碑 在github上打开项目首页release菜单-&gt;Draft a new release版本号 @ Target:master -&gt;Write 记录项目信息Publish release 发布里程碑 分支开发 在github客户端操作创建新分支：项目文件名 -&gt; Manage -&gt; 右侧Unpbulish -&gt; Branch 建立分支名为BUG在新分支中：修改项目文件内容 -&gt; Commit to BUG 提交修改内容到BUG分支合并分支内容：项目文件名 -&gt; Manage -&gt; BUG 移动到左侧Merge ，master移动到右侧Merge -&gt; 点击Merge 以下是互联网摘取信息 最基本的命令：拷贝并跟踪远程的master分支。跟踪的好处是以后可以直接通过pull和push命令来提交或者获取远程最新的代码，而不需要指定远程分支名字。 12345git clone git submodule initgit submodule update 显示信息类命令123456789101112131415161718192021git ls-files -u 显示冲突的文件，-s是显示标记为冲突已解决的文件git diff 对比工作区和stage文件的差异 git diff --cached 对比stage和branch之间的差异git branch 列出当前repository下的所有branch git branch --a 列出local 和remote下的所有branchgit ls-files --stage 检查保存在stage的文件git log 显示到HEAD所指向的commit为止的所有commit记录 。使用reset HEAD~n 命令使HEAD指针向前移动，会导致HEAD之后的commit记录不会被显示。git log -g则会查询reflog去查看最近做了哪些动作，这样可以配合git branch 恢复之前因为移动HEAD指针所丢弃的commit对象。如果reflog丢失则可以通过git fsck --full来查看没被引用的commit对象。 git log -p -2 对比最新两次的commit对象 log -1 HEADgit log --pretty=onelinegit log --stat 1a410e 查看sha1为1a410e的commit对象的记录git blame -L 12,22 sth.cs 如果你发现自己代码中 的一个方法存在缺陷,你可以用git blame来标注文件,查看那个方法的每一行分别是由谁 在哪一天修改的。下面这个例子使用了-L选项来限制输出范围在第12至22行 创建类命令12345git brach branchName 创建名为branchName的branch git checkout branchName 切换到branchName的branch git checkout -b 创建并切换，也就是上面两个命令的合并git brach branchName ef71 从commit ef71创建名为branchName的branch 撤销类命令123456789101112131415161718192021如果是单个文件 1.use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage 如果已经用add 命令把文件加入stage了，就先需要从stage中撤销然后再从工作区撤销 2.use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directorygit checkout a.txt 撤销a.txt的变动（工作区上的文件） 如果是多个文件 git chenkout .如果已经commit 了，则需要 git commit --amend 来修改，这个只能修改最近上一次的,也就是用一个新的提交来覆盖上一次的提交。因此如果push以后再做这个动作就会有危险$ git reset --hard HEAD 放弃工作区和index的改动,HEAD指针仍然指向当前的commit.（参照第一幅图）这条命令同时还可以用来撤销还没commit的merge,其实原理就是放弃index和工作区的改动，因为没commit的改动只存在于index和工作区中。$ git reset --hard HEAD^ 用来撤销已经commit的内容(等价于 git reset --hard HEAD~1) 。原理就是放弃工作区和index的改动，同时HEAD指针指向前一个commit对象。git revert 也是撤销命令，区别在于reset是指向原地或者向前移动指针，git revert是创建一个commit来覆盖当前的commit,指针向后移动 提交类命令12345git add 跟踪新文件或者已有文件的改动，或者用来解决冲突git commit 把文件从stage提交到branchgit commit -a 把修改的文件先提交到stage,然后再从stash提交到branch 删除类命令12345git rm --cached readme.txt 只从stage中删除，保留物理文件git rm readme.txt 不但从stage中删除，同时删除物理文件git mv a.txt b.txt 把a.txt改名为b.txt Merge类命令12345678910在冲突状态下，需要解决冲突的文件会从index打回到工作区。1.用工具或者手工解决冲突 2.git add 命令来表明冲突已经解决。 3.再次commit 已解决冲突的文件。$ git reset --hard ORIG_HEAD 用来撤销已经commit 的merge. $ git reset --hard HEAD 用来撤销还没commit 的merge,其实原理就是放弃index和工作区的改动。git reset --merge ORIG_HEAD，注意其中的--hard 换成了 --merge，这样就可以避免在回滚时清除working tree。]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中hover连续触发动画的bug]]></title>
    <url>%2F2015%2F20150731-1.html</url>
    <content type="text"><![CDATA[在用jQuery实现下拉菜单特效时，发现鼠标连续触碰对象会导致hover事件反复发生，如：12345jQuery(&quot;#nav li&quot;).hover(function()&#123; $(this).find(&quot;ul:first&quot;).slideDown(&quot;slow&quot;);&#125;,function()&#123; $(this).find(&quot;ul:first&quot;).slideUp(&quot;fast&quot;);&#125;); 度娘找到相关的解决方法，增加filter过滤到正在执行的动画模块即可，修正后的代码如下：12345jQuery(&quot;#nav li&quot;).hover(function()&#123; $(this).find(&quot;ul:first&quot;).filter(&apos;:not(:animated)&apos;).slideDown(&quot;slow&quot;);&#125;,function()&#123; $(this).find(&quot;ul:first&quot;).slideUp(&quot;fast&quot;);&#125;);]]></content>
      <categories>
        <category>前端</category>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS默认样式表]]></title>
    <url>%2F2015%2F20150730-1.html</url>
    <content type="text"><![CDATA[网页设计，让人最头疼的莫过于让页面兼容各大浏览器，准确些是兼容它们“默认”的CSS样式表。 第一部分第一种方式1* &#123;margin:0px; padding:0px;&#125; 这行代码虽然简单，但却让网页解析太慢。于是出现了几种CSS重置方法： 第二种方式 123456789101112body, html, div, blockquote, img, label, p, h1, h2, h3, h4, h5, h6, pre, ul, ol,li, dl, dt, dd, form, a, fieldset, input, th, td&#123;margin: 0; padding: 0; border: 0; outline: none;&#125;body&#123;line-height: 1;font-size: 88% /* Decide for yourself if you want to include this. */;&#125;h1, h2, h3, h4, h5, h6&#123;font-size: 100%;padding: .6em 0;margin: 0 15px;&#125;ul, ol&#123;list-style: none;&#125;a&#123;color: black;text-decoration: none;&#125;a:hover&#123;text-decoration: underline;&#125;.floatLeft&#123;float: left;padding: .5em .5em .5em 0;&#125;.floatRight&#123;float: right;padding: .5em 0 .5em .5em;&#125;` NETTUTS上的 Jeffrey Way写了篇文章Weekend Quick Tip: Create Your Own Simple Reset.css File释出自己用来重置CSS样式表的方法,这个方法适用于大多数的网页设计。 第三种方式1234567891011121314151617181920212223242526272829303132html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, font, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-size: 100%; vertical-align: baseline; background: transparent;&#125;body &#123;line-height: 1;&#125;ol, ul &#123;list-style: none;&#125;blockquote, q &#123;quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;content: &apos;&apos;;content: none;&#125;/* remember to define focus styles! */:focus &#123;outline: 0;&#125;/* remember to highlight inserts somehow! */ins &#123;text-decoration: none;&#125;del &#123; text-decoration: line-through;&#125;/* tables still need &apos;cellspacing=&quot;0&quot;&apos; in the markup */table &#123;border-collapse: collapse;border-spacing: 0;&#125; 这个重置的太多 第四种方式12345678910111213body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td &#123; margin:0; padding:0;&#125;table &#123;border-collapse:collapse;border-spacing:0;&#125;fieldset,img &#123; border:0;&#125;address,caption,cite,code,dfn,em,strong,th,var &#123;font-style:normal;font-weight:normal;&#125;ol,ul &#123;list-style:none;&#125;caption,th &#123;text-align:left;&#125;h1,h2,h3,h4,h5,h6 &#123;font-size:100%;font-weight:normal;&#125;q:before,q:after &#123;content:&apos;&apos;;&#125;abbr,acronym &#123; border:0;&#125; 第二部分CSS通用样式1234567891011body,ul,ol,dl,dd,h1,h2,h3,h4,h5,h6,p,input,select,textarea,form&#123;margin: 0; padding: 0;&#125;body&#123;font:14px/1.5 &quot;宋体&quot;;&#125;img&#123;border:none;&#125;ul,ol&#123;list-style:none;&#125;input,select,textarea&#123;outline:none;border:none;background:none;&#125;textarea&#123;resize:none;&#125;a&#123;text-decoration:none;&#125;/*清浮动*/.clearfix:after&#123;content:&quot;&quot;;*display:block;*clear:both;&#125;.clearfix&#123;zoom:1;&#125; 选择12::selection &#123;background-color:#669900; color:#ffffff; text-shadow:none;&#125;::-moz-selection &#123;background-color:#669900; color:#ffffff;text-shadow:none;&#125; 去掉a的下划线12a &#123;blr:expression(this.onFocus=this.blur())&#125; /*if IE*/a &#123;outline:none;&#125;/*if 火狐等现代浏览器浏览器*/ 省略号1white-space:nowrap;overflow:hidden;text-overflow:ellipsis; 英文自动换行1word-break: break-all; 强制不换行12345white-space:nowrap;contenteditable=&quot;true&quot;` clearfix完整版12345.clearfix:before,.clearfix:after &#123; content:&quot;&quot;; display:table;&#125;.clearfix:after&#123;clear:both;&#125;.clearfix&#123;*zoom:1;&#125;--------------------expression(this.onFocus=this.blur())]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo SEO优化]]></title>
    <url>%2F2015%2F20150725-1.html</url>
    <content type="text"><![CDATA[当我们搭建一个网站之后，如果没有做一些相关的搜索引擎优化SEO，那么我们的网站是很难获取来自搜索引擎的流量的，用户很难在搜索引擎上搜索到我们网站的内容，所以接下来我们要为Hexo网站做一些简单的搜索优化。 将网站链接提交到百度百度搜索引擎提交入口有三种验证方式，我选择Html标签验证，在themes\next\layout_partials\head.swing中添加验证代码： &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;s8Pe1TBqyy&quot; /&gt; 然后点击完成验证，通过即可。同理将站点链接也提交到Google和搜狗，此处不表。 给站点添加sitemapHexo安装sitemap npm install hexo-generator-sitemap --save #sitemap.xml适合提交给谷歌搜素引擎 npm install hexo-generator-baidu-sitemap --save #baidusitemap.xml适合提交百度搜索引擎 2、 在站点配置文件_config.yml中添加以下代码12345# 自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 3、 修改站点配置文件_config.yml123# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://yoursite 4、 Hexo编译12hexo cleanhexo g 会/public目录下生成sitemap.xml和baidusitemap.xml，这就是你的站点地图。5、 提交sitemap到站长平台百度站长平台sitemap提交是邀请制的，并没有对所有站长开放，只有网站到一定等级百度才会在你后台开放提交sitemap的入口。 添加蜘蛛协议robots.txt1、 新建robots.txt文件，添加以下文件内容，把robots.txt放在hexo站点的source文件下。123456789101112131415# hexo robots.txtUser-agent: *Allow: /Allow: /categories/Allow: /tags/Allow: /archives/Allow: /about/Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: http://www.zaoanx.com/sitemap.xmlSitemap: http://www.zaoanx.com/baidusitemap.xml 2、 在百度站长平台监测并更新Robots提示检测到您更新了Robots文件即成功。 给出站链接添加 “nofollow” 标签nofollow标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用nofollow标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有nofollow属性的任何出站链接，以减少垃圾链接的分散网站权重。以hexo的NexT主题为例，需要修改两处1、 找到footer.swig，路径在your-hexo-site\themes\next\layout_partials，将下面代码 {{ __('footer.powered', 'Hexo') }} 改成 {{ __('footer.powered', 'Hexo') }} 将下面代码 &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt; 改成 &lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt; 2、 修改sidebar.swig文件，路径在your-hexo-site\themes\next\layout_macro，将下面代码 &lt;a href=&quot;{{ link }}&quot; target=&quot;_blank&quot;&gt;{{ name }}&lt;/a&gt; 改成 &lt;a href=&quot;{{ link }}&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;{{ name }}&lt;/a&gt; 将下面代码 &lt;a href=&quot;http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt; 改成 &lt;a href=&quot;http://creativecommons.org/licenses/{{ theme.creative_commons }}/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt; 可以使用chinaz站长工具进行各项检测。 keywords 和 description在\scaffolds\post.md中添加如下代码，用于生成的文章中添加关键字和描述。12keywords: description: 在\themes\next\layout_partials\head.swig有如下代码，用于生成文章的keywords。暂时还没找到生成description的位置。1234567&#123;% if page.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;&#123;% elif page.tags and page.tags.length %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;&#123;% elif theme.keywords %&#125; &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;&#123;% endif %&#125; 然后在\themes\next\layout_macro\post.swig中找到这个位置： {% if post.description %} 将以下代码去掉：1234567&#123;% if post.description %&#125; &#123;&#123; post.description &#125;&#125; &lt;div class=&quot;post-more-link text-center&quot;&gt; &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt; &#123;&#123; __(&apos;post.read_more&apos;) &#125;&#125; &amp;raquo; &lt;/a&gt; &lt;/div&gt; 否则首页的文章摘要就会变成文章的description。 首页title的优化更改index.swig文件，文件路径是your-hexo-site\themes\next\layout，将下面代码 {% block title %} {{ config.title }} {% endblock %} 改成 {% block title %} {{ config.title }} - {{ theme.description }} {% endblock %} 这时候你的首页标题会更符合网站名称 - 网站描述这习惯。 修改文章链接HEXO默认的文章链接形式为domain/year/month/day/postname，默认就是一个四级url，并且可能造成url过长，对搜索引擎是十分不友好的，我们可以改成 domain/postname 的形式。编辑站点_config.yml文件，修改其中的permalink字段改为permalink: :title.html即可.]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>seo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo分类和标签无法显示]]></title>
    <url>%2F2015%2F20150724-3.html</url>
    <content type="text"><![CDATA[hexo 下的分类和标签无法显示，解决方法 步骤一新建一个页面，命名为 tags 。命令如下：1$ hexo new page &quot;tags&quot; 步骤二编辑刚刚新建的页面，将页面的类型设置为tags，主题将自动为这个页面显示标签云。页面内容如下：1234title: Tagclouddate: 2014-12-22 12:39:04type: &quot;tags&quot;--- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：12345title: Tagclouddate: 2015-7-24 22:21:13type: &quot;tags&quot;comment: false--- 步骤三在菜单中添加链接。编辑 主题配置文件 ，添加 tags 到 menu 中，如下:1234567menu: home: / categories: /categories about: /about archives: /archives tags: /tags #commonweal: /404.html 分类的解决方法同标签]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库基本操作]]></title>
    <url>%2F2015%2F20150724-2.html</url>
    <content type="text"><![CDATA[数据库操作连接数据库：1/Applications/XAMPP/xamppfiles/bin/mysql -uroot -p123456 创建数据库12mysql&gt; create database uiste charset=utf8;Query OK, 1 row affected (0.01 sec) 选择数据库 12mysql&gt; use uiste;Database changed 创建数据表12345678mysql&gt; create table uiste_stu( -&gt; id int not null auto_increment primary key, -&gt; name char(10) not null, -&gt; sex char(1) not null default &apos;男&apos;, -&gt; age tinyint not null, -&gt; score decimal(3,1) -&gt; );Query OK, 0 rows affected (0.02 sec) 查看所有表：1234567mysql&gt; show tables;+-----------------+| Tables_in_uiste |+-----------------+| uiste_stu |+-----------------+1 row in set (0.00 sec) 显示创建表的SQL语句语法：show create table 表名 [\G];123456789101112131415mysql&gt; show create table uiste_stu \G;*************************** 1. row *************************** Table: uiste_stuCreate Table: CREATE TABLE `uiste_stu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` char(10) NOT NULL, `sex` char(1) NOT NULL DEFAULT &apos;男&apos;, `age` tinyint(4) NOT NULL, `score` decimal(3,1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)ERROR: No query specified 删除表语法：drop table 表1,表2,表3;12345mysql&gt; drop tabel stu;Query OK, 0 rows affected (0.01 sec)mysql&gt; show tables;Empty set (0.00 sec) 数据表操作显示数据表结构1234567891011mysql&gt; describe uiste_stu;+-------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || name | char(10) | NO | | NULL | || sex | char(1) | NO | | 男 | || age | tinyint(4) | NO | | NULL | || score | decimal(3,1) | YES | | NULL | |+-------+--------------+------+-----+---------+----------------+5 rows in set (0.01 sec) 插入数据语法：insert into 表名 (字段1,字段2) values (值1,值2);12mysql&gt; insert into uiste_stu (id,name,sex,age,score) values(2,&apos;杜敏&apos;,&apos; 女&apos;,22,59.9);Query OK, 1 row affected (0.01 sec) *插入字段可以和数据库中的字符顺序不一致，但是值需要和字段的顺序一致；1insert into uiste_stu (name,id,sex,age,score) values(&apos;钟程程&apos;,3,&apos;女&apos;,23,79.9); *插入字段是可以省略的，插入的值和数据表中的字段顺序和个数是一致的；1insert into uiste_stu values(4,&apos;赵哥&apos;,&apos;男&apos;,45,19.9); *自动增长的插入1insert into uiste_stu values(null,&apos;圆哥&apos;,&apos;女&apos;,18,89.9); *默认值的插入（default不带分号）1insert into uiste_stu values(6,&apos;张宝&apos;,default,28,9.9); 修改数据语法：update 表名 set 字段1=值1,字段2=值2 where 条件;*将赵哥的性别改为女;123mysql&gt; update uiste_stu set sex=&apos;女&apos; where name=&apos;赵哥&apos;;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 *若不加限定条件，将表中所有字段进行更改； 删除数据语法：delete from 表名 [where 条件];*删除id为6的信息1mysql&gt; delete from uiste_stu where id=6; 查询数据语法：select 列名 from 表名 [where 条件] [order by 字段 asc|desc] [limit 起始位置,获取条数];默认升序：asc 降序：desclimit 限制：限制取几条数据*查询所有学生的姓名和性别1mysql&gt; select name,sex from uiste_stu; *查询所有学生的所有字段12mysql&gt; select id,name,sex,age,score from uiste_stu;mysql&gt; select * from uiste_stu; *查询所有男生的信息1mysql&gt; select * from uiste_stu where sex=&apos;男&apos;; *查询所有分数大于60分的女生1mysql&gt; select * from uiste_stu where sex=&apos;女&apos; and score&gt;=60; *查询将所有分数大于60分的学生的信息，按分数从高到低排序1mysql&gt; select * from uiste_stu where score&gt;=60 order by score desc; *查询数据表中的前三条数据1mysql&gt; select * from uiste_stu limit 3; *查询第二条开始往后的三条数据(第一条是0)1mysql&gt; select * from uiste_stu limit 1,3; *查询分数前三名的学生信息1mysql&gt; select * from uiste_stu order by score desc limit 3; *最后查询所有的数据123456789101112mysql&gt; select * from uiste_stu;+----+-----------+-----+-----+-------+| id | name | sex | age | score |+----+-----------+-----+-----+-------+| 1 | 小兰 | 男 | 25 | 98.7 || 2 | 杜敏 | 女 | 22 | 59.9 || 3 | 钟程程 | 女 | 23 | 79.9 || 4 | 赵哥 | 女 | 45 | 19.9 || 5 | 圆哥 | 女 | 18 | 89.9 || 6 | 张宝 | 男 | 28 | 9.9 |+----+-----------+-----+-----+-------+6 rows in set (0.00 sec) 聚合函数· sum():求和1mysql&gt; select sum(score) from uiste_stu; · avg():求平均值1mysql&gt; select avg(score) from uiste_stu; · max():求最大值1mysql&gt; select max(score) from uiste_stu; · min():求最小值(不算null)1mysql&gt; select min(score) from uiste_stu; · count():求记录数1mysql&gt; select count(*) from uiste_stu; 比较运算符= 等于和赋值&lt;&gt; 不等于· 逻辑运算符and 与or 或not 非 数据库常见问题创建的数据库已存在1ERROR 1007 (HY000): Can&apos;t create database &apos;uiste&apos;; database exists 创建的数据库是一个关键字，解决在名字上加上反引号1create database `create`; 反引号可以创建更为复杂的字符和汉字 delete 和 drop 删除表名的区别delete删除表的内容，表的结构还保留，drop 删除整个表创建数据库或者数据表必要时进行的判断1create database if not exists uiste 一张表只能有一个主键，但是主键可以由多个字段组成，如：123456CREATE TABLE `products_description` ( `products_id` int(11) NOT NULL, `language_id` int(11) NOT NULL default &apos;1&apos;, `products_name` varchar(64) NOT NULL default &apos;&apos;, PRIMARY KEY (`products_id`,`language_id`)) ENGINE=InnoDB DEFAULT CHARSET=latin1;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL ERROR 1044 (42000)]]></title>
    <url>%2F2015%2F20150724-1.html</url>
    <content type="text"><![CDATA[问题描述： 在MySQL控制台下创建数据库出现以下信息：mysql&gt; CREATE DATABASE uiste;ERROR 1044 (42000): Access denied for user ‘‘@’localhost’ to database ‘uiste’ 解决方法：执行以下命令进入控制台： 123456mysql --user=root -p输入root用户的密码即可进入mysql控制台：创建数据库：create database uiste;显示所有数据库：show databases;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Brew搭建PHP(LNMP/LAMP)开发环境]]></title>
    <url>%2F2015%2F20150723-1.html</url>
    <content type="text"><![CDATA[Mac下搭建lamp开发环境很容易，有xampp和mamp现成的集成环境。但是集成环境对于经常需要自定义一些配置的开发者来说会非常麻烦，而且Mac本身自带apache和php，在brew的帮助下非常容易手动搭建，可控性很高。 Brewbrew对于mac，就像apt-get对于ubuntu，安装软件的好帮手，不能方便更多… brew的安装方式如下： ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go/install)&quot;brew常用选项1234brew install xxxbrew uninstall xxxbrew list brew update xxx Apache || NginxApacheApache的话使用mac自带的基本就够了，我的系统是10.9，可以使用以下命令控制Apache123sudo apachectl startsudo apachectl restartsudo apachectl stop 唯一要改的是主目录，mac默认在home下有个sites（站点）目录，访问路径是 http://localhost/~user_name这样很不适合做开发用，修改/etc/apache2/httpd.conf内容1234567DocumentRoot &quot;/Users/username/Sites&quot;&lt;Directory /&gt; Options Indexes MultiViews AllowOverride All Order allow,deny Allow from all&lt;/Directory&gt; 这样sites目录就是网站根目录了，代码都往这个下头丢 Nginx要使用Nginx也比较方便，首先安装 brew install nginx启动关闭Nginx的命令如下（如果想要监听80端口，必须以管理员身份运行） #打开 nginxsudo nginx #重新加载配置|重启|停止|退出 nginxnginx -s reload|reopen|stop|quit #测试配置是否有语法错误nginx -t配置Nginx cd /usr/local/etc/nginx/mkdir conf.d修改Nginx配置文件 vim nginx.conf主要修改位置是最后的include12345678910111213141516171819202122232425worker_processes 1; error_log /usr/local/var/log/nginx/error.log warn;pid /usr/local/var/run/nginx.pid;events &#123; worker_connections 256;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /usr/local/var/log/nginx/access.log main; port_in_redirect off; sendfile on; keepalive_timeout 65; include /usr/local/etc/nginx/conf.d/*.conf;&#125; 修改自定义文件 vim ./conf.d/default.conf增加一个监听端口12345678910111213141516171819server &#123; listen 80; server_name localhost; root /Users/username/Sites/; # 该项要修改为你准备存放相关网页的路径 location / &#123; index index.php; autoindex on; &#125; #proxy the php scripts to php-fpm location ~ \.php$ &#123; include /usr/local/etc/nginx/fastcgi.conf; fastcgi_intercept_errors on; fastcgi_pass 127.0.0.1:9000; &#125; &#125; 这个时候还不能访问php站点，因为还没有开启php-fpm。 虽然mac 10.9自带了php-fpm，但是由于我们使用了最新的PHP，PHP中自带php-fpm，所以使用PHP中的php-fpm可以保证版本的一致。 这里的命令在安装完下一步的php后再执行12sudo nginxsudo php-fpm -D PHPPHP在mac下默认安装了，但是不好控制版本，利用brew可以再mac下安装最新版本，甚至是多个版本，我装了php5.512345brew updatebrew tap homebrew/dupesbrew tap josegonzalez/homebrew-php# brew install php55 --with-fpm #Nginxbrew install php55 #Apache 然后修改php的cli路径和apache使用的php模块。在.bashrc或.zshrc里头加以下内容 #export PATH=&quot;$(brew --prefix josegonzalez/php/php55)/bin:$PATH&quot;export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot;就用刚刚安装的php代替了系统默认cli的php版本。然后在/etc/apache2/httpd.conf下增加 LoadModule php5_module /usr/local/Cellar/php55/5.5.8/libexec/apache2/libphp5.so这样就对apache使用的php版本也进行了修改。 后面会用到mongo和mysql，所以可以直接利用下面命令安装php模块，其他模块也类似12brew install php55-mysqlbrew install php55-mongo MySQLmac不自带mysql，这里需要重新安装，方法依然很简单1234brew install mysqlunset TMPDIRmysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew --prefix mysql)&quot; --datadir=/usr/local/var/mysql --tmpdir=/tmpsudo chown -R your_user /usr/local/var/mysql/ 第一句是安装，后面的是确保正常使用。然后是启动命令 mysql.server start最好给mysql设个密码，方法如下 mysqladmin -u root password &#39;xxx&#39;如果想修改mysql的配置，在/usr/local/etc下建立一个my.cnf，例如增加log [mysqld]general-loggeneral_log_file = /usr/local/var/log/mysqld.log MongoDBMongoDB可以说是最简单的一个，直接执行 brew install mongodb启动方法 mongod --fork PHPMyAdminphpmyadmin几乎是管理mysql最容易的web应用了吧，每次我都顺道装上。 1.去官网下载最新的版本2.解压到~/Sites/phpmyadmin下3.在phpmyadmin目录下创建一个可写的config目录4.打开http://localhost/phpmyadmin/setup，安装一个服务，最后保存（这里只需要输入帐号密码就够了）5.将config下生成的config.inc.php移到phpmyadmin根目录下6.删除config 这样就装好了，虽然可能有点小复杂，但是来一次就习惯了。 这里很可能会遇到2002错误，就是找不到mysql.sock的问题，用下面方法解决 sudo mkdir /var/mysqlsudo ln -s /tmp/mysql.sock /var/mysql/mysql.sock RockMongoRockMongo是MongoDB很好用的一个web应用，安装也很容易 1.去官网下载最新版本2.解压到~/Sites/rockmongo下3.运行http://localhost/rockmongo即可 完成 这样就在mac下配置好一个php开发环境了，enjoy it!]]></content>
  </entry>
  <entry>
    <title><![CDATA[消消乐小游戏]]></title>
    <url>%2F2015%2F20150720-2.html</url>
    <content type="text"><![CDATA[消消乐小游戏 使用HTML+CSS+JavaScript编写的简易消消乐小游戏！随着时间的推移会越来越快的出现随机位置随机大小的小星星，点击小小星星就会消失。游戏功能如下： 开始游戏 暂停游戏 结束游戏 游戏时常记录 游戏分数统计，记录消掉星星的个数 游戏血条显示，设定结束关卡为10个星星 技术点备注 消除星星时通过obj.onclick=remove;再通过remove()函数：this.parentNode.removeChild(this);进行消除 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;style type="text/css"&gt; *&#123; margin: 0px; padding: 0px; &#125; #blood&#123; margin-top:5px; width: 300px; height: 30px; border: 1px solid red; display:block; &#125; #blood2&#123; display: inline-block; width:300px; height: 30px; background: red; &#125; &lt;/style&gt; &lt;script type="text/javascript"&gt; var time,time2,time3; var count=0; var score = 0; var i=1000; var n=0; //启动定时器 function start()&#123; window.clearInterval(time); if(i&gt;100)&#123;i-=100;&#125; //设定当页面出现的星星超过10个就结束游戏 time = window.setInterval('show()',i); &#125; //加快速度 function speed()&#123; window.clearInterval(time2); window.clearInterval(time3); //显示游戏进行的时间 time3 = window.setInterval("timeOver()",1000); //点击开始默认先加载一次 window.setTimeout("start()",0); time2 = window.setInterval("start()",5000); &#125; //开始显示星星 function show()&#123; //创建对象 var obj = document.createElement('img'); //设置对象属性 //生成随机大小的星星 var size = Math.floor(Math.random()*30+30); //生成随机的位置坐标,首先获取屏幕尺寸的大小 var h = parseInt(screen.availHeight); var w = parseInt(screen.availWidth); var x = Math.floor(Math.random()*(w-w*0.2)+w*0.1); var y = Math.floor(Math.random()*(h-h*0.4)+h*0.1); //通过src设置图片路径 obj.src="images/xingxing.png"; obj.width = size; //必须通过定位才能使用top和left功能 obj.style.position = "absolute"; obj.style.top = y + "px"; obj.style.left = x+ "px"; //写入内容到页面中 document.body.appendChild(obj); //记录写入到页面的次数 count++; //设置血条的长度 var obj4 = document.getElementById("blood2"); obj4.style.width = 300-(count * 30) +"px"; //设定超过次数就结束游戏 if (count&gt;=10)&#123; alert("游戏结束，得分"+score+"分"); window.clearInterval(time); window.clearInterval(time2); window.clearInterval(time3); //游戏结束，清楚所有星星通过重新加载页面 location.reload(); &#125; //添加点击事件用来消除星星 obj.onclick=remove; &#125; //消除星星 function remove()&#123; this.parentNode.removeChild(this); //记录消除的次数 count--; //计算总分数 score++; var obj5=document.getElementById("score"); obj5.innerHTML="得分:"+score+"分"; &#125; //显示游戏进行的时间 function timeOver()&#123; n++; var obj3 = document.getElementById("overTime"); obj3.innerHTML="游戏进行了"+n+"秒"; &#125; //暂停游戏 function pause()&#123; alert("暂停游戏"); &#125; &lt;/script&gt; &lt;title&gt;星星小游戏&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="开始游戏" onclick="speed()"&gt;&lt;/input&gt;&lt;input type="button" value="暂停游戏" onclick="pause()"&gt;&lt;/input&gt;&lt;span id="overTime"&gt;游戏进行了0秒&lt;/span&gt;｜&lt;span id="score"&gt;得分:0分&lt;/span&gt;&lt;span id="blood"&gt;&lt;span id="blood2"&gt;&lt;/span&gt;&lt;/span&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>代码</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmd Markdown 简明语法手册]]></title>
    <url>%2F2015%2F20150710-3.html</url>
    <content type="text"><![CDATA[『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』 Cmd Markdown 简明语法手册标签： Cmd-Markdown 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 示例： 这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 野火烧不尽，春风吹又生。 7. 行内代码块使用 `代码` 表示行内代码块。 示例： 让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 示例： Cmd Markdown 高阶语法手册1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 更多语法参考：流程图语法参考8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 更多语法参考：序列图语法参考9. 表格支持 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 10. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 11. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： &lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 12. 内嵌图标本站的图标系统对外开放，在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 13. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： [ ] Cmd Markdown 开发 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [ ] 支持以 PDF 格式导出文稿 [x] 新增Todo列表功能 语法参考 [x] 改进 LaTex 功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 语法参考 [ ] 七月旅行准备 [ ] 准备邮轮上需要携带的物品 [ ] 浏览日本免税店的物品 [x] 购买蓝宝石公主号七月一日的船票 [^footnote]: 这是一个 注脚 的 文本。 [^footnote2]: 这是另一个 注脚 的 文本。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F20150710-1.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post12$ hexo new "My New Post"$ hexo new post &lt;title&gt; More info: Writing Set the Directory1234tags:- 标签categories:- 分类 Run server12$ hexo server$ hexo s More info: Server Generate static files12$ hexo generate$ hexo g More info: Generating Deploy to remote sites12$ hexo deploy$ hexo d More info: Deployment Clean the cache1$ hexo clean hexo pro1$ hexo g -d]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
